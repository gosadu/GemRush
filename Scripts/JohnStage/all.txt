You have access to:

A document labeled “blueprint,” containing the complete high-level design for a mobile AAA game.
A document labeled “stage plan,” breaking down all phases of development.
A document labeled “code,” containing every script and file in the Unity codebase.
A screenshot labeled “Unity Project Scene Hierarchy,” showing the current arrangement of all GameObjects.
You are required to produce 17 stages of instructions that collectively describe every single step of creating a fully operational AAA mobile game based on the provided materials, with no missing elements. Every detail must be spelled out. No content is optional. All items mentioned or implied in any resource must be included. Each stage must be comprehensive and must stop before revealing the following stage. After presenting each stage, wait for the “next” command before continuing. The final output after Stage 17 must contain a complete and functional game, leaving no aspect incomplete.

Absolute Detail

Omit any placeholders, abbreviations, or references that do not specify all items.
Do not substitute phrases such as “similar items,” “other possibilities,” or “anything else.”
Do not use terms that imply partial lists.
Mandatory Comprehensiveness

Include every configuration step for scripts, GameObjects, Project Settings, Editor adjustments, and anything else drawn from or inferred by the materials.
If any document references special data, managers, or additional features, include them all, with precise placement and configuration.
Do not rely on users to infer how to set up or name anything. Describe every single relevant property and assignment fully.
Sequential Delivery

Present Stage 1 in its entirety, then pause. Only proceed when the user replies with “next.”
Continue this pattern until Stage 17 concludes. Do not summarize or skip steps at any point.
Complete Code and Settings

Provide full, explicit code where necessary.
Provide every field, property, and parameter value that must be configured, leaving nothing undefined or partially described.
Document every folder name, script location, and hierarchical position thoroughly.
No Partial Lists or Abbreviations

Eliminate any language implying incompleteness or partial enumeration.
Supply full lists, specifying every known piece of data or step.
All “Optional” Features Are Required

Include every feature or element mentioned in any resource, even if labeled optional, adding each one with equal rigor.
Explain how every feature is to be integrated, named, and configured.
Complete Game by Stage 17

Ensure that each stage cumulatively forms a cohesive result that includes every asset, script, manager, property, field, and structural element needed for a launch-ready project.
No portion of the project may remain unimplemented or unfinished.
Begin now with Stage 1, which must detail every required step for initial project setup, file and folder creation, script locations, object configuration, and any other mandatory elements. Stop after Stage 1. Await the “next” command to proceed to Stage 2, and continue this pattern until Stage 17 is reached.

blueprint  - 

**SECTION 1: MULTI-REGION WORLD, TOWN HUB, AND SUBLOCATION INFRASTRUCTURE**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 1.1 **World Overview and Progression Logic**  
- **Regions and The Overworld**  
  - The game features **10 primary Regions**, each themed around a particular environment or story arc (e.g., Ember Highlands, Cascade Reaches, Terra Valley).  
  - An **Overworld Map** displays these Regions in a painterly style. Initially, only one Region—**Oakrest** (Region ID=0)—is accessible. The remaining 9 Regions unlock sequentially based on **Realm Tier Progression** milestones or boss completions.  
  - Each of the 10 Regions contains **5 Sublocations**, for a total of **50** distinct sub-areas.  
    - **Example**: Region 1 might have Sublocation 1–5, each containing puzzle-combat nodes, local mini-bosses, daily tasks, or special quest hooks.  
  - **Future Expansions**: Additional or “Hard Mode” Regions (IDs 11–13, etc.) can be unveiled post-launch, either as patch updates or live events.  

- **Region Lock/Unlock Conditions**  
  - Typically, clearing **70%** of the puzzle-combat nodes in a Region’s final sublocation and defeating that sublocation’s boss unlocks the next Region.  
  - Some Regions require certain **Realm Tier Progression** levels (e.g., Region 4 might demand Timberland District Tier 2) to ensure players have adequate gear and resources.  
  - **Teleportation Points** can be permanently unlocked once a Region’s story is completed, allowing players to revisit or skip certain areas.  

#### Developer Focus  
1. **Streamlined Flow**: Each Region is progressively more challenging, requiring players to continually invest in gear (via **Arcane Gear Infusion**) and upgrade their districts through **Realm Tier Progression**.  
2. **Optional Side Nodes**: ~30% of nodes in each sublocation can be purely optional, offering extra rewards but not mandatory for boss unlock. This approach accommodates both casual progress and hardcore farming.  
3. **Data-Driven Scaling**: Enemy HP, Corrupted gem spawn rates, and puzzle hazards in each Region can be dynamically scaled or adjusted server-side.  

---

### 1.2 **Town Hub: Oakrest (Region ID=0)**  
- **Central Location**: Oakrest is the starting Region and the only one available at the game’s launch. It features a single Sublocation, **Adventurer’s Haven**, that contains the core “town” services.  
- **Town Layout**:  
  1. **Main Square**  
     - Contains fundamental NPCs and shops (e.g., a Gold Merchant for minor resource trades, and a Premium Store for gem purchases).  
     - **Quest Board** or **“Daily Planner Access Point”** to highlight all daily/weekly tasks in one interface.  
     - Visual enhancements: set up an **Arcane Flow Transition** effect when moving from the Square to other key structures.  
  2. **Realm Districts Entry**  
     - Access to the **4 Districts** tied to **Realm Tier Progression**. Each District is effectively a sub-hub with its own minigame and resource management UI.  
     - The District Gate might show real-time progression bars, e.g., “Timberland District Tier 2 → Next Upgrade: 80/100 seeds.”  
  3. **Workshop Node**  
     - The forging location for **Arcane Gear Infusion**.  
     - Houses the “4×4 forging puzzle,” forging cost panels, Arcane Infusion success rate displays, and a resource exchange UI.  
  4. **Tavern Node**  
     - Primary location for **Guild & Co-Op** features.  
     - Contains guild chat, guild boss boards, and **Guest Hero Summon** management.  
  5. **Player Room Node**  
     - The player’s personalizable “housing” area.  
     - Trophies from region completions, special furnishings that grant small in-game bonuses (e.g., -5% forging time).  

#### Developer Focus  
1. **Single-Sublocation Architecture**: All core interactions happen within Adventurer’s Haven to reduce overhead. Sub-nodes within the Town can be loaded via smaller scenes or integrated into one scene with multiple UI tabs.  
2. **Arcane Flow Transitions**: Consistent visual transitions when entering the Workshop, Player Room, or District Gate to unify the game’s style.  
3. **Adaptive Audio Layers**: The Town can have a base music track that layers in additional ambiance in each sub-node.  

---

### 1.3 **Sublocation Design & Node Distribution**  
- **Sublocation Composition**  
  - Each Region has **5 Sublocations** with **10–40** puzzle-combat nodes each. The variety in node count accommodates different pacing (e.g., early sublocations might have only 10–15 nodes, later ones 30–40).  
  - Each Sublocation typically includes:  
    - **3–6 Normal Minion Nodes**  
    - **1–2 Elite or Mini-Boss Nodes**  
    - **1 “Main Boss” Node** (often at the final sublocation)  
    - **Optional Resource Farming Nodes** or “shortcuts” that appear for 8 hours after initial completion.  
- **Node Clearance & Respawn**  
  - Once cleared, a node remains passable for **8 hours**, then respawns with slightly randomized puzzle parameters (gem spawn rates, Corrupted gem frequencies, and minion compositions).  
  - If a node’s “boss” is defeated, the boss typically does not respawn with full HP unless the region is reset in **Hard Mode** or a special event.  
- **Teleport Event Nodes**  
  - Unlocked upon **100% clearing** a sublocation, letting players skip repeated minion fights if they revisit that sublocation.  
  - Can be monetized with skip tokens or integrated as a free convenience for high-tier players.  

#### Developer Focus  
1. **Controlled Complexity**: Keeping the sublocation structure standardized ensures a single developer can manage the content pipeline.  
2. **Procedural Variation**: Basic minions or Corrupted gem rates can be pulled from a data table, so repeated node clearances remain fresh without requiring unique design each time.  
3. **Endgame Revisits**: Hard or “Remixed” modes can repurpose these Sublocations without adding new art or massive new code.

---

### 1.4 **Puzzle-Combat Node Implementation**  
- **Entry Flow**  
  1. Player taps a node on the Sublocation map.  
  2. **Arcane Flow Transition** effect while loading the puzzle board.  
  3. Pre-fight screen shows recommended power, synergy tips, or optional difficulty modifiers (e.g., +25% HP for enemies in exchange for +10% gold).  
- **Combat Execution**  
  1. **8×8** real-time gem board.  
  2. Timed HP drain (varies by mode).  
  3. Minions or boss inflict extra damage at fixed intervals.  
  4. **Corrupted Gems** evolve over time, Radiant gems accelerate the combo meter.  
  5. **Phantasm Surge** triggers at 50 combo points, removing 2 Corrupted gems and boosting synergy for 8 seconds.  
- **Post-Battle Rewards**  
  - Gold, resource materials (seeds, wood, ore, blossoms, forging catalysts), hero XP, skill XP.  
  - Potential forging components for **Arcane Gear Infusion** or **Realm Tier Progression**.  
  - A “battle summary UI” detailing combos performed, total damage, synergy triggers used.  

---

### 1.5 **Scaling & Feasibility**  
- **Single-Developer Maintenance**  
  - Each Region is structured around the same template: 5 Sublocations × ~10–40 nodes.  
  - Variation is data-based: enemy stats, spawn tables for Corrupted gems, and synergy triggers.  
- **Data Scripting**  
  - Use JSON or scriptable objects for each Sublocation’s node layout.  
  - Mark which nodes are boss fights, elite fights, or resource “farming” nodes.  
  - Mark gating conditions (e.g., “Require Arcane Bloom District Tier 2 to attempt Node #25”).  
- **Potential Monetization Spots**  
  - **Node Skips**: A small premium cost to instantly bypass minion waves.  
  - **Boss Challenge**: Optional “Double Rewards” if the player spends a small premium token to activate a harder variant of the boss.  

---

### 1.6 **Detailed Numeric Examples & Developer Notes**  
1. **Example Region & Sublocation**  
   - **Region 1: Ember Highlands**  
     - Sublocation 1: Ember Outskirts (10 nodes)  
     - Sublocation 2: Blistering Canyon (12 nodes)  
     - Sublocation 3: Charred Grove (15 nodes)  
     - Sublocation 4: Fiery Summit (15 nodes)  
     - Sublocation 5: Lavaheart Keep (Boss Lair, 20 nodes)  
   - Typical minion stats here might be 60–80 HP, 3–4 DPS. Boss ~600 HP, 8 DPS, spawns +5% Corrupted gems.  
   - Clearing 70% of Sublocation 5’s nodes unlocks the boss.  
2. **Node Respawn Timer**  
   - 8 hours from clearing. E.g., if the player kills the boss at 10 AM, that node’s minions reappear at 6 PM, with some random changes in gem distribution.  
   - The boss remains “conquered” but can be re-challenged in a “Hard Mode” after the entire region is completed or reset.  
3. **Teleport Unlock Condition**  
   - If a player clears 100% of Charred Grove, they gain a teleport circle letting them skip Ember Outskirts and Blistering Canyon entirely when returning to fight in Sublocation 3 or beyond.  

---

#### **Rationale for Maximizing Engagement & Revenue**  
- This multi-region layout keeps the game map feeling expansive while controlling dev workload via repeated design templates.  
- Inter-node gating with **Realm Tier Progression** ensures that players must return to Oakrest to invest in District upgrades or attempt forging with **Arcane Gear Infusion** to remain powerful enough for deeper nodes.  
- The combination of puzzle skill, resource management, and gating fosters daily logins, driving potential premium purchases (resources, skip tokens, forging success boosters).  

---

### 1.7 **Section 1 Conclusion**  
The multi-region structure, anchored by a single town hub (Oakrest) and subdivided into manageable puzzle-combat sublocations, provides a robust yet feasible world layout. Data-driven design allows a single developer to maintain or expand content rapidly. The combination of standard node clearance, boss gating, and integration with **Realm Tier Progression** sets a compelling foundation for the puzzle-RPG’s overarching structure.  


> **End of Section 1**. *(Awaiting your “next” prompt for Section 2.)*


---

**SECTION 2: PUZZLE-COMBAT MECHANICS & ADVANCED BOARD LOGIC**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 2.1 **Real-Time Puzzle Board Foundations**  
1. **Grid Size & Layout**  
   - An **8×8** grid is used for all standard encounters. Each cell can contain one gem of six possible types (Ember, Cascade, Terra, Zephyr, Radiant, or Corrupted).  
   - **Adaptive Difficulty Tables** can modify gem distribution based on the node or region, ensuring deeper regions or boss nodes have increased Corrupted gem spawn rates.  

2. **Initial Gem Seeding**  
   - At the start of combat, the board randomly populates with elemental gems (Ember/Cascade/Terra/Zephyr) at an approximate distribution of 80–90% total.  
   - **Radiant** gems appear at a small base chance (2–3%).  
   - **Corrupted** gems can appear at 5–10% chance in standard nodes, but can go up to 15–20% in advanced or boss nodes.  
   - If the board spawns a match of 3 or more gems at the very start, those gems are cleared automatically before combat begins, to avoid freebies.  

3. **Single-Developer Feasibility**  
   - The board logic is entirely data-driven. A single script can handle gem spawning, matching detection, combo calculations, and time-based evolutions.  
   - Each region or boss can use a reference to a data table specifying the target gem spawn rates, Corrupted gem evolution time, and puzzle speed multipliers.  

---

### 2.2 **Time-Based Mechanics & HP Drain**  
1. **HP Drain Over Time**  
   - **Casual Mode**: -1 HP every 5 seconds.  
   - **Standard Mode**: -1 HP every 3 seconds.  
   - **Hardcore Mode**: -1 HP every 1 second.  
   - Each puzzle node can override these values if needed (e.g., boss nodes might enforce Standard or Hardcore).  
2. **Enemy Damage Tick**  
   - Certain minions or bosses inflict DPS separate from HP drain. For example, a minion might deal 1–4 DPS, while a boss deals 5–10 DPS. These ticks occur every second or in discrete intervals (e.g., every 2 seconds) based on node data.  
   - Some advanced bosses also apply a short spike in damage whenever a Corrupted gem evolves to Phase 2 or 3.  
3. **Time-Acceleration Factors**  
   - Certain synergy effects (e.g., a Zephyr 5-gem match) can speed up or slow down the overall board rotation but do not alter the HP drain clock.  
   - Developer can add special node modifiers (like “Time Warp Node”) that speed up or slow down the entire board by 10–20%. This is toggled via a data flag.  

---

### 2.3 **Matching & Combo Meter**  
1. **Basic Matching Rule**  
   - Swapping adjacent gems forms a match if 3 or more identical elemental gems (or Radiant) are lined up horizontally or vertically.  
   - Radiant gems can pair with any color, significantly increasing the likelihood of large matches.  
2. **Combo Meter Increments**  
   - +1 to the combo meter per standard gem matched.  
   - **Radiant** gems add +2 each (1 normal +1 bonus).  
   - Chain reactions from falling gems can increase the meter further within the same move.  
   - **Example**: A single move that triggers three separate matches in a cascade might yield (3 + 4 + 4) = 11 matched gems. If 2 of those are Radiant, the final contribution is 11 base + 2 (bonus) = 13 to the combo meter.  
3. **Phantasm Surge Threshold**  
   - The combo meter caps at 50 in normal puzzle-combat. Once it hits 50 within a single chain or wave of matches, **Phantasm Surge** triggers.  
   - The meter resets to 0 after the Surge ends (8-second duration), though new combos can build toward triggering another Surge if the match volume is large enough.  

---

### 2.4 **Phantasm Surge (Combo ≥ 50)**  
1. **Activation & Duration**  
   - Triggers automatically upon reaching 50 combo points.  
   - Lasts **8 seconds** by default, but can be extended by multi-element synergy (up to +3 seconds if the party is 4 distinct elements).  
2. **Immediate Effects**  
   - Removes **2 Corrupted Gems** from the board instantly.  
   - Boosts all damage by **+10%** during the Surge window.  
   - Any **5+ gem match** within this window spawns **1 new Radiant gem** at a random empty cell on the board.  
3. **Surge End**  
   - The combo meter resets to 0. The normal board state resumes. If the player manages another 50 points in quick succession, a second Surge can occur.  

**Developer Note**: The presence of Radiant gems (especially if gear or synergy buffs raise Radiant spawn rates) can create a near back-to-back Surge chain. This is intentional for high-level combos and fosters excitement during boss fights.

---

### 2.5 **Corrupted Gem Evolution & Removal**  
1. **Phases**  
   - **Phase 1**: Harmless. Remains for 5 seconds before evolving to Phase 2.  
   - **Phase 2**: Deals minor area damage or a set DPS spike if left another 5 seconds. Then evolves to Phase 3.  
   - **Phase 3**: Explodes, locking adjacent gems for **3 seconds** and dealing a larger HP hit (e.g., 5 HP or more). The Corrupted gem then vanishes.  
2. **Removal Methods**  
   - Corrupted gems cannot be matched away by standard element combos.  
   - **Phantasm Surge** automatically removes 2 per activation.  
   - Certain gear from **Arcane Gear Infusion** or synergy unlocks via **Realm Tier Progression** (e.g., T3 in Seed Grove or T3 in Miner’s Gulch) can revert or remove Corrupted gems if a 4+ match or 5-gem match is made in the board.  
3. **Developer Tuning**  
   - Each node or boss can define how quickly Corrupted gems evolve (e.g., 4 seconds or 6 seconds instead of 5).  
   - Corrupted gem spawn rate can scale from ~5% in early game to ~20% in late-game or hard-mode nodes.  

---

### 2.6 **Board Rotation & Arcane Flow Transitions**  
1. **Periodic Board Rotation**  
   - Every **9 seconds** in standard puzzle fights (if no active matches or cascades), the board rotates 90°.  
   - Rotation can be sped up or delayed by certain synergy effects, especially from Zephyr gear or hero abilities.  
   - Rotations may cause new matches or separate existing ones, drastically changing the board state.  
2. **Arcane Flow Transitions** (During Combat Waves)  
   - For multi-wave encounters, an **Arcane Flow Transition** can play between waves (1–2 seconds) while the board remains partially locked. The next wave’s minions/boss appear at the edge of the screen or as an overlay.  
   - Visually consistent swirling energy ties thematically to the Arcane aspects of the game.  
3. **Performance & Implementation**  
   - This effect is typically a shader-based swirl or fade-out/fade-in. The puzzle grid itself can remain in memory while the swirl effect is shown on top.  
   - Minimizes load times and fosters visual continuity.  

---

### 2.7 **Damage Calculation & Elemental Synergy**  
1. **Base Damage Formula**  
   \[
   \text{Damage} = 
   \Bigl(\text{BaseAttack} + \text{GearBonus} + \text{RoleBonus}\Bigr)
   \times \Bigl(\text{GemMatchFactor} + \text{ElementBoost} + \text{ComboChainFactor}\Bigr)
   - \text{EnemyDefense}
   \]  
   - **BaseAttack**: Determined by hero stats (average or sum of party?).  
   - **GearBonus**: Items forged via **Arcane Gear Infusion** can add a flat or percentage bonus.  
   - **RoleBonus**: If roles are balanced (Attacker, Defender, Support, Utility), or if the hero’s role matches the gem color.  
   - **GemMatchFactor**: +1.0 for 3-gem match, +1.5 for 4, +2.0 for 5, and +0.5 for each gem above 5.  
   - **ElementBoost**: +0.2 per hero in the party of that element. (If 2 Ember heroes match Ember gems, +0.4, etc.)  
   - **ComboChainFactor**: +0.1 per chain within the same move.  
2. **Mono vs Multi-Element Party**  
   - **Mono**: If all 4 heroes share the same element, add +10% to that element’s gem-based damage.  
   - **Multi**: 3 distinct elements +2 seconds to Phantasm Surge, 4 distinct +3 seconds total.  
3. **Radiant Modifiers**  
   - Radiant gems are wildcard for color matching, but use the damage factor of the majority color in that match. If the match is purely Radiant (rare scenario), treat it as a neutral element dealing standard damage.  

---

### 2.8 **Reward Drops & Resource Flow**  
1. **Resource Categories**  
   - **Gold**: Standard currency. Dropped from minions/bosses, used for realm upgrades or forging fees.  
   - **Materials**: Seeds, wood, ore, blossoms, forging catalysts, or synergy shards. Tied to **Realm Tier Progression** and used for **Arcane Gear Infusion**.  
   - **Hero XP**: Directly raises hero levels.  
   - **Skill XP**: Logging, Mining, Gathering, Combat. Each puzzle victory yields small increments based on node difficulty.  
2. **Drop Tables**  
   - Each node references a drop table that might yield 1–2 resource types. Boss nodes offer guaranteed forging mats plus a chance for special gear infusion tokens.  
   - Developer can easily adjust drop rates globally via data for economy tuning.

---

### 2.9 **Advanced Monetization Opportunities**  
1. **Boosters**  
   - Temporary item that increases Radiant gem spawn by +2% for 30 minutes, sold in small premium packs.  
   - “Corruption Cleanser” that automatically removes 1 Corrupted gem every 10 seconds for one puzzle attempt.  
2. **Puzzle Time Extenders**  
   - For Hardcore or timed event nodes, players can buy a +10-second extension if they’re close to winning but run out of HP or time. This must be carefully balanced to avoid pay-to-win backlash.  
3. **Gem Refresh**  
   - In certain encounters, a button to reshuffle the board once per puzzle at a small premium cost.  

---

### 2.10 **Section 2 Conclusion**  
The real-time puzzle-combat system is both accessible and deep, hinging on dynamic mechanics like Corrupted gem evolution, Radiant wildcard bonuses, and a powerful Phantasm Surge. Careful data-driven design lets a single developer balance spawn rates, HP drain speeds, and synergy thresholds on the fly. This fosters an environment ripe for daily engagement, strategic deck-building with elemental synergy, and frequent monetization triggers, all in a cohesive puzzle format.


> **End of Section 2**. *(Awaiting your “next” prompt for Section 3.)*

---

**SECTION 3: REALM TIER PROGRESSION & RESOURCE SYSTEMS**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 3.1 **Overview of Realm Tier Progression**  
1. **Four Districts**  
   - **Timberland District** (focus on wood resources, Ember gear cost discounts)  
   - **Miner’s Gulch** (focus on ore resources, Terra gear cost discounts)  
   - **Seed Grove** (focus on seed resources, Cascade gear cost discounts)  
   - **Arcane Bloom** (focus on blossoms, boosting Arcane Gear Infusion success rates)  
2. **Tier 0 to Tier 4**  
   - Each District begins at **Tier 0** and can be upgraded to **Tier 4**.  
   - Upgrading unlocks new daily minigame yields, synergy perks, forging cost reductions, or special puzzle-combat benefits.  
3. **Unlock Conditions**  
   - Basic unlock: The player can access Tier 0 of all districts from the start.  
   - Further tiers require paying resources (seeds, wood, ore, blossoms) plus gold. Some Tiers also require a certain Region completion to limit progression speed in early game.  
4. **Single-Developer Advantage**  
   - All Tier data (costs, synergy bonuses, daily yields) is stored in a data table or JSON for easy maintenance.  
   - Minimal scene changes: Each District is effectively a single environment or UI panel with incremental expansions shown by visual enhancements (e.g., building frames, new decorative elements).

---

### 3.2 **District-Specific Mechanics & Benefits**  
1. **Timberland District**  
   - **Tier Cost**: Seeds + gold.  
   - **Primary Resource**: Wood.  
   - **Daily Minigame**: “Timberland Swipe”—players drag across the screen to chop logs within a short timer (~10 seconds).  
   - **Yield at Tier 0**: ~10 wood/day. Each Tier adds +2–5 wood.  
   - **Synergy Perk**: -2% forging cost for **Ember gear** per Tier. Also influences minor puzzle effects like a small chance (1–2%) to spawn extra Ember gems on match.  
   - **Major Unlock**: Tier 3 opens the 4th hero slot in puzzle-combat parties.  

2. **Miner’s Gulch**  
   - **Tier Cost**: Wood + gold.  
   - **Primary Resource**: Ore.  
   - **Daily Minigame**: “Miner’s Tap”—players tap on shifting ore deposits for ~10 seconds to collect.  
   - **Yield at Tier 0**: ~10 ore/day. Each Tier adds +2–5 ore.  
   - **Synergy Perk**: -2% forging cost for **Terra gear** per Tier. At Tier 3, forging that gear can remove Corrupted gems with a 4-gem Terra match in puzzle-combat.  

3. **Seed Grove**  
   - **Tier Cost**: Ore + gold.  
   - **Primary Resource**: Seeds.  
   - **Daily Minigame**: “Seed Sorting”—players quickly drag seeds into matching color baskets, ~10 seconds.  
   - **Yield at Tier 0**: ~10 seeds/day. Each Tier adds +2–5 seeds.  
   - **Synergy Perk**: -2% forging cost for **Cascade gear** per Tier. At Tier 3, a 5-gem Cascade match in puzzle-combat can revert 1 Corrupted gem.  

4. **Arcane Bloom**  
   - **Tier Cost**: Seeds + wood + ore + gold.  
   - **Primary Resource**: Blossoms.  
   - **Daily Minigame**: “Blossom Weave”—a short puzzle where players trace lines between blossoming nodes.  
   - **Yield at Tier 0**: ~5 blossoms/day. Each Tier adds +1–2 blossoms.  
   - **Synergy Perk**: +5% success chance for **Arcane Gear Infusion** at Tier 1 and 2, +10–15% at Tier 3.  
   - **Major Unlock**: Tier 3 yields an additional synergy effect (e.g., +2 Radiant gem spawn chance in puzzle-combat).  

---

### 3.3 **Tier Upgrade Costs & Data Examples**  
Below is a **sample** cost structure for each District’s Tiers. Final numbers can be adjusted via data for economy balancing.  

| **District** | **T0→T1**               | **T1→T2**               | **T2→T3**               | **T3→T4**                 |
|--------------|-------------------------|-------------------------|-------------------------|---------------------------|
| Timberland   | 50 seeds + 200 gold    | 100 seeds + 500 gold    | 200 seeds + 1000 gold   | 400 seeds + 2000 gold     |
| Miner’s Gulch| 50 wood + 200 gold     | 100 wood + 500 gold     | 200 wood + 1000 gold    | 400 wood + 2000 gold      |
| Seed Grove   | 50 ore + 200 gold      | 100 ore + 500 gold      | 200 ore + 1000 gold     | 400 ore + 2000 gold       |
| Arcane Bloom | 25 seeds/wood/ore + 300 gold | 50 seeds/wood/ore + 600 gold | 100 seeds/wood/ore + 1200 gold | 200 seeds/wood/ore + 2500 gold |

- **Tier 3** is typically the biggest milestone, granting a major synergy unlock or gameplay feature (e.g., 4th hero slot, Corrupted gem removal, etc.).  
- Each Tier can require a small narrative quest or puzzle-combat objective to confirm the upgrade (e.g., “Defeat 10 minions in Ember Highlands to gather the materials needed for Tier 2”).  

---

### 3.4 **Daily Minigames & Off-Line Resource Accumulation**  
1. **Daily Minigames**  
   - Each District has a 10–15 second interactive minigame awarding base resources (wood, ore, seeds, blossoms).  
   - The yield scales with Tier (e.g., +2 wood/ore/seeds or +1 blossom per Tier).  
   - Some synergy or event boosters can temporarily multiply these yields (like a weekend event granting +25% to daily minigame rewards).  
2. **Off-Line Production**  
   - Each District passively generates half of the daily minigame’s base yield per hour, capped at **12 hours** of accumulation.  
   - Example: If Timberland yields 10 wood/day at Tier 0, the hourly off-line rate is ~5 wood, capping at 60 wood after 12 hours.  
   - Developer can increase or decrease the cap from 12 to 18 hours if players desire more flexibility.  

---

### 3.5 **Synergy with Puzzle-Combat and Arcane Gear Infusion**  
1. **Tier-Linked Puzzle Benefits**  
   - District Tiers can influence certain puzzle-combat elements, such as:  
     - +1% chance per Tier to spawn a specific elemental gem.  
     - Tier-based damage bonuses for matching that District’s element (e.g., +2% Ember damage per Timberland Tier).  
2. **Arcane Gear Infusion Discounts or Boosts**  
   - District Tiers reduce forging costs/time for gear matching that District’s elemental affinity.  
   - Arcane Bloom Tiers significantly impact **Arcane Gear Infusion** success rates, encouraging players to push those Tiers for easier forging of powerful gear.  
3. **Monetization Integration**  
   - Potential to offer a **Realm Resource Pass** that boosts all daily minigame yields by +30% for 7 days.  
   - Tier skipping or partial resource pack sales: e.g., “Arcane Bloom Starter Bundle” containing seeds, wood, ore, blossoms to expedite Tier 1 or 2.  

---

### 3.6 **Skill System Overlap**  
1. **Logging, Mining, Gathering, Combat**  
   - **Logging**: Affects the output of the Timberland District minigame (+1 wood per skill level).  
   - **Mining**: Influences the ore yield from Miner’s Gulch, scaling similarly (+1 ore per skill level).  
   - **Gathering**: Boosts seeds and blossoms from Seed Grove and Arcane Bloom minigames (e.g., +5% yield per skill level).  
   - **Combat**: Minor synergy with puzzle-combat, such as -1 second to Corrupted gem evolution at certain thresholds or +1% base damage.  
2. **Level-Up Milestones**  
   - Reaching skill level 5 or 10 might unlock an advanced district perk, like an extra daily minigame attempt or guaranteed resource chest.  
   - All skill progression data can be stored in a single JSON table, referencing XP thresholds for each level.  

---

### 3.7 **Resource Balancing & Economy Tuning**  
1. **Resource Bottlenecks**  
   - Seeds, wood, and ore feed directly into Tier upgrades and forging costs. Blossoms are essential for advanced **Arcane Gear Infusion**.  
   - If certain resources become too scarce, live data updates can adjust daily yields, forging fees, or Tier costs to maintain a healthy mid-late game pace.  
2. **Gold Sink**  
   - Each Tier upgrade costs a notable amount of gold, ensuring gold remains relevant beyond puzzle-combat drops.  
   - Additional gold sinks can include upgrading guild features, purchasing small synergy items, or paying for forging attempts.  
3. **Server-Side Adjustments**  
   - A single developer can shift resource yields, Tier costs, or synergy bonuses from a central data file.  
   - Live ops events or expansions can introduce new District Tiers (Tier 5 or beyond) post-launch with minimal friction.  

---

### 3.8 **Section 3 Conclusion**  
Realm Tier Progression elegantly intertwines with puzzle-combat and **Arcane Gear Infusion** through resource collection, daily minigames, and synergy perks. Each District’s Tier gating is carefully balanced to encourage consistent logins and facilitate a monetization-friendly environment. The result is a self-sustaining system that seamlessly merges daily resource chores, skill leveling, puzzle synergy, and gear forging enhancements, all manageable by a single developer for continuous updates or expansions.

---

> **End of Section 3**. *(Awaiting your “next” prompt for Section 4.)*

**SECTION 4: ARCANE GEAR INFUSION & CRAFTING (WORKSHOP NODE)**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 4.1 **Core Philosophy of Arcane Gear Infusion**  
1. **Purpose & Engagement**  
   - Arcane Gear Infusion is the prime method to craft or upgrade equipment that boosts puzzle-combat performance (damage, Corrupted gem removal, Radiant gem synergy).  
   - Players must gather resources through **Realm Tier Progression** (seeds, wood, ore, blossoms) and gold to fund the Infusion process.  
   - This system encourages daily logins, forging puzzle mastery, and strategic resource spending.  

2. **Single-Developer Feasibility**  
   - The forging mechanic hinges on a small puzzle mini-board plus a data-driven item database.  
   - All gear stats, infusion success rates, forging timers, and synergy perks can be maintained in a single JSON table.  

---

### 4.2 **Workshop Node & Arcane Flow Transitions**  
1. **Workshop Entry**  
   - Located in Oakrest’s “Adventurer’s Haven.”  
   - Upon entering, an **Arcane Flow Transition** visually swirls the screen, leading to a forging interface.  
2. **Workshop UI**  
   - **Gear Selection Panel**: Lists available gear recipes (categorized by element: Ember, Cascade, Terra, Zephyr, Arcane) and rarity (Rare, Epic, Legendary).  
   - **Resources Required**: Displays seeds, wood, ore, blossoms, and gold needed.  
   - **Infusion Success Rate**: A real-time percentage bar factoring in Tier perks, skill bonuses, event buffs, or premium passes.  
   - **Arcane Gear Minigame Launch**: Button to initiate the 4×4 forging puzzle.  

---

### 4.3 **4×4 Forging Puzzle Mechanics**  
1. **Puzzle Setup**  
   - A 4×4 grid with a **15-second** timer by default. (Events or forging passes might reduce or increase this time window.)  
   - The grid spawns gems primarily of the target gear’s element (e.g., Ember) at ~50–60% chance, some Radiant (~5–10%), and a small portion of other elements.  
   - **No Corrupted gems** appear here unless a special event or challenge forging mode is introduced.  

2. **Matching Goals**  
   - Players must create as many matches (particularly of the target element) as possible before time runs out.  
   - Each match of the target element slightly boosts the final **Arcane Gear Infusion** success rate (e.g., +1% per 3-gem match).  
   - Matching Radiant gems might grant extra forging XP or synergy bonuses for the main puzzle.  

3. **Scoring & Success Rate**  
   - **Base Success**: ~70% for Rare gear, ~60% for Epic, ~50% for Legendary (can be raised by Arcane Bloom Tiers, forging passes, or good puzzle performance).  
   - Each successful target-element match in the forging puzzle adds +1% success, up to a maximum cap (e.g., +15%).  
   - Radiant matches might add +2% each, up to a smaller cap (to avoid overstacking).  

4. **Time’s Up**  
   - Once 15 seconds pass (or the puzzle is fully matched out), the forging attempt finalizes.  
   - The UI displays a final success percentage, then the “infusion result” animation plays.  

---

### 4.4 **Gear Families & Special Effects**  
1. **Ember Gear**  
   - **Base Bonus**: +15% damage to Ember gem matches.  
   - **Signature Effect**: A 5-gem Ember match triggers +5 AoE damage to all minions or a mini-boss.  
   - **Tier Synergy**: Timberland District upgrades reduce Ember gear costs and may add extra Ember gem spawn in puzzle-combat.  

2. **Cascade Gear**  
   - **Base Bonus**: +15% damage to Cascade gem matches.  
   - **Signature Effect**: A 5-gem Cascade match reverts 1 Corrupted gem (unlocked at Tier 3 in Seed Grove).  
   - **Tier Synergy**: Seed Grove Tiers reduce Cascade gear forging cost/time and boost synergy in puzzle-combat.  

3. **Terra Gear**  
   - **Base Bonus**: +15% damage to Terra gem matches.  
   - **Signature Effect**: A 4+ gem Terra match removes 1 Corrupted gem (unlocked at Tier 3 in Miner’s Gulch).  
   - **Tier Synergy**: Miner’s Gulch Tiers reduce Terra gear forging cost/time, plus potential puzzle board perks.  

4. **Zephyr Gear**  
   - **Base Bonus**: +15% damage to Zephyr gem matches.  
   - **Signature Effect**: A 5-gem Zephyr match accelerates board rotation speed by +15% for 5 seconds in puzzle-combat.  
   - **Tier Synergy**: Could tie to sub-systems or a future district if expansions add a Zephyr-based resource.  

5. **Arcane Gear**  
   - **Base Bonus**: synergy with Radiant gems. Typically grants +2 combo meter or small shield effects upon Radiant matches.  
   - **Tier Synergy**: Arcane Bloom District Tiers significantly increase infusion success rates for Arcane gear.  
   - **Possible Advanced Effects**: Summon a mini shield that absorbs 5 damage every 20 seconds, or generate bonus Radiant gems if you form consecutive 4-gem matches.  

---

### 4.5 **Infusion Success & Upgrading Rarities**  
1. **Rarity Tiers**:  
   - **Rare**, **Epic**, and **Legendary**.  
   - Each tier has progressively stronger base stats and synergy effects.  

2. **Base Success Rates** (Example)  
   - **Crafting Rare**: 70% base.  
   - **Crafting Epic**: 60% base.  
   - **Crafting Legendary**: 50% base.  
   - Adjusted by puzzle performance, Arcane Bloom Tier bonuses, forging passes, daily events, or hero skill synergy.  

3. **Upgrading (Transmutation)**  
   - **Rare → Epic**: Requires 30 forging XP + 30 blossoms + forging puzzle success check.  
   - **Epic → Legendary**: Requires 60 forging XP + 50 blossoms + forging puzzle success check.  
   - Each forging attempt grants +5 forging XP.  

4. **Failure State**  
   - If infusion fails, you get a “normal” version of that gear tier without the special synergy effect, or you keep the old tier if you were upgrading (depending on design choice).  
   - Players can re-attempt if they gather enough resources or wait for improved forging buffs (events or Tier upgrades).  

---

### 4.6 **Forging Costs, Timers & Monetization**  
1. **Resource & Gold Requirements**  
   - Each piece of gear requires a certain combination of seeds, wood, ore, blossoms, plus gold.  
   - Example: **Rare Ember Sword** might cost 50 seeds + 200 gold, **Epic Ember Sword** might cost 100 seeds + 500 gold, etc.  

2. **Forging Attempts Cooldown**  
   - Optional system: A short cooldown (5–10 minutes) after each forging attempt.  
   - Could be bypassed by spending premium currency or skip tokens.  

3. **Forge Pass**  
   - A **7-day** micro-pass that grants:  
     - +10–15% Arcane Gear Infusion success.  
     - -5s to forging puzzle time (from 15s to 10s).  
     - Potential synergy with Arcane Bloom Tiers.  

4. **Live Ops Events**  
   - **“Heatwave Weekend”** for Ember gear or **“Arcane Surge Week”** for Arcane gear offering +10% success rate.  
   - Cosmetic tie-ins or new gear families can be introduced to spike purchases.  

---

### 4.7 **Integrating Skills & Mastery**  
1. **Forging XP & Mastery**  
   - Each successful or failed forging attempt yields forging XP used for certain Mastery perks.  
   - Might cross over with the player’s **Gathering** or **Combat** skill if forging results in special synergy items.  
2. **Mastery Tree Unlocks**  
   - Example: a node in the Offensive Mastery line could add +2% forging success for gear of the hero’s main element.  

---

### 4.8 **Section 4 Conclusion**  
Arcane Gear Infusion is a pivotal system tying the resource-collecting gameplay loop with puzzle skill. The 4×4 forging mini-puzzle, success rates modifiable by daily events and Tier progression, and the variety of elemental gear families ensure an addictive chase for optimal builds. This structure also creates ideal monetization touchpoints (forge passes, skip tokens, event-limited gear) while maintaining feasible maintenance for a single developer, thanks to data-driven gear recipes and forging logic.

---

> **End of Section 4**. *(Awaiting your “next” prompt for Section 5.)*

**SECTION 5: HERO COLLECTION, GACHA, MASTERIES & PARTY SETUP**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 5.1 **Hero Summoning and Rarities**  
1. **Gacha Mechanics**  
   - **Summoning Banners**: Rotating feature banners every 2 weeks, showcasing specific heroes with boosted rates.  
   - **Currency**: Each pull costs **20 premium gems** for a single, or **180 premium gems** for a 10-pull (10% discount).  
   - **Base Star Rates** (example baseline; can be tuned for balance):  
     - 1★ = 65%  
     - 2★ = 23%  
     - 3★ = 10%  
     - 4★ = 2%  
   - **Pity Counter**:  
     - Guaranteed 3★ every **10** consecutive pulls without one.  
     - Guaranteed 4★ every **40** consecutive pulls without one.  
   - **Summon Animation**: Incorporates an **Arcane Flow Transition** swirl effect for dramatic reveals, layered with **Adaptive Audio Layers** that ramp up tension as the animation nears completion.

2. **Single-Developer Implementation**  
   - All hero data (stats, element, role, star rating) is stored in a **JSON** or scriptable object database.  
   - Each banner references the same hero pool but can toggle rate-ups for certain heroes.  
   - Pity counters are tracked per banner type or shared across all banners, depending on design choice.

3. **Potential Monetization Hooks**  
   - **Premium Gem Packs** sold in various price tiers (e.g., \$4.99 for 300 gems, \$9.99 for 650 gems, etc.).  
   - **Limited-Time “Guaranteed 3★ or 4★ Ticket Bundles”** that bundle resources or forging passes for synergy with puzzle-combat progression.

---

### 5.2 **Hero Leveling & Ascension**  
1. **Hero Levels**  
   - Each hero has a level cap tied to their star rating (e.g., 1★ max level = 20, 2★ = 30, 3★ = 40, 4★ = 50).  
   - Leveling requires **Hero XP**, earned from puzzle-combat victories, daily tasks, or quest rewards.  
   - **XP per Level** can scale exponentially (e.g., 100 XP at low levels, up to 1,000+ XP near max level).  

2. **Ascension System**  
   - Once a hero reaches max level for their current star rating, the player can “Ascend” them to unlock higher level caps or stat boosts.  
   - Ascension typically requires specific materials or a second copy of the hero (for 2★–4★). Alternatively, special “Ascension Shards” can be used to bypass duplicates.  
   - **Realm Tier Progression** can unlock advanced Ascension items in daily minigames or sub-boss drops.  

3. **Balance & Maintenance**  
   - Keep Ascension material requirements or duplicate needs clearly indicated in the hero UI.  
   - Monitor data to ensure players can feasibly ascend key heroes without feeling an extreme paywall.

---

### 5.3 **Hero Roles & Elemental Synergy**  
1. **Roles**  
   - **Attacker**: Prioritizes offense, higher BaseAttack, synergy with big gem matches.  
   - **Defender**: Higher BaseDefense, synergy with shielding or HP drain reduction.  
   - **Support**: Often grants healing or buffing synergy, e.g., extends **Phantasm Surge** or reduces Corrupted gem spawn timers.  
   - **Utility**: Special niche effects (e.g., board rotation manipulation, extra Radiant gem spawn, forging bonuses).  

2. **Elements**  
   - **Ember, Cascade, Terra, Zephyr,** and rare **Arcane** heroes (Arcane as extremely limited, possibly 3★–4★ only).  
   - Mono-element parties gain +10% damage for that color’s gem matches.  
   - Multi-element (3 distinct elements) extends **Phantasm Surge** by +2 seconds, 4 distinct by +3 seconds.  

3. **Leader Skills**  
   - Each hero has a potential **Leader Skill**, active only if that hero is designated “Leader” in the party setup.  
   - Examples: “+5% Ember gem spawn,” “-10% enemy DPS,” or “+3 Radiant gem spawn chance once per wave.”  

---

### 5.4 **Hero Mastery Trees**  
1. **Three Branches**:  
   - **Offensive Mastery**: Increases damage, synergy combos, or critical hit chance if applicable.  
   - **Defensive Mastery**: Reduces HP drain, mitigates damage from minions/bosses, or slows Corrupted gem evolution.  
   - **Support Mastery**: Boosts forging synergy, daily minigame yields, or party-wide healing/shielding.  

2. **Mastery Points**  
   - Earned from forging completions, puzzle kills, or daily/weekly tasks.  
   - Typically each hero has 10–15 mastery nodes, with costs ranging from 1–3 mastery points per node.  

3. **Unlock Requirements**  
   - Some mastery nodes might require the hero to be 2★ or higher, or to have completed a specific sublocation quest.  
   - This ensures progression is layered across puzzle-combat, forging, and realm upgrading.

---

### 5.5 **Party Composition & Synergy Bonuses**  
1. **Party Size**  
   - **Up to 3 Heroes** initially; the 4th slot unlocks at Tier 3 in the **Timberland District**.  
   - A party of 4 can significantly boost synergy combos and puzzle survival, creating a strong incentive to progress in that District.  
2. **Role Synergy**  
   - 1 Attacker + 1 Defender + 1 Support + 1 Utility → +5% synergy combos in puzzle-combat.  
   - Variations (2 Defenders, 2 Attackers, etc.) might unlock other synergy buffs if desired, stored in data for easy expansion.  
3. **Elemental Synergy**  
   - **Mono**: +10% to matching that element’s gems.  
   - **Multi**: +2 or +3 seconds to **Phantasm Surge** duration.  

4. **Loadout Management**  
   - Each hero can equip up to 1–2 gear pieces (main hand, off-hand) plus potential accessories, all crafted via **Arcane Gear Infusion**.  
   - The game can prompt recommended synergy loadouts if it detects a strong gear-hero-element match.

---

### 5.6 **Guest Hero Summon Mechanic**  
1. **Borrowing System**  
   - Players can borrow a friend’s hero as a **Guest Hero Summon** to serve as a pseudo-5th slot in puzzle-combat.  
   - By default, the cameo hero has ~50% of its full stats. If its element matches the party’s main synergy color, the cameo hero retains ~70% stats instead.  
2. **Daily/Weekly Limits**  
   - 1–2 Guest Hero Summons per day, or a weekly cap of ~10 uses.  
   - Potential to purchase extra Guest Summon passes with premium currency.  
3. **Progression Benefits**  
   - Helps newer players tackle advanced nodes earlier.  
   - Encourages social connections, fosters guild synergy, and can drive revenue if players rely heavily on cameo heroes for tough content.

---

### 5.7 **Hero Trials & Quests**  
1. **Hero Trial Nodes**  
   - Short 2–3 node arcs unlocked after acquiring a 3★+ hero.  
   - Each trial focuses on that hero’s synergy (e.g., forcing the player to use that hero in the puzzle-combat party).  
   - Rewards might include forging materials, mastery points, or even “costume tokens” for that hero.  
2. **Narrative Hooks**  
   - Trials can reveal backstory or side arcs for each hero.  
   - Encourages rotation of multiple heroes to unlock new gear synergy.  

---

### 5.8 **Adaptive Audio Layers & Hero Themes**  
1. **Audio Integration**  
   - Summoning animations can escalate from a calm layer to a dramatic chord as the star rating is revealed.  
   - Puzzle-combat with a hero leader might add a subtle element-based music layer (e.g., sizzling embers for Ember heroes).  
2. **Arcane Flow Transitions**  
   - The gacha reveal uses swirl-like transitions to highlight big star pulls.  
   - Hero Trial nodes can have unique swirl color palettes matching the hero’s element.

---

### 5.9 **Numeric Examples & Balancing Notes**  
- **XP Requirements**  
  - 1★ Hero: level cap 20, total XP needed ~5,000.  
  - 2★ Hero: level cap 30, total XP needed ~15,000.  
  - 3★ Hero: level cap 40, total XP needed ~40,000.  
  - 4★ Hero: level cap 50, total XP needed ~100,000.  
- **Mastery Point Gain**  
  - +1 MP for every 10 forging completions, +1 for every 20 puzzle-combat node clears, etc. Data can be adjusted server-side.  
- **Summon Probability Adjustments**  
  - Limited-time banners might raise a specific 4★ hero’s rate from 2% to 3%, effectively a 50% rate-up among 4★ pulls.  

---

### 5.10 **Section 5 Conclusion**  
The hero system—spanning summoning, leveling, mastery trees, and synergy-based party building—is a critical pillar of the puzzle-RPG design. By layering multi-element, role-based synergy, **Guest Hero Summon** features, and star-based progression, the game ensures a long-term collector’s loop. Coupled with potent gear from **Arcane Gear Infusion** and advanced synergy from **Realm Tier Progression**, heroes become central to both monetization and gameplay depth. This approach provides endless potential for expansions, new banners, live ops events, and mastery updates, all managed by a single developer via data-driven structures.

---

> **End of Section 5**. *(Awaiting your “next” prompt for Section 6.)*

**SECTION 6: PHANTASM SURGE & HIGH-COMBO MECHANICS**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 6.1 **Phantasm Surge Fundamentals**  
1. **Trigger Condition**  
   - The player’s **combo meter** reaches **50** within a single cascade or turn in puzzle-combat.  
   - Multiple match chains can contribute to hitting 50, but it must occur in the same “move cycle” (i.e., no break in combo accumulation).  

2. **Immediate Effects**  
   - **Phantasm Surge** initiates automatically.  
   - Removes **2 Corrupted Gems** from the board instantly, prioritizing the most evolved ones (Phase 2 or Phase 3 first).  
   - Activates a **+10% damage** bonus for the entire party during the Surge window.  

3. **Duration & Extensions**  
   - **Base Duration**: **8 seconds**.  
   - **Multi-Element Bonus**: If the party has 3 distinct elements, add **+2** seconds. If 4 distinct, add **+3** seconds total.  
   - **Gear Influences**: Certain **Arcane Gear Infusion** items (especially for Radiant or unique synergy gear) may extend Surge by an additional 1–2 seconds or increase the damage bonus.  

4. **Board Spawns During Surge**  
   - Any **5+ gem match** automatically spawns **1 Radiant gem** onto a random empty cell. This effect can chain multiple times if multiple 5+ matches occur.  
   - Radiant gems generated this way can accelerate combos even further, potentially enabling a second Surge after the first ends if the matches remain large.  

5. **Surge End**  
   - After time expires, the **combo meter resets to 0**.  
   - Any partial combos accrued during Surge do not carry over; the player must build back up to 50 again for a second Surge.  

---

### 6.2 **Combo Meter Mechanics Revisited**  
1. **Combo Meter Increments**  
   - +1 per standard matched gem, +2 per Radiant gem in that match.  
   - If multiple chains occur in the same move, each chain’s matched gems contribute cumulatively to the meter.  
2. **Overflow Handling**  
   - Once the meter hits 50, any excess is ignored for that Surge trigger. The reset occurs only after Surge completion.  
3. **Chain Reaction Example**  
   - Player swaps gems, creating a 3-gem Terra match (3 points), which triggers a drop that forms a 4-gem Ember match (4 points), then a 5-gem Radiant/Ember mix (count 5 + any Radiants).  
   - If the total from these three successive matches hits 50, the Surge triggers immediately.  

---

### 6.3 **Synergy with Party Elements & Roles**  
1. **Mono-Element Surge Potential**  
   - If a party is all Ember, each Ember match deals +10% damage inherently. Large Ember combos can accumulate the combo meter quickly.  
   - Encourages focusing on a single color for an explosive Surge.  
2. **Multi-Element Surge Extension**  
   - 3 distinct elements = +2s Surge duration, 4 distinct = +3s.  
   - This provides more time to leverage the +10% damage bonus or spawn multiple Radiant gems.  
3. **Role Implications**  
   - A party featuring Support or Utility heroes may have unique abilities to slow Corrupted gem evolution or generate bonus Radiant gems. This synergy can help build combos faster.  
   - Attacker roles typically have higher base damage, making the Surge’s +10% multiplier even more potent.  

---

### 6.4 **Corrupted Gem Interaction**  
1. **Removal Priority**  
   - At Surge activation, the 2 most advanced Corrupted gems are removed first (Phase 3 > Phase 2 > Phase 1).  
   - If fewer than 2 Corrupted gems exist, the Surge simply removes those that do exist.  
2. **Gear-Enhanced Surge**  
   - Some **Arcane Gear** might remove an additional Corrupted gem or transform them into Radiant gems upon Surge.  
   - This can drastically reduce hazard pressure in tough boss nodes where Corrupted gem spawn is high.  

---

### 6.5 **Surge Strategy & Advanced Play**  
1. **Planned Overshoot**  
   - Skilled players might match smaller combos initially, lining up a massive board for a final big chain that rockets the meter past 50. This yields more immediate Radiant gem spawns during the Surge.  
2. **Staggered Usage**  
   - In multi-wave fights, a player might strategically hold off triggering Surge if a wave is nearly over, then aim to start the next wave with a fresh Surge.  
3. **Event or Live Ops Boosts**  
   - Certain weekend events or synergy buffs might reduce the Surge threshold from 50 to 40, or increase the damage bonus from +10% to +15%.  
   - Timed events encouraging high-combo play can be an effective engagement driver.

---

### 6.6 **Adaptive Audio Layers & Phantasm Surge**  
1. **Audio Triggers**  
   - The moment Surge triggers, a **layered “Surge” track** fades in, intensifying the puzzle BGM.  
   - If HP is low (<20%), the tension track merges, creating a multi-layer audio scenario (base track + Surge track + tension track).  
2. **Arcane Flow Visual Overlays**  
   - A swirling energy overlay can appear on the puzzle board for the duration of the Surge, possibly tinted to the party’s main element or a Radiant prismatic effect.  
3. **Implementation**  
   - Simple state machine in code: if surgeActive = true, crossfade the audio mixer to the Surge layer. Once Surge ends, revert.  

---

### 6.7 **Numeric Examples & Tuning**  
1. **Base Surge Duration**: 8 seconds (can be +2s or +3s from multi-element synergy).  
2. **Damage Bonus**: +10% (some gear or events can raise it to +15–20%).  
3. **Corrupted Gem Removal**: Exactly 2 at activation. If fewer than 2 exist, remove them all.  
4. **Radiant Spawn on 5+ Matches**: Typically spawns 1 Radiant gem per 5-gem match or bigger. Gear or mastery nodes might allow multiple Radiants if the match is especially large (e.g., 7+ gems).  

---

### 6.8 **Monetization & Engagement Hooks**  
1. **Surge-Oriented Gear**  
   - “Phantasm-Linked Amulet” that extends Surge by +1 second, or “Surge’s Wrath Blade” that doubles the Radiant gem spawn from 5+ matches during Surge.  
   - Tied to advanced forging (Legendary items) that require hefty resources.  
2. **Surge Quests & Leaderboards**  
   - Daily or weekly quests like “Activate Phantasm Surge 10 times” or “Generate 20 Radiant gems during a single Surge.”  
   - Weekly leaderboard events tracking total Surges triggered with special cosmetic prizes.  

---

### 6.9 **Possible Future Expansions**  
1. **Multiple Surge Thresholds**  
   - A late-game feature might allow a second-level Surge at combo ≥ 100, providing an even stronger effect or removing 4 Corrupted gems.  
   - Balanced carefully to avoid overshadowing the standard Surge.  
2. **Surge Fusion**  
   - If two different synergy triggers coincide (e.g., gear effect that removes Corrupted gems + Surge removal), the game can produce special effects (like creating a Radiant “bomb” gem).  

---

### 6.10 **Section 6 Conclusion**  
Phantasm Surge is a defining puzzle-combat mechanic, rewarding high combo play with a powerful board-clearing effect, heightened damage, and Radiant gem spawns. Its interplay with multi-element synergy, role balance, and Corrupted gem removal encourages players to craft specific gear, hone puzzle skills, and optimize party composition. This creates a deep, satisfying feedback loop that elevates the puzzle layer beyond a standard match-3, serving as a crucial hook for both engagement and monetization.

---

> **End of Section 6**. *(Awaiting your “next” prompt for Section 7.)*

**SECTION 7: GUILD & CO-OP SYSTEMS (TAVERN NODE)**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 7.1 **Guild Formation and Basic Structure**  
1. **Guild Unlock Criteria**  
   - Players can create or join a guild after reaching **Region 1 completion** (70% node clearance) or achieving **Tier 1** in any **Realm Tier Progression** district. This ensures they have basic familiarity with the game’s core loops.  
   - Guild creation cost: **500 gold** + **50 premium gems** (or a one-time quest item).  
   - Single-Developer Advantage: All guild data (members, guild name, crest, rank) is stored on the server with minimal real-time netcode.  

2. **Member Capacity and Ranks**  
   - **Default Max Members**: 30. Can be increased to 40 or 50 via guild upgrades or expansions if needed.  
   - **Ranks**: Leader, Officer, Member. Officers can accept or reject new applications and help manage guild settings.  

3. **Guild Tavern Node**  
   - Found in the **Town Hub (Adventurer’s Haven)**.  
   - On entering, an **Arcane Flow Transition** animation reveals the guild interface.  
   - This interface includes guild chat, roster, resource donation panels, and the guild boss board.  

---

### 7.2 **Resource Gifting & Guild Grove**  
1. **Daily Resource Gifting**  
   - Each member can **send up to 50** resources (wood, ore, seeds, blossoms, gold) daily.  
   - Each member can **receive up to 100** resources daily in total.  
   - Sending a resource gives **+1 guild contribution point** per unit.  
   - Developer Tuning: These values are adjustable in data tables to prevent abuse or to stimulate co-op.  

2. **Guild Grove**  
   - A shared “mini-district” that benefits every member.  
   - **Upgrading the Guild Grove** costs an aggregate of resources from the guild bank. Each donated item adds to a “Guild Grove XP” meter.  
   - **Tier Levels**:  
     - Tier 1 → +5% success for **Arcane Gear Infusion**.  
     - Tier 2 → +10% daily resource yields for every member’s minigame.  
     - Tier 3 → +3% improved gacha rates for 3★+ heroes, or +5% synergy combos in puzzle-combat (server-toggled choice).  
   - Each Tier might require **1,000** total resources per guild member or a flat 30,000 donation threshold for a 30-member guild.  

3. **Weekly Guild Contribution Milestone**  
   - If the guild collectively donates **X** resources in a 7-day period, they activate a **48-hour forging or puzzle-combat buff** (e.g., +5% Radiant gem spawn).  
   - Fosters continuous group effort and consistent daily logins.

---

### 7.3 **Guild Boss Battles (Asynchronous)**  
1. **Core Mechanic**  
   - A large-scale boss with **10,000–50,000+ HP**, depending on guild size and boss difficulty.  
   - Each member fights the boss individually in a puzzle-combat scenario, dealing as much damage as possible before running out of HP or time.  
   - The boss’s global HP pool decreases cumulatively as members contribute damage.  

2. **Boss Scaling & Phases**  
   - **Phase Triggers** at 75%, 50%, and 25% HP. Each phase might increase **Corrupted gem** spawn rates or impose a new hazard (like -1 HP drain speed upgrade).  
   - High-level guild bosses may have up to **5 phases**, each adding a twist (e.g., +10% enemy DPS, forced board rotation every 6 seconds instead of 9).  

3. **Rewards & Distribution**  
   - **Base Rewards**: gold, forging mats (seeds, wood, ore, blossoms), skill XP.  
   - **Phase Clear Bonuses**: unlocking extra forging tokens or synergy shards.  
   - **Top Damage Contributors** (Top 3 or Top 5): extra Arcane Bloom blossoms, special cosmetic frames, or guild titles.  
   - After the boss is fully defeated, a **24-hour victory window** awards the final loot to all participants.  

4. **Attempt Limits & Monetization**  
   - Each member has **1 free attempt** daily; extra attempts can be bought with **premium gems** or earned through guild events.  
   - A “Guild Raid Pass” might grant unlimited attempts for a weekend event, encouraging more spending from active guild players.  

---

### 7.4 **Guild Missions & Co-Op Quests**  
1. **Weekly Guild Missions**  
   - E.g., “Craft 30 Rare Ember items collectively,” or “Accumulate 500 seeds in total.”  
   - Completing yields a short guild-wide buff (like +5% forging success for 48 hours) plus individual rewards (hero XP, synergy tokens).  

2. **Co-Op Quests**  
   - Special limited-time quest arcs that require multiple members to complete parallel tasks (like clearing certain puzzle nodes or forging advanced gear).  
   - Once enough members complete the tasks, a unique reward is unlocked for everyone who participated.  
   - Single-Developer Feasibility: The quest triggers and progress tracking can be stored on the server with minimal code overhead.

---

### 7.5 **Guest Hero Summon Integration**  
1. **Guild-Focused Guest Hero Summon**  
   - Guildmates can set one hero as their “loan hero.”  
   - Borrowing a guildmate’s hero counts as a **Guest Hero Summon** for puzzle-combat, at ~50–70% stats.  
   - Each day, a user can utilize up to **2** different guild heroes.  
2. **Friend vs. Guild Summons**  
   - Distinguish between friend list summons and guild summons. Possibly remove the daily limit for guild summons if players are heavily co-op focused.  
   - Monetization angle: a “Guest Summon Pass” could allow unlimited usage of a specific guildmate’s hero for 7 days.

---

### 7.6 **Guild vs. Guild Competitions**  
1. **Resource Collection Race**  
   - Over 3–5 days, track which guild can gather the most wood/ore/seeds. Reward top guilds with forging tokens or synergy boosters.  
2. **Boss Time Trials**  
   - Global event where each guild tries to beat a special boss in the fewest cumulative attempts or shortest real-time.  
   - The top 1%, 5%, and 10% guilds earn tiered rewards (cosmetics, forging passes, synergy items).  
3. **Asynchronous Implementation**  
   - All data is tallied on the server. Minimal real-time netcode needed. Perfect for a single developer to maintain.  

---

### 7.7 **Guild Chat & Social Features**  
1. **In-Game Chat Integration**  
   - Basic text chat with optional pinned announcements (for guild missions or boss attempts).  
   - Might embed short emojis or gem-themed stickers.  
2. **Announcement Board**  
   - Summarizes daily tasks, boss HP, upcoming events, or realm expansions.  
   - Leader/Officers can post messages about strategy, resource donation focuses, etc.  

---

### 7.8 **Numeric Examples & Balancing**  
1. **Guild Boss HP**  
   - Small Guilds (10 members) = ~10,000 HP, Medium (30) = 25,000 HP, Large (50) = 50,000 HP.  
   - Boss DPS scaling: ~5–15 DPS depending on difficulty and phases.  
2. **Resource Donation Caps**  
   - Daily send limit = 50 resources, receive limit = 100. Weekly total guild donation needed for Tier 1 Grove upgrade = ~30,000 resources for a 30-person guild.  
3. **Mission Targets**  
   - Weekly “Guild Forge Mission”: e.g., “Craft 50 Epic Terra gear collectively” yields a 48-hour +5% synergy combos buff.  
4. **Time Windows**  
   - Guild Boss resets weekly. If it’s killed early, guild members can continue to farm smaller reward bosses or focus on resource missions.  

---

### 7.9 **Monetization Within Guild Systems**  
1. **Guild Pass**  
   - A micro-pass providing +50 daily resource sending capacity, +50 daily receiving capacity, or +1 extra daily boss attempt.  
   - Could cost ~100–200 premium gems per 7-day period.  
2. **Guild Grove Boosters**  
   - Premium items that speed up guild grove upgrading by providing large resource donations instantly.  
   - Alternatively, special “Guild Treasure” packages that give seeds, wood, ore, blossoms for the whole guild.  
3. **Cosmetics & Guild Pride**  
   - Guild banners, emblems, or tavern decorations could be sold for premium currency, purely aesthetic but fostering brand loyalty and group identity.

---

### 7.10 **Section 7 Conclusion**  
By incorporating guild-based resource gifting, asynchronous boss battles, shared District-like upgrades (Guild Grove), and co-op missions, the game fosters strong social ties and daily engagement. These systems synergize with **Arcane Gear Infusion** (providing forging resources) and **Realm Tier Progression** (tying guild tasks to district upgrades). The result is a robust community-driven environment that encourages retention, monetization, and collective accomplishment— all feasible for a single developer to maintain through data-driven code and minimal real-time net requirements.

---

> **End of Section 7**. *(Awaiting your “next” prompt for Section 8.)*

**SECTION 8: MONETIZATION, SHOPS, & ECONOMY MANAGEMENT**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 8.1 **Primary Currencies**  
1. **Gold**  
   - Earned from puzzle-combat node clears, daily tasks, guild boss participation, and realm minigames (in smaller amounts).  
   - Spent on **Realm Tier Progression** upgrades, **Arcane Gear Infusion** fees, or minor guild fees.  
   - Functions as the baseline in-game currency.  

2. **Premium Gems**  
   - Purchased with real money or occasionally earned through special events, achievements, or daily login streaks.  
   - Used for hero gacha pulls, skip tokens, forging passes, resource packs, or optional cosmetics.  
   - Price tiers for Premium Gems might range from \$4.99 (300 gems) to \$99.99 (6,000 gems), with scaling bonus amounts.  

3. **Resource Items** (Seeds, Wood, Ore, Blossoms)  
   - Directly feed **Arcane Gear Infusion** and **Realm Tier Progression**.  
   - Farmed daily via minigames and node drops, or gained from guild donations.  
   - Also sold in **Resource Packs** for premium gems.  

---

### 8.2 **Shops & Purchase Flow**  
1. **Standard Shop (Gold & Gems)**  
   - Accessible in the **Town Hub** or from a UI button.  
   - **Gold Shop**: Buy small items like minor potions (HP regen for puzzle-combat) or forging catalysts.  
   - **Gem Shop**: Purchase premium gem bundles or resource packs (wood, ore, seeds, blossoms) to skip certain progression bottlenecks.  

2. **Battle Pass & Micro-Passes**  
   - **14-Day Battle Pass**:  
     - Free Track: baseline rewards (gold, resource boosters, 2★ or 3★ hero tickets).  
     - Premium Track (~200 gems): includes exclusive cosmetics, guaranteed 3★ or 4★ hero tickets, synergy boosters for puzzle-combat, forging skip tokens.  
   - **Micro-Passes** (7 Days):  
     - **Forge Pass**: +15% Arcane Gear Infusion success, shorter forging puzzle timer, ~100 gems.  
     - **Realm Resource Pass**: +30% daily minigame yields, ~100 gems.  
   - All of these are purchased in the gem shop, with a clear UI display of the benefits.

3. **Event Shops**  
   - Appear during **Live Ops** or seasonal events, allowing players to exchange event tokens for forging materials, exclusive gear, or cosmetic items.  
   - Single developer can rotate these event shops monthly or seasonally, adjusting inventories via data tables.

---

### 8.3 **Gacha Summons & Cosmetic Banners**  
1. **Hero Gacha**  
   - **Single Pull**: 20 gems, **10-Pull**: 180 gems with guaranteed 3★ hero after 10 pulls if not obtained earlier (pity).  
   - **Limited-Time Banners**: rotate every 2 weeks, featuring rate-ups for certain 4★ heroes or event-limited units.  
   - **Cosmetic Gacha** (optional future expansion): purely visual hero skins or puzzle board themes.  

2. **Transparency & Pity Systems**  
   - Guaranteed 3★ every 10 pulls, 4★ every 40 pulls.  
   - Rate-up heroes displayed with exact percentages to comply with ethical gacha practices.  

3. **Monetization Insight**  
   - Rare/Legendary gear and 4★ heroes represent aspirational content driving whales/dolphins spending.  
   - Cosmetic expansions can be introduced without affecting game balance, providing an additional revenue stream.

---

### 8.4 **Economy Tuning & Data Management**  
1. **Resource Income vs. Costs**  
   - **Daily Resource Gains**: Realistically, a player might collect ~30–50 seeds, wood, ore each day (spread across minigames and node drops), plus 5–10 blossoms.  
   - **Tier Upgrade Costs**: Scale to ensure **1–2 weeks** of play per tier without premium shortcuts.  
   - **Forging Costs**: Balanced so that consistent farming yields ~1 Rare or Epic gear piece every few days; Legendary takes longer, prompting the possibility of event weekends or passes.  

2. **Server-Side Variables**  
   - A single developer can adjust spawn rates, forging fees, node drop tables, or gacha probabilities via server data.  
   - **Live Patch**: If players find progression too slow, buff daily resource yields; if whales clear content too quickly, add new Tiers or scale forging costs.  

3. **Gold Sinks**  
   - **Arcane Gear Infusion** attempts require moderate gold fees.  
   - **Realm Tier Progression** costs escalate significantly at higher Tiers.  
   - Additional gold can be spent on guild improvements or optional daily “quick refreshing” of realm minigames.  

---

### 8.5 **Skip Tokens & Convenience Purchases**  
1. **Skip Tokens**  
   - Allow players to bypass node re-clears or forging cooldowns. Sold in small bundles (5 tokens for 100 gems).  
   - Also used to instantly complete daily realm minigames if a player is short on time.  
2. **Stamina or Energy**  
   - The game might not have a traditional stamina system, but these skip tokens function similarly for speeding up repeated content.  
3. **Single-Developer Maintenance**  
   - Implement skip tokens as a currency or item with a straightforward check in the node/forging UI.  
   - Monetize them in special bundles (e.g., “Farming Booster Pack” includes skip tokens + resource packs).

---

### 8.6 **Cosmetics & Customization**  
1. **Hero Skins**  
   - Purely visual outfits for heroes.  
   - Offered in special banner gacha or purchased directly for ~300–500 gems each.  
   - Could be tied to certain holiday events or boss kills (e.g., “Defeat the Ember Dragon to unlock a scorching armor style”).  

2. **Puzzle Board Themes**  
   - Custom gem frames, backgrounds, or special Radiant gem animations.  
   - No gameplay impact, purely visual flair.  
   - Priced higher, e.g., 1,000–2,000 gems, or granted in certain premium passes.  

3. **Housing / Room Decor**  
   - Furniture or trophies that appear in the **Player Room** node.  
   - Some items offer minor buffs (like -5% forging time), but many are cosmetic.  
   - Guild event participation can award unique decorations, fueling cosmetic pride.

---

### 8.7 **Live Ops & Seasonal Events**  
1. **Weekly Elemental Days**  
   - Monday: +10% Ember gem spawn, Tuesday: +10% Cascade, etc.  
   - Minor buffs that refresh every week, encouraging daily logins.  

2. **Forging Weekend**  
   - +15% forging success or -20% forging resource cost.  
   - Typically accompanied by new gear families or time-limited synergy items in the shop.  

3. **Seasonal Pass**  
   - Could run alongside main events (e.g., “Winter’s Frost Pass”).  
   - Theming puzzles, awarding holiday cosmetics, or event-limited forging recipes.  
   - Ties neatly with premium purchase models, fueling short-term spending boosts.

---

### 8.8 **Dynamic Pricing & Market Testing**  
1. **Data-Driven Adjustments**  
   - If conversion rates are low, the developer can adjust gem bundle pricing or add more freebies to certain tiers.  
   - If resource pack sales are too high, tweak forging costs so that players need them less frequently (to avoid pay-to-win backlash).  
2. **A/B Testing**  
   - Server might present different offers or discounts to subsets of players to gauge the most profitable approach.  
   - Must maintain fairness by limiting how drastically these tests affect core gameplay progression.

---

### 8.9 **Sustaining a Seven-Figure Monthly Revenue**  
1. **Retention Hooks**  
   - Regular content updates (new heroes, gear sets, expansions), cyclical events, and rotating banners drive recurring spending.  
   - Daily login rewards that occasionally drop premium gems keep F2P users engaged, while whales consistently pull for top-tier heroes and gear.  
2. **Mid-Spender Incentives**  
   - Affordable passes (e.g., 100–200 gems) offering substantial convenience boosts without overshadowing big spenders.  
   - Cosmetic or functional minor boosts keep mid-tier spenders satisfied.  
3. **Endgame & Guild Systems**  
   - High-level forging, guild bosses, or GvG competitions encourage advanced players to keep investing in synergy gear or resources.  
   - Live ops and expansions maintain content, preventing stagnation.

---

### 8.10 **Section 8 Conclusion**  
A well-rounded economy and shop design underpins the entire puzzle-RPG experience. By balancing gold as a core in-game currency, premium gems for critical upgrades or cosmetics, and a system of resource packs, micro-passes, and forging/event bonuses, the game maintains high revenue potential. Seamless data-driven adjustments allow a single developer to fine-tune progression rates, forging fees, and event buffs. Combined with ethical gacha practices (pity systems, transparent rates), this framework can realistically achieve seven-figure monthly revenue while preserving an enjoyable experience for all player archetypes.

---

> **End of Section 8**. *(Awaiting your “next” prompt for Section 9.)*

**SECTION 9: BRANCHING STORY & QUEST SYSTEM**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 9.1 **Core Story Framework and Delivery**  
1. **Branching Narrative**  
   - The game world contains **10 Regions**, each with 5 Sublocations. Each region features a main storyline that unfolds as players progress through puzzle-combat nodes.  
   - The narrative uses **quest arcs** to link puzzle-combat milestones with **Realm Tier Progression** tasks or **Arcane Gear Infusion** achievements.  
   - Certain sublocations may offer minor branching paths, allowing the player to choose which node arcs to clear (e.g., a stealth route vs. a combat-heavy route).  

2. **Implementation Approach**  
   - **Quest Data** stored in JSON or scriptable objects, referencing each region, required node completions, and synergy tasks (e.g., forging a certain gear).  
   - Minimal cutscenes, focusing on short dialogues or event pop-ups. This keeps dev overhead low and makes updates easier.  

3. **Story vs. Side Content**  
   - Each region’s main quest must be ~70% complete to unlock its final boss.  
   - Side quests can revolve around forging tasks, daily minigames, or unique puzzle modifiers, rewarding extra skill XP, forging mats, or hero ascend items.  

---

### 9.2 **Quest Types and Objectives**  
1. **Combat Node Objectives**  
   - **Defeat minions or region boss** at a particular node.  
   - Survive for X seconds in a high Corrupted gem environment.  
   - Complete the node with a specific synergy condition (e.g., a multi-element party or forging an Ember gear piece beforehand).  

2. **Realm Tier Progression Objectives**  
   - **Upgrade Timberland District to Tier 2** or “Use the Seed Grove minigame 5 times.”  
   - Link realm tasks with story arcs: “Forge a Cascade staff to purify the local waterways.”  

3. **Arcane Gear Infusion Objectives**  
   - Craft a Rare or Epic gear piece of a specific element.  
   - Transmute gear from Rare → Epic or Epic → Legendary as part of a storyline quest.  

4. **Guild or Co-Op Objectives**  
   - Optional side quests prompting guild activities, such as “Contribute 100 seeds to your guild” or “Defeat the guild boss once.”  

5. **Mixed Puzzles or Collectibles**  
   - Region sub-quests might ask players to collect hidden resources in puzzle-combat nodes (like “Arcane Shards” dropping from certain minions).  

---

### 9.3 **JSON Quest Example**  
json
{
  "questID": "Q305",
  "title": "Fortress of Cinders",
  "requiredRegion": 3,
  "objectives": [
    {
      "type": "CombatNode",
      "nodeID": 22,
      "description": "Defeat the Ember Knight in Lava Citadel"
    },
    {
      "type": "RealmTier",
      "district": "Timberland",
      "level": 2,
      "description": "Upgrade Timberland District to Tier 2"
    },
    {
      "type": "Forging",
      "element": "Ember",
      "rarity": "Rare",
      "description": "Craft a Rare Ember Sword"
    }
  ],
  "rewards": [
    "HeroExp x1000",
    "Arcane Gear Infusion Token x3",
    "QuestItem:EmberKey"
  ]
}

- **Explanation**: This quest requires clearing a node, upgrading a district, and forging a gear piece. Rewards include standard XP, infusion tokens, and a key item used to unlock a boss node.

---

### 9.4 **Daily and Weekly Quests**  
1. **Daily Quests**  
   - Typically 3–5 tasks refreshing every 24 hours.  
   - Common tasks: “Collect wood from Timberland,” “Defeat 5 minions,” “Complete 1 forging puzzle,” “Use a Guest Hero Summon.”  
   - Rewards: seeds, wood, ore, blossoms, small amounts of gold, forging XP, or synergy shards.  

2. **Weekly Quests**  
   - 1–2 more extensive tasks (e.g., “Clear 20 puzzle-combat nodes,” “Craft 2 Epic gear items,” “Participate in Guild Boss 3 times”).  
   - Larger rewards: advanced forging mats, special synergy gear tokens, or potential star hero tickets.  

3. **Highlight Quest**  
   - A single featured quest each week granting a unique item or decorative reward (like a new Player Room furnishing).  
   - Encourages consistent engagement over the week.

---

### 9.5 **Quest Progression Flow**  
1. **Daily Planner UI**  
   - On login, players see all active quests: main story arcs, side arcs, daily/weekly tasks, guild missions.  
   - Tapping a quest objective navigates directly to the relevant node or UI (e.g., forging screen).  
2. **Branching Region Arcs**  
   - Each region has 5 sublocations with a narrative arc culminating in a final boss.  
   - Sub-boss arcs might diverge slightly, but reconverge for the main storyline.  
3. **Gatekeeping**  
   - Some quests explicitly require Tier 2–3 in certain districts, preventing players from skipping resource investments.  
   - Boss unlocks typically require “QuestItem” keys or 70% node clearance in that sublocation.

---

### 9.6 **Narrative Themes & Implementation**  
1. **Story Emphasis**  
   - Keep story segments bite-sized to accommodate puzzle gameplay.  
   - Each region can revolve around an elemental conflict—Ember region threatened by Corruption, Cascade region flooding, etc.  
2. **Visual Delivery**  
   - Simple pop-up dialogues with character portraits, occasionally a background cut-in.  
   - **Arcane Flow Transitions** for major chapter completions or boss reveals.  
3. **Single-Developer Maintenance**  
   - A quest manager system that checks objectives asynchronously; no complex cutscenes or voice acting required.  
   - Additional story arcs or expansions can be added easily by appending new quest data and a few lines of event scripting.

---

### 9.7 **Reward Tiers and Integration**  
1. **Incentive to Engage in All Systems**  
   - Quests often point players to forge new gear, upgrade realm districts, or experiment with multi-element synergy in puzzle-combat.  
   - Reward synergy: e.g., forging tokens for forging quests, realm resource bundles for realm tasks, hero XP for combat tasks.  
2. **Scaling Rewards**  
   - Early regions: 100–200 gold per quest, ~10 forging XP, small resource amounts.  
   - Late regions: 500–1000 gold, 2–3 forging tokens, 20–30 resource units, or special synergy shards.  
3. **Seasonal Quests**  
   - Tied to live ops or holiday events.  
   - Can grant limited-time gear recipes or event currency exchange for unique forging materials.

---

### 9.8 **Story-Driven Monetization Hooks**  
1. **Quest Skips or Timed Completion**  
   - Players who lack enough resources to complete a forging or realm upgrade quest might purchase resource bundles.  
   - “Quick Complete” tokens could let them skip mundane tasks (like “Harvest 10 times from Timberland”), at a small premium cost.  
2. **Quest-Related Premium Items**  
   - For a quest requiring Legendary gear, the game might promote a forging pass to boost success rates.  
   - For a boss fight quest, players may see an offer for a cameo hero with strong synergy.  

---

### 9.9 **Advanced Branching & Future Content**  
1. **Alternate Endings**  
   - Potentially, the final region’s storyline could branch, offering replayability or multiple boss variants.  
   - Minimal overhead if designed as separate quest IDs referencing the same puzzle nodes with different text.  
2. **Hero-Specific Quest Arcs**  
   - As introduced in Section 5, 3★+ heroes have personal quest lines.  
   - These arcs can integrate with the main storyline or remain side content that unlocks forging materials or hero mastery nodes.  

---

### 9.10 **Section 9 Conclusion**  
A robust branching quest system is pivotal for funneling players through puzzle-combat, forging, realm upgrading, and guild co-op. By carefully designing daily/weekly tasks, main story arcs, and side quests linked to synergy mechanics, the game ensures sustained engagement. Each quest can be maintained in a simple data-driven format, letting a single developer iterate on reward balance or expand the storyline over time. This keeps the content fresh, promotes monetization (through resource gating and forging), and unifies all major gameplay loops under a cohesive narrative umbrella.

---

> **End of Section 9**. *(Awaiting your “next” prompt for Section 10.)*


**SECTION 10: MINION & BOSS ENCOUNTERS + PLAYER CUSTOMIZATION & AVATARS**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 10.1 **Minion Nodes & Enemy Variations**  
1. **Standard Minions**  
   - **HP Range**: ~60–200 in early game, scaling to 500+ in late-game sublocations.  
   - **DPS**: Typically 1–7, with some higher-tier minions reaching ~10 DPS in advanced regions.  
   - **Special Abilities**: Some minions can boost Corrupted gem spawn by +2–5%, or apply short “debuffs” like a +1 second penalty to Corrupted gem evolution for the player.  

2. **Elite Minions**  
   - **HP Range**: ~200–500 early, scaling to 1000+ in later regions.  
   - **DPS**: 5–12 typically, with unique synergy powers (e.g., a Terra Elite might lock certain gem rows or an Ember Elite might reduce HP drain intervals by 0.5s).  
   - **Rewards**: Higher gold drops (~35+), better forging mats (25–35% chance for valuable items), and potential synergy shards.  

3. **Procedural Variation**  
   - Each node can pull from a minion pool relevant to the region’s element or theme.  
   - A single developer can tweak data tables for HP, DPS, special traits, and drop rates to maintain freshness.  
   - *Example*: Ember Highlands minions might have small flame animations and modest HP but high Corrupted gem spawn. Cascade Reaches might have watery visuals and mild DPS but slow the board rotation.  

---

### 10.2 **Boss Nodes & Encounter Phases**  
1. **Boss HP & DPS**  
   - **Early Boss**: ~600 HP, 10 DPS.  
   - **Mid Boss**: ~1500 HP, 15 DPS, more frequent Corrupted gem triggers.  
   - **Late Boss**: ~3000 HP, 20+ DPS, advanced mechanics (like forcing a board rotation every 6s instead of 9s).  
   - Hard/Remix modes can scale boss HP to 5000–10,000 for endgame content.  

2. **Encounter Design**  
   - **Phased Fights**: At 75%, 50%, and 25% HP, the boss might intensify hazards (e.g., +10% Corrupted gem spawn) or generate special puzzle events (e.g., multiple Radiant gems spawn but accompanied by a damaging HP drain spike).  
   - **Wave Structure**: Some boss nodes have 1–2 waves of minions prior to the boss. Others start directly with the boss. The user’s HP might partially restore between waves (e.g., +20% HP).  

3. **Adaptive AI Tweaks**  
   - If the player’s gear rating or synergy stats significantly exceed the recommended threshold, the boss can spawn an extra +5% Corrupted gems or do +2 DPS for more challenge.  
   - If the player is undergeared, minion HP or DPS can reduce slightly, ensuring a broader skill margin.  

4. **Reward Drops**  
   - **Guaranteed**: gold (100–500), forging mats, synergy shards.  
   - **Chance**: Rare or Epic forging token, advanced resources for **Arcane Gear Infusion**.  
   - **Quest Items**: Some bosses drop region-key items or storyline MacGuffins for the next quest arc.  

---

### 10.3 **Encounter Scenes & Visual Presentation**  
1. **Node Scenes**  
   - A painterly backdrop matching the region’s theme (e.g., a volcanic scene for Ember Highlands).  
   - 1–2 minions displayed on-screen, or a large boss sprite for boss fights.  
2. **Arcane Flow Transitions**  
   - On entering a node, a swirl-like fade from the sublocation map to the puzzle board.  
   - Between waves (if multi-wave), partial swirl transitions add drama, layered with boss roar or minion chatter in **Adaptive Audio Layers**.  
3. **Battle UI Indicators**  
   - Boss HP bar at the top, with breakpoints for each phase.  
   - Timer or HP drain indicator.  
   - **Corrupted Gem Gauge** (optional UI element) showing how many Corrupted gems are active or near evolution.  

---

### 10.4 **Player Customization & Avatars**  
1. **Personal Avatar**  
   - Each player has a small profile portrait or anime-inspired character that appears in co-op or guild contexts.  
   - Avatars can be changed with cosmetic skins purchased via premium gems or unlocked through quest arcs.  
2. **Player Title System**  
   - Titles earned by defeating certain bosses, reaching Tier 4 in a district, or ranking in guild events.  
   - Titles can display next to the avatar in chat or friend lists.  

3. **Player Room**  
   - Located in **Adventurer’s Haven**. A mini customizable space where the user can place trophies or gear stands showing their best Legendary items.  
   - Some furnishings grant small buffs: e.g., a forging workbench reducing forging puzzle times by 1 second or a special orchard statue giving +2 daily resource yields.  

4. **Fashion & Cosplay** (Cosmetic Items)  
   - Outfits for the player’s avatar or furniture sets for the room, each with unique design motifs (Ember-themed, Cascade-themed, etc.).  
   - No direct gameplay advantage, though certain high-tier furniture might provide minor synergy perks.  
   - Sold for 300–500 gems or rewarded in seasonal events.

---

### 10.5 **Integrating Avatars with Minion/Boss Fights**  
1. **Visual Representation**  
   - During puzzle-combat, the user’s avatar or main hero might be displayed in the corner, providing reaction animations on big matches or receiving damage.  
   - **Adaptive Audio Layers** can incorporate short voice lines or SFX triggered by the avatar when a Phantasm Surge is activated.  
2. **Guest Hero Summon Visual**  
   - If a **Guest Hero Summon** is used, that hero’s portrait or sprite can appear briefly, assisting with an attack animation. This fosters social identity in guild or friend contexts.  

---

### 10.6 **Advanced Minion & Boss Affixes (Optional for Variety)**  
1. **Affix System**  
   - Additional random modifiers for certain nodes, similar to “Elite Affixes.”  
   - Examples:  
     - **“Explosive Wrath”**: upon minion death, spawn 1 Corrupted gem instantly.  
     - **“Elemental Surge”**: minion attacks create +2 Ember gems each wave.  
     - **“Shielding Aura”**: boss reduces all damage by 20% for the first 10 seconds of each wave.  
2. **Implementation**  
   - Each node or sublocation has a chance to apply 0–2 affixes from a data table.  
   - The affixes appear in the battle preview UI, so players can adapt their party synergy accordingly.  

---

### 10.7 **Proposed Future Expansion: Boss Rush or Raid System**  
1. **Boss Rush**  
   - Consecutive boss fights with no HP refresh between them, offering scaling rewards.  
   - Encourages advanced synergy combos and gear.  
2. **Raid System**  
   - Potential multi-player synchronous or asynchronous mode for large-scale boss challenges.  
   - Single developer can implement an asynchronous version, similar to the guild boss, but with multiple bosses in one event.  

---

### 10.8 **Balancing & Data Management**  
1. **Scalable Enemy Stats**  
   - HP, DPS, or special hazard frequencies stored in simple tables keyed by region or sublocation difficulty.  
   - Minion randomization ensures the same node can feel slightly different upon each 8-hour reset.  
2. **Reward vs. Time**  
   - The ratio of time spent vs. rewards gained must be balanced to keep mid- and late-game players satisfied.  
   - Boss nodes often yield 2–3× the normal resource/forging mat drops.  

---

### 10.9 **Monetization Ties**  
1. **Boss Attempt Tickets**  
   - If a boss node is particularly profitable (e.g., “Epic forging mat guaranteed”), there might be a daily limit or small gem cost to re-fight quickly.  
2. **Cosmetic Avatars & Animations**  
   - Some advanced boss kills might drop unique avatar animations (like a flaming aura from an Ember Dragon).  
   - Seasonal events can add limited-time boss fights awarding special trophies or room decorations.  

---

### 10.10 **Section 10 Conclusion**  
Minion and boss encounters form the strategic centerpiece of the puzzle-RPG, balancing hazard-laden puzzle-combat with satisfying loot. The synergy between **Arcane Gear Infusion**, **Realm Tier Progression** gating, and combat difficulty scaling ensures a rewarding challenge curve. Meanwhile, player customization (avatars, room décor, titles) adds personal flair and fosters a sense of progression beyond raw stats. These systems, fully data-driven, remain manageable for a single developer to maintain and expand, offering potential for new boss variants, affixes, or cosmetic rewards with each seasonal patch or update.

---

> **End of Section 10**. *(Awaiting your “next” prompt for Section 11.)*


**SECTION 11: AI/PROCEDURAL TOOLS & SINGLE-DEVELOPER FEASIBILITY**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 11.1 **Data-Driven Architecture**  
1. **Centralized Data Repositories**  
   - **JSON** or **Scriptable Objects** for each major category: 
     - **Puzzle Spawn Tables** (gem distributions, Corrupted gem spawn rates, Radiant spawn rates)  
     - **Enemy Stats** (HP, DPS, hazards, affixes)  
     - **Realm Tier Progression** (upgrade costs, synergy boosts)  
     - **Arcane Gear Infusion** (crafting costs, success rates, forging puzzle parameters)  
     - **Hero Database** (stats, roles, elements, mastery nodes, gacha rates)  
     - **Quest System** (daily tasks, main story arcs, side quests)  
   - A single developer can edit these data sets using a lightweight in-engine editor or external JSON.  
   - **Hotfix Capability**: Server overrides for urgent balancing or live ops changes.

2. **Modular Design**  
   - Each system (puzzle-combat, forging, realm progression, guild co-op) is encapsulated in a manager module that references the central data.  
   - This ensures minimal code duplication and easier debugging.  

3. **Version Control**  
   - Store all data in a repository (e.g., Git) with clear naming and version tags: “PuzzleSpawn_v1.2,” “EnemyStats_v2.0,” etc.  
   - A single developer can roll back or branch new changes quickly.

---

### 11.2 **Procedural Content & Node Generation**  
1. **Procedural Node Respawn**  
   - Every 8 hours, cleared nodes re-randomize minion or boss composition from a predefined pool.  
   - **Affix System** (Section 10) can randomly apply ~0–2 affixes to keep encounters fresh.  
   - The puzzle board’s initial gem layout uses a seeded random with adjustable Corrupted gem spawn rates.  
2. **Event-Based Variations**  
   - On weekends or special events, the server can globally modify “Ember gem spawn +5%” or “Corrupted gem evolve 1s faster,” applying instantly to all puzzle nodes.  
3. **Single-Dev Maintenance**  
   - Node generation logic only needs a few config tables: minion sets per region, probability weighting for elite spawns, boss triggers.  
   - Adjust these tables for difficulty fine-tuning without altering core code.  

---

### 11.3 **Quest & Hazard Generation**  
1. **Random Daily/Weekly Quests**  
   - A script randomly picks from a pool of quest templates (e.g., “Defeat X minions,” “Use forging puzzle Y times,” “Harvest from Realm District Z”).  
   - Weighted logic ensures variety (combat tasks, forging tasks, realm tasks).  
2. **Corrupted Gem Hazard Tuning**  
   - If data indicates too many players fail at certain puzzle nodes, the dev can reduce the spawn rate or extend Corrupted gem phase timers.  
   - Conversely, if advanced players find the game too easy, spike hazard rates for higher-tier regions or enable Hard Mode.  

---

### 11.4 **Incremental Content Additions**  
1. **New Region Releases**  
   - Create new region data: 5 sublocations, each with 10–40 nodes referencing minion/boss tables.  
   - Add new forging recipes or synergy gear in data.  
   - Possibly introduce an additional District Tier (Tier 5) for existing realms or a brand-new realm with distinct resources.  
2. **Live Ops & Seasonal Events**  
   - Minimal code changes needed. The developer can toggle event flags (e.g., “+15% forging success on weekends”) or add a questline awarding unique resources.  
   - Cosmetic items, hero banners, or forging item sets can be introduced in the data layer alone.

---

### 11.5 **Performance & Optimization**  
1. **Mobile Platform Target**  
   - Keep puzzle-combat logic efficient with minimal overhead. An 8×8 grid with real-time matching can run smoothly if coded carefully.  
   - **Arcane Flow Transitions** are shader or sprite-based effects, not heavy cinematics.  
2. **Server Interaction**  
   - Asynchronous design: only boss kills, guild donations, or quest completions require server validation.  
   - Everything else (local puzzle gem logic, forging mini-puzzle) can run client-side, with periodic sync to prevent major cheating.  

---

### 11.6 **AI Opponents & Asynchronous PvP (Optional)**  
1. **Asynchronous PvP**  
   - If the dev wants to add a puzzle duel mode, they can store each player’s “defense pattern” (gear synergy, gem spawn style) in a data file.  
   - Challengers face an AI-simulated puzzle scenario referencing that defense pattern.  
   - The overhead is low, as it’s mostly a parameter set for the puzzle hazard rates and Corrupted gem triggers.  
2. **Future Real-Time PvP**  
   - More complex netcode, requires synchronization. Typically beyond a single dev’s scope unless the user base is large and the feature is demanded.  

---

### 11.7 **Single-Developer Feasibility Strategies**  
1. **Automated Tools**  
   - A simple “Node Editor” to place or remove puzzle nodes, assign minion/boss sets, define quest references.  
   - A “Resource Editor” for forging costs and realm upgrade data.  
2. **Scheduled Content**  
   - Plan out monthly or quarterly expansions. Pre-generate the next region’s data.  
   - Activate them on the server side when ready. This drip-feed approach keeps the game lively without overwhelming dev resources.  
3. **Community Feedback Loop**  
   - Track analytics (clear rates, forging success attempts, realm tier upgrade frequency) to identify friction points or exploit.  
   - Adjust the data values in real-time to keep retention high and monetize effectively.

---

### 11.8 **QA & Testing Methodology**  
1. **Automated Unit Tests**  
   - For puzzle logic, forging success calculations, synergy triggers.  
   - Minimizes regression errors when adjusting data.  
2. **Staging Environment**  
   - Maintain a test environment with debug UI to instantly set Tier levels, forging resources, or puzzle spawns.  
   - Ensure changes are tested before going live to the player base.  
3. **Bug Prioritization**  
   - Focus on game-breaking puzzle logic issues, quest gating issues, or economy exploits first.  
   - Cosmetic or minor UI quirks can be patched later.  

---

### 11.9 **AI-Driven Recommendations**  
1. **Difficulty Auto-Balance**  
   - The server can track average time to defeat bosses or node clear rates. If <40% of players can beat a node, reduce hazard rates. If 90% beat it easily, increase them.  
2. **Dynamic Offers**  
   - Simple logic can recommend forging passes or resource packs if the system detects players stuck on a certain Tier or gear upgrade.  

---

### 11.10 **Section 11 Conclusion**  
By leveraging a data-driven architecture, modular design, and simple asynchronous netcode, a single developer can feasibly maintain and expand every aspect of this puzzle-RPG. Procedural node respawns, quest automation, and flexible event toggles minimize manual overhead. With strategic use of analytics and a robust QA pipeline, the game can adapt in real time to player behavior, ensuring an optimal blend of challenge, engagement, and monetization potential.

---

> **End of Section 11**. *(Awaiting your “next” prompt for Section 12.)*

**SECTION 12: POST-LAUNCH EXPANSIONS, HARD/REMIXED MODES & LIVE OPS**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 12.1 **Philosophy of Post-Launch Content**  
1. **Sustaining Engagement**  
   - Continuous introduction of new Regions, gear families, or event types prevents stagnation.  
   - Regular live ops keep mid- to late-game players invested in upgrading more heroes, forging better gear, and revisiting earlier nodes in Hard modes.  

2. **Single-Developer Manageability**  
   - All expansions must be primarily **data-driven** with minimal new code.  
   - Reusing existing puzzle-combat mechanics (e.g., gem boards, Corrupted gem rates) with new parameters or skins keeps dev time low.  

---

### 12.2 **Hard/Remixed Regions**  
1. **Unlock Criteria**  
   - After clearing a Region normally, a **Hard Mode** variant unlocks.  
   - Hard Mode can apply a global +50% minion/boss HP, +10–20% damage, higher Corrupted gem spawn.  
   - Possibly require a certain **Realm Tier Progression** milestone (e.g., Tier 2 in two Districts) to ensure the player is prepared.  

2. **Rewards**  
   - **Increased Resource Drops**: 1.5× or 2× from each node, forging mats more likely to be Epic-grade.  
   - **Unique Materials**: Shards for higher-tier forging recipes or special synergy gear (e.g., “Hard Terra Shards”).  
   - **Cosmetic Titles**: “Conqueror of Ember Highlands (Hard)” or exclusive puzzle board themes.  

3. **Extended Hard Variants**  
   - **Expert Mode**: An even tougher step, available after Hard mode completion.  
   - **Remixed Nodes**: Additional affixes or brand-new node layouts for replay value, all stored in data for easy toggling.  

---

### 12.3 **Rogue-Lite Endless Mode**  
1. **Unlock Criteria**  
   - Beating Region 5 (or finishing the main storyline) grants access to an **Endless Tower** or similar challenge.  
2. **Wave-Based Combat**  
   - Each wave introduces new minions or environmental hazards (e.g., progressive Corrupted gem spawn, rotating board speeds).  
   - HP does not fully reset between waves; partial recovery or item usage is possible.  
3. **Rewards & Progression**  
   - Every **5–10 waves**, the player gets forging mats or synergy tokens.  
   - Every **50 waves**, a bigger reward (e.g., a guaranteed Epic gear infusion token).  
   - The mode typically resets weekly or monthly, with leaderboards tracking the highest wave cleared.  
4. **Data-Driven Implementation**  
   - The wave structure references a procedural enemy set.  
   - Single developer can update the table for difficulty adjustments or special event twists (like “Week of Ember Overload” – more Ember gems, stronger Ember minions).

---

### 12.4 **Seasonal Live Ops & Rotating Events**  
1. **Elemental Day Cycle**  
   - Already established weekly rotations: Ember Monday, Cascade Tuesday, etc.  
   - This can be amplified post-launch with added bonuses (e.g., +15% synergy combos, +10% forging success for that element on its day).  
2. **Weekend Forging Events**  
   - “Forging Weekend” or “Arcane Bloom Festival” with +15–20% forging success or -20% forging cost.  
   - These events can coincide with new gear banners or gacha hero releases for maximum revenue impact.  
3. **Seasonal Events (Monthly or Quarterly)**  
   - Themed around real-world holidays or in-game lore (e.g., “Flamefall Festival,” “Aqua Solstice”).  
   - Introduce time-limited quest lines, forging recipes, or mini-bosses that drop unique materials.  
   - Offer a seasonal pass with free/premium tracks.  

4. **Guild vs. Guild Seasons**  
   - A 2-week competition period every month where guilds race in resource collection, forging item counts, or boss time trials.  
   - Rewards include special guild emblems, upgraded orchard visuals, or synergy gear.  

---

### 12.5 **Heroic Tales & Special Mini-Events**  
1. **Heroic Tales**  
   - 2–3 node arcs focusing on a specific hero’s backstory.  
   - Repeatable every few weeks, awarding synergy items, forging XP, or a second copy of that hero for ascension.  
   - Encourages players to diversify hero usage.  
2. **Mini-Events**  
   - Short 3–5 day events that reuse existing sublocations with twists (like “Rain of Corruption” – higher Corrupted gem rates, special boss cameo).  
   - Could reward unique furniture for the Player Room or minor synergy gear.  

---

### 12.6 **Adding New District Tiers & Realms**  
1. **Tier 5 Additions**  
   - Post-launch, the developer can introduce a **Tier 5** for each district, requiring higher resource costs and unlocking advanced synergy perks (e.g., “+2 Radiant gems on every 5-gem match”).  
   - Could coincide with new forging materials only found in Hard Mode or Endless Tower.  
2. **Extra Realms**  
   - Beyond the initial four (Timberland, Miner’s Gulch, Seed Grove, Arcane Bloom), additional realms (e.g., “Zephyr Spire”) might be introduced for new gear families.  
   - This realm could focus on a new resource or synergy bonus, all data-driven and referencing the same minigame logic.  

---

### 12.7 **Monetization in Post-Launch Phases**  
1. **Battle Pass Expansions**  
   - Offer seasonal or extended passes with tiered rewards.  
   - Tie unique gear or hero skins to top-tier pass milestones.  
2. **Limited-Time Gacha Heroes**  
   - Seasonal 4★ or 5★ heroes with exclusive synergy effects, rotating every 2–3 months.  
   - Potential for festival or holiday banners with small pity adjustments or guaranteed event-limited units.  
3. **Forge Bundles for Hard Mode**  
   - Special resource packs or forging passes that help players tackle Hard Mode content sooner.  
   - “Legendary Infusion Kit” includes blossoms, forging XP tokens, skip tokens, etc.

---

### 12.8 **Data-Driven Live Ops Management**  
1. **Weekly Timers**  
   - The developer sets a schedule for weekly tasks, forging weekends, or elemental day bonuses in a server-side calendar.  
   - Minimal code changes needed—each event is a data flag that modifies spawn rates, forging success, or synergy combos.  
2. **Hotfix & Balancing**  
   - If an event proves too generous, adjust rates or event durations mid-week.  
   - If players complain about difficulty spikes, reduce enemy HP or hazard rates on Hard Mode nodes.  

---

### 12.9 **Leaderboards & Competition Incentives**  
1. **Endless Tower Leaderboard**  
   - Resets monthly or quarterly, awarding unique frames, titles, or forging passes to the top 1–10%.  
   - Encourages whales to invest in synergy gear or multiple star heroes to push further.  
2. **Guild vs. Guild**  
   - Seasonal GvG ranking with rewards to top guilds.  
   - Easy to maintain asynchronously: just track resource donations, boss kills, forging completions, etc.  

---

### 12.10 **Section 12 Conclusion**  
Post-launch expansions, Hard/Remixed modes, and continuous live ops form the backbone of a thriving, long-lived puzzle-RPG. By reusing core data-driven systems—puzzle mechanics, forging, realm progression—a single developer can roll out substantial new content with minimal code overhead. Weekly or monthly events, Heroic Tales, and seasonal expansions maintain user excitement and spending, ensuring the game’s ongoing viability and profitability.

---

> **End of Section 12**. *(Awaiting your “next” prompt for Section 13.)*

**SECTION 13: LEADERBOARDS & PLAYER-VERSUS-PLAYER (PVP) SYSTEM**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 13.1 **Leaderboards Overview**  
1. **Purpose & Motivation**  
   - Leaderboards fuel competitive play, driving retention and monetization as players vie for ranking-based rewards or prestige titles.  
   - They also provide social validation, especially in guild contexts or among friend lists.  

2. **Single-Developer Feasibility**  
   - Asynchronous data collection and display: no heavy real-time netcode required.  
   - All leaderboards can be updated periodically (hourly, daily, weekly) with a server-based script.  

3. **Leaderboard Categories** (Examples)  
   - **Realm Tier Progression**: Ranking players by how many districts they’ve leveled to Tier 4 (or Tier 5 in future expansions).  
   - **Forging Mastery**: Tally total successful **Arcane Gear Infusion** attempts or forging XP earned.  
   - **Endless Mode Scores**: Highest wave reached or total waves cleared in a season.  
   - **Daily Quest Streaks**: Longest unbroken streak of daily task completions.  
   - **Guild Boss Damage**: Summed damage contributed to guild bosses in a weekly cycle.

---

### 13.2 **Leaderboard Data & Implementation**  
1. **Data Storage**  
   - Server maintains a simple database table for each leaderboard type.  
   - Each entry references the player’s account ID, rank, score/metric (e.g., total forging XP), and last update time.  

2. **Update Frequency**  
   - Some boards (e.g., daily quest streaks) can be updated instantly upon task completion.  
   - Others (like forging or Endless Mode) might refresh every 5–15 minutes to avoid server strain.  

3. **Seasons or Resets**  
   - **Seasonal Leaderboards** (monthly, quarterly) reset at the end of the season, distributing rewards to the top X%.  
   - **Persistent Leaderboards** (like total Realm Tiers) remain ongoing with no reset, simply reflecting lifetime progress.

---

### 13.3 **Reward Structures**  
1. **Ranking Tiers**  
   - **Top 1%**: Unique cosmetic frames or titles (e.g., “Grand Artisan” for forging).  
   - **Top 5%**: Slightly lesser but still exclusive cosmetics or forging passes.  
   - **Top 10–20%**: Resource bundles, forging tokens, synergy items.  
   - **Participation**: Everyone gets a small reward for placing on the board, ensuring broad appeal.  

2. **Trophy & Title System**  
   - Titles displayed next to the player’s avatar in guild chat or friend lists.  
   - Trophies can appear in the **Player Room**, granting minor synergy buffs or purely cosmetic bragging rights.  

3. **Monetization Angle**  
   - Competitively minded players might spend on forging skip tokens, synergy gear, or limited-time passes to push higher on the boards.  
   - Seasonal events with leaderboards often see a revenue spike near season’s end as whales chase top ranks.

---

### 13.4 **PvP Modes: Asynchronous Puzzle Duels**  
1. **Core Concept**  
   - Players challenge an AI-controlled “defense setup” defined by another player’s chosen heroes, synergy gear, or puzzle hazard preferences.  
   - The challenger faces a puzzle board with special conditions (e.g., increased Corrupted gem spawn, boosted Radiant gem spawn) based on the defender’s gear synergy.  

2. **Battle Flow**  
   - **Matchmaking**: Could be bracketed by player level, synergy rating, or an ELO-like system.  
   - **Puzzle-Combat**: The challenger’s puzzle board spawns with hazards or buffs reflecting the defender’s setup. If the challenger can defeat the “AI minions” or meet the objective (e.g., reduce HP to 0) within the time limit, they win.  
   - **Scoring**: Possibly track time to victory, HP lost, or number of Surges triggered.  

3. **Rewards**  
   - **Rank Points**: Gains or losses in a PvP leaderboard bracket.  
   - **PvP Currency**: Used to buy exclusive cosmetics or synergy gear in a dedicated PvP shop.  
   - **Seasonal Trophies**: Similar to other leaderboards.  

4. **Implementation Feasibility**  
   - The “defender” states are just data sets: which heroes, gear effects, synergy buffs, recommended hazard rates.  
   - The puzzle logic is single-player, meaning minimal real-time netcode is needed.  

---

### 13.5 **Optional Live PvP (High Complexity)**  
1. **Real-Time Matching**  
   - Two players simultaneously matching gems on separate boards, possibly sending Corrupted gems or negative effects to each other.  
   - Significantly more complicated netcode for a single dev, with potential desync issues.  
2. **Recommendation**  
   - Launch with asynchronous PvP first. If the user base demands it, consider real-time PvP as a post-launch expansion.  
   - Keep real-time PvP in careful alpha/beta testing if ever pursued.  

---

### 13.6 **GvG (Guild vs. Guild) Competitions**  
1. **Resource Races**  
   - Track which guild accumulates the most seeds, wood, ore, blossoms in a 3–5 day event.  
   - Leaderboard ranks guilds by total donations. Rewards are distributed similarly in tiers (top 1%, top 5%, etc.).  
2. **Forging or Boss Kill Races**  
   - Count how many Epic or Legendary gear items a guild collectively forges during an event window.  
   - Summed damage to special GvG boss spawns on an event server.  
3. **Rewards**  
   - Guild-wide buffs, exclusive guild banners or decorations, forging passes for the top guilds.  
   - Encourages group coordination and resource spending (hence increased monetization).

---

### 13.7 **Merging Leaderboards with Live Ops**  
1. **Weekly Rotations**  
   - Focus on a particular leaderboard each week (e.g., forging XP board is highlighted; top players get special forging perks for the next week).  
   - Rotating highlights keep the meta dynamic.  
2. **Seasonal Rankings**  
   - Tied to major events (e.g., “Harvest Festival Season” spans a month).  
   - Exclusive “season champion” frames or rarities in synergy gear.  

---

### 13.8 **Cheat Prevention & Fair Play**  
1. **Server Validation**  
   - Key game actions (forging success, puzzle node completion, synergy gear creation) must be verified server-side to prevent hacking inflated scores.  
2. **Anti-Bot Measures**  
   - Captchas or random puzzle modifications for suspiciously repetitive players.  
   - Leaderboard data scanning for impossible forging or node clear rates.  

3. **Ethical Gacha & PvP**  
   - Display exact pull rates, pity counters, and avoid extreme pay-to-win gear in PvP to maintain a healthy community.

---

### 13.9 **Detailed Numeric Examples & Tuning**  
1. **Asynchronous PvP**  
   - Win yields +10 rank points, loss yields -5 rank points.  
   - End-of-week rank determines premium or cosmetic rewards.  
2. **Leaderboard Seasonal Reset**  
   - Seasonal reset every 30 days for Endless Tower, forging XP, or guild resource collection.  
   - Top 100 or top 1% get unique titles like “Master Forgemaster,” “Phantasm Champion,” etc.  
3. **GvG Resource Race**  
   - 3-day event. Each guild competes to gather the most combined seeds/wood/ore. The top 3 guilds per bracket (silver, gold, platinum) earn progressively better forging tokens.

---

### 13.10 **Section 13 Conclusion**  
Leaderboards and PvP inject a competitive spark into the puzzle-RPG’s core loops, providing long-term goals for advanced and social players. Asynchronous puzzle duels, GvG events, and tiered rewards encourage strategic team building, synergy gear investment, and forging upgrades. All these systems are feasible for a single developer through data-driven design and periodic server updates, ensuring a steady stream of engagement and revenue from both competitive and cooperative features.

---

> **End of Section 13**. *(Awaiting your “next” prompt for Section 14.)*


**SECTION 14: ADVANCED CODE INTEGRATION & MODULES**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 14.1 **Module Breakdown & Responsibilities**  
1. **MultiRegionManager**  
   - **Purpose**: Handles data for the 10 Regions, each containing 5 Sublocations. Tracks node unlocks, boss states, and Hard/Remixed modes.  
   - **Key Functions**:  
     - LoadRegionData(regionID): Retrieves node/spawn data from JSON.  
     - CheckRegionCompletion(): Evaluates 70% node clearance or boss defeats to unlock next region.  
     - ApplyHardMode(): Ups enemy stats, modifies Corrupted gem spawn rates, etc.  
2. **BoardManager (Puzzle Logic)**  
   - **Purpose**: Core puzzle-combat engine for the 8×8 grid and 4×4 forging puzzle.  
   - **Key Functions**:  
     - InitializeBoard(config): Spawns gems per data-driven rates (elemental, Radiant, Corrupted).  
     - CheckMatches(): Detects matches, increments combo meter, triggers chain reactions.  
     - ApplyCorruptedEvolution(): Runs a timer to evolve Corrupted gems through Phases 1–3.  
     - TriggerPhantasmSurge(): Handles Surge effects (remove 2 Corrupted, +10% damage, Radiant spawns).  
3. **RealmManager (Realm Tier Progression)**  
   - **Purpose**: Governs the four districts (Timberland, Miner’s Gulch, Seed Grove, Arcane Bloom), plus any expansions.  
   - **Key Functions**:  
     - LoadTierData(districtID): Reads upgrade costs, synergy perks from data.  
     - UpgradeTier(districtID, targetTier): Checks resource/gold requirements, applies synergy boosts.  
     - ProcessDailyMinigame(districtID): Awards resources, handles offline accumulation.  
4. **AmplificationManager (Arcane Gear Infusion)**  
   - **Purpose**: Manages forging puzzle, gear data, infusion success calculations.  
   - **Key Functions**:  
     - LoadGearData(element, rarity): Retrieves base cost, synergy effect, success rate.  
     - StartForgingPuzzle(): Launches the 4×4 puzzle with time limit, calculates final success.  
     - ApplyInfusionResult(): Upgrades or grants gear item, processes forging XP, logs any failures.  
5. **HeroGachaManager & HeroMasteryManager**  
   - **Purpose**: Oversees hero summoning, star rates/pity systems, hero leveling, mastery trees.  
   - **Key Functions**:  
     - PerformGachaPull(bannerID): Consumes premium gems, randomizes hero outcome with pity logic.  
     - AwardHeroExp(heroID, amount): Levels hero if thresholds are reached.  
     - UnlockMasteryNode(heroID, nodeID): Validates mastery points, applies synergy bonuses.  
6. **QuestManager (Daily, Weekly, Story Arcs)**  
   - **Purpose**: Central system for all quest types—main story, side arcs, daily tasks, guild missions.  
   - **Key Functions**:  
     - LoadQuestData(questID): Retrieves objectives, rewards, gating conditions.  
     - CheckObjectiveCompletion(questID): Confirms if the player’s actions satisfy each objective.  
     - GrantQuestRewards(questID): Awards items, XP, synergy tokens, etc.  
7. **GuildManager (Co-Op & Resource Gifting)**  
   - **Purpose**: Manages guild membership, guild grove, guild boss fights, resource gifting.  
   - **Key Functions**:  
     - DonateResources(playerID, resourceType, amount): Updates guild bank, tallies contribution points.  
     - StartGuildBossFight(playerID): Spawns an asynchronous boss instance.  
     - SubmitGuildBossDamage(playerID, damage): Applies damage to the shared guild boss HP pool.  
8. **LiveOpsManager**  
   - **Purpose**: Toggles daily/weekly events, forging weekend buffs, elemental day cycles, or seasonal expansions.  
   - **Key Functions**:  
     - ActivateEvent(eventID): Applies data flags that modify spawn rates, forging success, synergy combos.  
     - DeactivateEvent(eventID): Reverts to default settings.  
     - ScheduleEvent(startTime, endTime, eventParams): Automates event lifecycle with minimal manual input.  

---

### 14.2 **Data Structures & Storage**  
1. **JSON / Scriptable Objects**  
   - **Regions.json**: Sublocation IDs, node data, enemy pools, affixes.  
   - **Gear.json**: Arcane Gear Infusion details (element, rarity, cost, base success, synergy effect).  
   - **Heroes.json**: Star rating, role, element, base stats, mastery tree references.  
   - **Quests.json**: Quest IDs, objectives array, reward array.  
   - **Events.json**: Timed buffs or environment changes for live ops.  
2. **Database or Server-Side**  
   - **Player Profile**: current realm tiers, hero roster, gear inventory, quest progression, guild info.  
   - **Guild Data**: guild membership, guild grove level, shared resource bank, guild boss HP.  
   - **Analytics Tables**: node clearance rates, forging success logs, daily retention metrics.  

---

### 14.3 **Real-Time Puzzle Logic vs. Server Validation**  
1. **Local Puzzle Execution**  
   - Gem matching, combo meter, Phantasm Surge triggers happen client-side for responsiveness.  
   - **Potential Exploit Risk**: Some anti-tamper checks or random seeds might be used to reduce cheating.  
2. **Server Checks**  
   - When a puzzle node is cleared, the client sends an encrypted result to the server: “Node X cleared, Y damage dealt, Z HP left, final rewards.”  
   - The server can re-check the synergy/gear data to ensure no impossible results. (Light re-simulation or sanity checks.)  

3. **Guild Boss & Leaderboard**  
   - Higher-level content requires server-side logging.  
   - If the server detects abnormal damage patterns, it might flag the account for review or revalidate forging synergy stats.  

---

### 14.4 **UI & Scene Management**  
1. **Scene Flow**  
   - Town Hub (Adventurer’s Haven) → Sublocation Map → Puzzle Node → Battle Result → Return to Sublocation Map → Return to Town.  
   - **Arcane Flow Transitions** are overlay animations rather than separate scenes, maintaining a quick sense of continuity.  
2. **UI Panels**  
   - **Main HUD**: hero portraits, HP bar, combo meter, skill triggers.  
   - **Forge UI**: gear list, forging puzzle window, infusion result popup.  
   - **Realm Tier UI**: four district panels, each showing upgrade bars, daily minigame start, offline resource claims.  
3. **Adaptive Audio Layers**  
   - The AudioManager module crossfades from base theme to a “combo intensity” layer at combo≥20, or a “Phantasm Surge” layer once Surge triggers, etc.  

---

### 14.5 **Performance & Optimization Targets**  
1. **Mobile Devices**  
   - Aim for **30–60 FPS** on mid-range devices.  
   - Keep memory usage under ~500 MB by reusing gem sprites, limiting heavy 3D assets, and applying texture compression.  
2. **Loading & Asset Bundles**  
   - Regions can share background textures. Sublocations differ mainly in color/lighting variations.  
   - A single developer can pack new region art into downloadable asset bundles if needed.  
3. **Network Usage**  
   - Asynchronous design ensures minimal data transfer.  
   - Only send major updates on node clearance, forging completion, or guild boss submission.  

---

### 14.6 **Back-End & LiveOps Tools**  
1. **Admin Panel**  
   - Web-based dashboard to toggle forging weekend event, set elemental day multipliers, or adjust resource drop rates server-side.  
   - Provide immediate hotfixes for economy balancing.  
2. **Analytics**  
   - Track daily active users, new user retention, average forging attempts per day, orchard/district upgrades, guild donation rates.  
   - Identify bottlenecks (e.g., if too few players reach Tier 3 in Timberland, lower the cost or raise wood/seed drops).  
3. **LiveOps Scheduling**  
   - A cron-like system triggers events (e.g., “Every Friday 00:00 UTC → start forging weekend. Sunday 23:59 UTC → end event.”).  
   - Single developer can manage a monthly calendar of events with minimal manual intervention.  

---

### 14.7 **Testing & QA**  
1. **Unit Tests**  
   - Each module has test cases: forging puzzle logic, synergy combos, realm resource accumulation, hero gacha draws.  
   - Validate boundary conditions (e.g., forging success at 100%, or a node with 100% Corrupted gem spawn).  
2. **Integration Tests**  
   - End-to-end scenario: Player logs in, collects daily resources, attempts forging puzzle, does puzzle-combat node, triggers quest updates, logs out. Check the entire pipeline is stable.  
3. **Beta Branch**  
   - For major updates, a small subset of players might test new region expansions, synergy gear families, or guild features.  
   - The single dev reviews feedback and implements hotfixes before global release.  

---

### 14.8 **Security & Anti-Cheat Layers**  
1. **Basic Checks**  
   - If a forging attempt claims 100% success from a minimal puzzle performance, the server can recalculate or challenge the result.  
   - If an offline orchard accrues more resources than possible (e.g., thousands instead of tens), the server corrects it.  
2. **Encryption**  
   - Low-level encryption on local save data or forging puzzle seeds.  
   - The puzzle board’s random seed can be partially server-generated to prevent manipulation.  
3. **Ban / Warning System**  
   - If repeated suspicious logs appear, the account is flagged for manual review.  
   - A single developer can quickly investigate via server logs or analytics triggers.  

---

### 14.9 **Future-Proofing**  
1. **Scalable Regions**  
   - Architecture easily supports new data sets for expansions, gear families, synergy buffs.  
   - Hard-coded region IDs are avoided; the system loops over an array of region definitions.  
2. **Hero Gacha Updates**  
   - Banners are stored in a Banners.json with start/end dates, featured hero IDs, adjusted rate-ups.  
   - A single dev can add new heroes or “limited-time variants” (costume versions) in the same data schema.  
3. **Live Co-Op Potential**  
   - If real-time co-op is desired, the core puzzle logic can remain local while a simple server channel synchronizes wave states. This is a larger project but still building on existing modules.

---

### 14.10 **Section 14 Conclusion**  
A well-structured modular approach ensures each system (puzzle board, forging, realm tiers, guild) remains self-contained yet connected via shared data references. From code-level modules like BoardManager and AmplificationManager to overarching LiveOpsManager tools, everything aligns to a single-developer pipeline. Hotfix-friendly JSON data, robust logging, and partial server validation mitigate exploits while allowing swift balancing and live event deployment. This coding blueprint provides the backbone for a scalable, feature-rich puzzle-RPG capable of consistent expansions and revenue spikes.

---

> **End of Section 14**. *(Awaiting your “next” prompt for Section 15.)*

**SECTION 15: INCREMENTAL TUTORIAL & ONBOARDING SEQUENCE**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 15.1 **Tutorial Philosophy**  
1. **Incremental Introduction**  
   - Rather than a single, lengthy tutorial at game start, present short pop-ups and guidance **only** when a new feature is first unlocked.  
   - Maintain pacing so players aren’t overwhelmed: puzzle basics first, then forging, then Realm Tier Progression, then guild features.  

2. **Single-Developer Strategy**  
   - Each tutorial step is data-defined, with triggers like “player reaches Tier 1 in Timberland” or “first forging attempt.”  
   - The developer can easily add or tweak these steps by editing a small **Tutorial.json** file that references game events.  

---

### 15.2 **Early Game Onboarding**  
1. **Initial Puzzle Basics**  
   - **Trigger**: On the very first node.  
   - **Pop-Up**: Explains gem matching (3+ same color), Radiant wildcard, and Corrupted gem hazards in simple bullet points.  
   - **Hands-On Segment**: A forced short puzzle scenario with fewer Corrupted gems, a relaxed HP drain, and guaranteed Radiant spawns to demonstrate combo building.  

2. **Town Hub & Realm Tier Introduction**  
   - **Trigger**: After clearing the first couple puzzle nodes, the player is guided to Oakrest’s **Adventurer’s Haven**.  
   - **Pop-Up**: “Welcome to the Town! Here’s where you can manage Districts, forging, guilds, and more.”  
   - **Realm Tier**: Prompt to visit **Timberland District** at Tier 0, show daily minigame for wood.  

3. **Hero Summoning & Party Setup**  
   - **Trigger**: Upon acquiring enough premium gems or receiving a free “Beginner Summon Ticket.”  
   - **Pop-Up**: Explains the hero gacha banner, star ratings, and how to slot heroes into a 3-hero party.  
   - **Optional Step**: A short sub-tutorial about synergy combos (mono element vs. multi element).  

---

### 15.3 **Mid-Game Tutorials**  
1. **Arcane Gear Infusion**  
   - **Trigger**: The first time the player enters the **Workshop Node** with enough resources for forging.  
   - **Pop-Up**: “Arcane Gear Infusion lets you craft powerful items. Complete the 4×4 forging puzzle to boost success rates!”  
   - **Hands-On Segment**: A guided forging attempt using a free or heavily discounted recipe.  
   - **Explanation**: Outlines forging XP, infusion success percentage, synergy effects (e.g., removing Corrupted gems).  

2. **Realm Tier Upgrades & Tier 3 Milestones**  
   - **Trigger**: When the player accumulates enough resources to upgrade Timberland or another district from Tier 2 to Tier 3.  
   - **Pop-Up**: “Tier 3 unlocks a major power boost, such as the 4th hero slot in Timberland District. Collect seeds/wood/ore to upgrade!”  
   - **Hands-On Segment**: Prompt to gather resources from daily minigames, reinforcing the cycle of daily chores → forging → puzzle-combat.  

3. **Guild & Co-Op**  
   - **Trigger**: Upon reaching a specified story milestone (e.g., clearing Region 1 or achieving Tier 1 in any district).  
   - **Pop-Up**: “Join or create a guild to tackle guild bosses, share resources, and earn group rewards!”  
   - **Tutorial Task**: “Send or receive 10 resources to/from guildmates,” “Challenge the guild boss.”  

---

### 15.4 **Late-Game & Special System Tutorials**  
1. **Phantasm Surge Refresher**  
   - **Trigger**: Once the player starts seeing bigger combos or hits Region 3.  
   - **Pop-Up**: “Hitting a combo of 50 triggers Phantasm Surge, which removes Corrupted gems and boosts damage. Try focusing on large matches or Radiant combos!”  
2. **Hard Mode / Endless Tower**  
   - **Trigger**: When the player completes the normal mode of a region or meets a specified level threshold.  
   - **Pop-Up**: “Hard Mode offers greater rewards but fiercer enemies. Prepare by upgrading your District Tiers or forging Legendary gear!”  
   - **Hands-On Segment**: Possibly a short demonstration wave in the Endless Tower with on-screen tips about scaling hazards.  

3. **Live Ops & Events**  
   - **Trigger**: The first time an elemental day or forging weekend is active.  
   - **Pop-Up**: “This weekend is a special forging event! Enjoy +10% success for Ember gear. Check the events panel in the Daily Planner!”  

---

### 15.5 **Daily Planner Highlight**  
1. **Centralized Guidance**  
   - The Daily Planner UI is introduced after the second or third puzzle node.  
   - **Pop-Up**: “Check your Daily Planner for tasks, minigames, forging opportunities, and guild requests. Tap an item to jump directly there.”  
2. **Single Tutorial Entry**  
   - Minimizes the need for repeated instructions; whenever new tasks or events appear, the planner auto-updates.  
   - Reinforces routine engagement: orchard chores (realm minigames), forging puzzle attempts, puzzle-combat node clears.  

---

### 15.6 **Quest Integration for Tutorials**  
1. **Tutorial Quests**  
   - Each tutorial pop-up can be framed as a mini-quest in the **QuestManager**.  
   - Example: “Tutorial Quest #1: Win 1 puzzle node + Summon 1 hero,” rewarding small gold or forging XP.  
2. **Rewarding Mastery Points**  
   - Some tutorials can award mastery points or synergy shards, motivating players to follow through the entire tutorial step.  
3. **Quest Flow**  
   - Mark tutorial quests as “Auto-Complete” if the user has already performed the required action. (E.g., if they upgrade a district before the tutorial triggers, it’s auto-completed.)

---

### 15.7 **Progressive Difficulty Ramps**  
1. **Soft Gating**  
   - The game gently nudges players to forge better gear before tackling higher-level puzzle nodes.  
   - Tutorials highlight the synergy between forging success rates, realm tier perks, and puzzle-combat synergy combos.  
2. **Preventing Overwhelm**  
   - By spacing out tutorials, players gain confidence in each system (puzzle-combat, forging, realm expansions, guild co-op) in manageable chunks.  

---

### 15.8 **UI/UX Best Practices**  
1. **Clear & Minimal Pop-Ups**  
   - Use short text lines, bullet points, or icons for clarity. Avoid heavy paragraphs.  
   - Option to skip or “learn later” for experienced players.  
2. **Highlight Effects**  
   - When referencing a new button (e.g., “Workshop Node”), glow or outline that button on-screen to direct the user’s gaze.  
3. **Disable Input**  
   - Briefly lock other UI elements during critical tutorial steps, ensuring the user completes the intended action. Keep these lockouts short to avoid frustration.  

---

### 15.9 **Analytics & Iteration**  
1. **Tutorial Completion Rate**  
   - Track how many players drop off during each tutorial step or how many skip.  
2. **Difficulty Spikes**  
   - If analytics show many players fail to progress beyond Region 1 or Tier 1 upgrades, revise tutorials or lower resource costs.  
3. **Event & Feature Tutorials**  
   - For newly introduced expansions or synergy gear families, add a small pop-up tutorial triggered by the first relevant event.  

---

### 15.10 **Section 15 Conclusion**  
A well-structured incremental tutorial ensures players gradually master every system—**Puzzle-Combat**, **Arcane Gear Infusion**, **Realm Tier Progression**, **Guild Co-Op**, and synergy combos—without feeling overwhelmed. By tying pop-ups to quest-like objectives in the **Daily Planner** and awarding small, meaningful rewards, the tutorial flow becomes seamlessly integrated with core gameplay loops. This approach maximizes accessibility, retention, and overall player satisfaction, all while minimizing development complexity through data-driven triggers and minimal-coded pop-up sequences.

---

> **End of Section 15**. *(Awaiting your “next” prompt for Section 16.)*

**SECTION 16: PERFORMANCE & NETCODE OPTIMIZATION**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 16.1 **Mobile Platform Targets**  
1. **Frame Rate Goals**  
   - **Mid-Range Devices**: Aim for consistent **30–60 FPS** in puzzle-combat.  
   - **High-End Devices**: Unlocked framerate if possible, but ensure stable performance even during large combos or Corrupted gem explosions.  
2. **Memory Footprint**  
   - Keep total memory usage under **500 MB** for a typical mid-range Android/iOS device.  
   - Reuse gem sprites, backgrounds, and animations via texture atlases.  

3. **Testing Matrix**  
   - At least one older Android device (2–3GB RAM) and one mid-tier iOS device to confirm performance baselines.  
   - Occasional checks on high-end devices to ensure no CPU or GPU spikes.

---

### 16.2 **Puzzle-Combat Optimization**  
1. **Board Updates & Match Detection**  
   - Use efficient data structures (e.g., a 2D array or list) for the 8×8 grid.  
   - **Match-Finding Algorithm**: A single pass each time the player swaps gems, plus a cascade check.  
   - Limit real-time collisions: the puzzle board can be updated in discrete steps, preventing overhead from continuous re-checking.  

2. **Corrupted Gem Evolution**  
   - Only update Corrupted gem phases every **1 second** or so, rather than checking constantly.  
   - A simple timer system can queue “evolution events” to reduce repeated CPU calls.  

3. **Particle & Visual Effects**  
   - Keep swirl or explosion VFX short and reuse particle assets.  
   - For mass combos, run a single combined effect rather than multiple overlapping ones if performance dips.

---

### 16.3 **Arcane Flow Transitions**  
1. **Shader-Based vs. Fullscreen Video**  
   - Prefer lightweight shader transitions or sprite-based swirl animations over heavy video assets.  
   - Cache the swirl texture in memory for quick reuse on sublocation entry or wave transitions.  
2. **Adaptive Quality Settings**  
   - On lower-end devices, reduce swirl complexity, skip some blending layers, or shorten the transition animation.  
   - Expose a “Low / Medium / High” graphics toggle in settings.

---

### 16.4 **Adaptive Audio Layers**  
1. **Audio Channel Management**  
   - Preload audio layers for base track, combo track, surge track, tension track.  
   - Crossfade them using the Unity audio mixer or a similar system.  
2. **Memory Budget**  
   - Music tracks can loop seamlessly. Keep them under a few MB each by compressing at an acceptable quality (e.g., Vorbis ~96kbps).  
   - Sound effects for gem matches, forging puzzle, etc. should be in short clips.  

3. **Performance Tips**  
   - Limit simultaneous SFX; if multiple combos occur in quick succession, pool the SFX or layer them at reduced volume to prevent audio chaos.  
   - Fade out unnecessary tracks quickly once the event ends (e.g., tension track stops if HP recovers above 20%).

---

### 16.5 **Asynchronous Netcode**  
1. **Minimal Real-Time Interaction**  
   - Puzzle-combat is local. The server receives results after completion, so no heavy synchronization is needed.  
   - Guild boss or PvP is also asynchronous: the server only processes damage logs or challenge results.  
2. **Data Packet Size**  
   - Each node completion or forging success might send a small JSON packet: {"playerID":..., "nodeID":..., "damageDealt":..., "rewards":...}.  
   - Batching these packets or sending them at session end can reduce overhead, but careful with potential data loss if a player closes the app abruptly.  

3. **Cheat Detection**  
   - On receiving results, the server does a quick validity check (e.g., max possible damage, synergy levels, forging success probability) to flag anomalies.  
   - Logs suspicious data for future review or auto-suspension if egregious.

---

### 16.6 **Server Architecture**  
1. **Backend Framework**  
   - A typical RESTful or small WebSocket-based approach is sufficient for asynchronous updates.  
   - Leaderboards, guild data, quest progression stored in a simple relational or NoSQL database.  
2. **Scaling**  
   - Light data usage means one or a few cloud instances can handle thousands of concurrent users if the puzzle logic is client-side.  
   - Optional load balancing if the player base grows significantly.  

3. **Disaster Recovery**  
   - Daily backups of database.  
   - Store user data with versioning so updates or expansions do not corrupt old records.

---

### 16.7 **Edge Cases & Offline Play**  
1. **Offline Resource Accumulation**  
   - The user can collect offline orchard resources for up to 12 hours if they aren’t connected.  
   - When they reconnect, the server calculates the difference based on the local last-login timestamp, validated by server time.  
2. **Combat Without Connection**  
   - Puzzle-combat can be done offline. The user’s results get queued and sent to the server once reconnected.  
   - If a node requires an online check (e.g., guild boss), block that node if offline or store the attempt result for a brief period until reconnection.  

3. **Potential Exploits**  
   - Timestamps can be manipulated if purely local. The server compares server time vs. local time to ensure consistency.  
   - If the difference is excessive, partial compensation or flags might be used.

---

### 16.8 **Client-Side Caching & Memory Management**  
1. **Asset Bundles by Region**  
   - Each region’s background, minion sprites, boss art can be in a single bundle ~10–20 MB.  
   - Unload previous region bundles when the player moves far enough away to reduce memory.  
2. **Persistent Data**  
   - The user’s inventory, hero data, quest states are kept in memory if the app remains open.  
   - Only flush them if memory constraints rise too high, then reload from local or server upon demand.  

3. **Garbage Collection Minimization**  
   - Object pooling for gem sprites, VFX, or forging puzzle elements.  
   - Reuse idle objects instead of constantly instantiating/destroying.

---

### 16.9 **Testing & Profiling**  
1. **Profiler Tools**  
   - Unity Profiler, Xcode Instruments, or Android Studio for analyzing CPU, GPU, memory usage.  
   - Identify bottlenecks in puzzle cascade logic, forging puzzle load, or swirl transitions.  
2. **Performance Benchmarks**  
   - Test worst-case scenario: multiple chain combos, mass Radiant gem spawns, Phantasm Surge back-to-back, extra layering of audio.  
   - Check guild boss fights with large HP and repeated wave transitions for load spikes.

3. **Continuous Monitoring**  
   - Log average frame times, memory usage on typical mid-range devices each patch.  
   - If a patch introduces new VFX or forging mechanics, ensure no major regression in performance.

---

### 16.10 **Section 16 Conclusion**  
A focus on efficient puzzle-combat updates, lightweight Arcane Flow Transitions, strategic audio layering, and asynchronous netcode ensures the puzzle-RPG runs smoothly on mainstream mobile devices. By caching assets regionally, minimizing repeated effect overhead, and offloading heavy tasks to data-driven logic, a single developer can maintain performance targets. Proper validation checks and server synchronization further safeguard fair play while allowing offline or low-bandwidth usage. This foundation guarantees a stable, scalable, and enjoyable experience crucial for player retention and monetization success.

---

> **End of Section 16**. *(Awaiting your “next” prompt for Section 17.)*

**SECTION 17: FINAL INTEGRATION & FULL GAMEPLAY LOOP**  
*(Ultra-Granular Developer-Level Detail)*  

---

### 17.1 **High-Level Loop Recap**  
1. **Daily Login → Town Hub (Adventurer’s Haven)**  
   - Player collects offline **Realm Tier Progression** resources (wood, ore, seeds, blossoms).  
   - Checks the **Daily Planner** for tasks (daily minigames, forging attempts, puzzle-combat nodes, guild boss participation).  
   - Potentially visits the **Guild Tavern** for resource gifting or Boss fights.  

2. **Realm Tier Progression & Resource Usage**  
   - The player upgrades District Tiers if they have enough gold + resources, unlocking synergy boosts or feature milestones (like the 4th hero slot at Timberland Tier 3).  
   - Plays each District’s **daily minigame** for additional wood, ore, seeds, or blossoms.  

3. **Arcane Gear Infusion (Workshop Node)**  
   - The player attempts the 4×4 forging puzzle to craft or upgrade gear (Rare → Epic → Legendary).  
   - Success rates vary based on puzzle performance, District Tiers, forging passes, and event buffs.  
   - Gear synergy (e.g., removing Corrupted gems, spawning Radiant gems) fuels puzzle-combat effectiveness.  

4. **Puzzle-Combat Nodes**  
   - The user selects a sublocation from one of the 10 Regions. Fights standard or elite minions, culminating in a boss node.  
   - Real-time matching with Corrupted gem evolution, Radiant wildcard synergy, and **Phantasm Surge** triggers.  
   - Earns gold, forging mats, hero XP, skill XP. Nodes respawn after 8 hours with slight randomization.  

5. **Hero Progression & Party Building**  
   - Summons new heroes from the gacha banner or levels existing ones, investing Mastery Points for synergy perks.  
   - Tweaks party composition (mono-element for +10% damage vs. multi-element for extended Surge).  
   - Equips Arcane Gear Infusion items to augment puzzle board strategies.  

6. **Guild & Co-Op**  
   - Donates resources to the guild’s shared **Guild Grove**, raises tiers for collective buffs.  
   - Fights asynchronous guild bosses for forging tokens, synergy shards, or bonus gold.  
   - Possibly engages in GvG resource races or cameo “Guest Hero Summon” from guildmates.  

7. **Live Ops & Events**  
   - Weekly elemental days (Monday = Ember, Tuesday = Cascade, etc.).  
   - Forging weekends or seasonal holiday events add extra success rates or special gear.  
   - Endless Tower or Hard Mode expansions for endgame challenge.  

8. **Overarching Story & Quest Arcs**  
   - Branching region arcs require puzzle nodes + forging tasks + realm upgrades to complete.  
   - Rewards typically include hero XP, forging items, synergy gear tokens, or quest keys to unlock boss nodes.  
   - Daily/weekly quests guide players to remain active in forging, puzzle-combat, and guild cooperation.  

---

### 17.2 **Full Developer Roadmap**  
1. **Core Systems Launch**  
   - Puzzle board logic, basic forging, Tier 0–4 for each District, main Regions (1–10).  
   - Hero gacha with pity counters.  
   - Basic guild functions: resource gifting, guild boss, guild grove.  
   - Incremental tutorials and daily tasks.  

2. **Post-Launch Additions**  
   - Hard/Remixed modes, Endless Tower, advanced synergy gear sets, potential Tier 5 expansions, new heroes and banners.  
   - Seasonal events, forging weekends, GvG competitions, asynchronous PvP or leaderboards.  
   - Cosmetic expansions for the Player Room, puzzle board skins, hero skins.  

3. **Long-Term Live Ops**  
   - Rotating hero banners every 2 weeks, forging synergy weekends, monthly seasonal passes, quarterly expansions with new Regions or District Tiers.  
   - Ongoing data-driven balancing to maintain monetization and smooth progression for new and veteran players alike.  

---

### 17.3 **Ensuring Seven-Figure Monthly Revenue**  
1. **Core Monetization Drivers**  
   - **Gacha Summons**: star-rated heroes with pity systems encourage repeated pulls.  
   - **Arcane Gear Infusion**: forging passes, skip tokens, resource bundles for quick progression or guaranteed synergy.  
   - **Realm Resource Passes**: daily orchard minigame boosters.  
   - **Battle Passes**: 14-day cycles with premium track rewards, forging tokens, guaranteed heroes.  
   - **Cosmetics**: puzzle board themes, avatar skins, hero costumes.  

2. **Retention & Engagement**  
   - **Quest System**: daily/weekly tasks, storyline arcs, synergy-based forging challenges.  
   - **Guild Features**: asynchronous bosses, donation-based grove upgrades, resource sharing, GvG events.  
   - **Live Ops**: elemental days, forging weekends, seasonal expansions.  
   - **Endgame Content**: Hard modes, Endless Tower, heroic tales, advanced synergy combos.  

3. **User Acquisition & Marketing**  
   - Vibrant puzzle-combat with real-time gem matches, distinct from typical turn-based match-3.  
   - High-quality anime/painterly style art with flashy Arcane Flow Transitions, layered music.  
   - Cross-promo with other puzzle or RPG titles, limited-time collaboration hero banners for spikes in revenue.  

---

### 17.4 **Final Blueprint Cohesion**  
1. **All Systems Interlocked**  
   - Puzzle-combat performance is enhanced by forging gear, which requires realm resources.  
   - Realm Tier Progression daily minigames yield resources that feed forging.  
   - Forging synergy items drastically improve puzzle capabilities, letting players defeat harder nodes or guild bosses.  
   - Quests push players to upgrade District Tiers, craft gear, and recruit heroes, which in turn unlock more puzzle efficiency.  
   - Guild cooperation further boosts resource flow, synergy bonuses, and fosters social retention.  

2. **Data-Driven Maintenance**  
   - A single developer can easily tweak spawn rates, forging costs, synergy percentages, or event parameters.  
   - No heavy re-coding for expansions: simply add new Region or Tier data, new synergy gear entries, new quest arcs.  

3. **Continuous Live Ops Loop**  
   - Weekly cycles of element buffs, forging weekends, rotating limited-time hero banners.  
   - Seasonal expansions or thematic events every 1–3 months, fueling bursts of spending and new content engagement.  
   - Leaderboards, guild events, and Hard/Remix modes keep endgame players busy and monetizing.  




Stage plan - 
--- JohnStage/stage1.txt ---
**STAGE 1**  
*(Multi-Realm World, Town Hub, Sublocation Infrastructure. Complete final code, no placeholders. Minimal non-functional text. Summary at end.)*

---

## 1. CODE (FINAL, 15× DETAIL)

csharp
/*********************************************
 * RealmTierData.cs
 *********************************************/
using UnityEngine;

[System.Serializable]
public class RealmTierData
{
    public string realmName;        // Example: "ValleyRealm", "HighlandRealm", etc.
    public int currentTier;         // Starting at 0
    public int maxTier;             // Typically up to 4 or 5
    public int resourceCostPerTier; // Optional if expansions require resources
}

/*********************************************
 * RealmProgressionManager.cs
 *********************************************/
using UnityEngine;

public class RealmProgressionManager : MonoBehaviour
{
    public static RealmProgressionManager Instance;

    [Header("Realm Tier Configuration")]
    public RealmTierData[] realms;  
    // e.g. Index 0: "ValleyRealm", currentTier=0, maxTier=4

    private void Awake()
    {
        if (Instance == null) 
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        } 
        else 
        {
            Destroy(gameObject);
        }
    }

    public bool UpgradeRealm(int index)
    {
        if (index < 0 || index >= realms.Length) return false;
        if (realms[index].currentTier < realms[index].maxTier)
        {
            realms[index].currentTier++;
            Debug.Log($"[RealmProgressionManager] Upgraded '{realms[index].realmName}' to Tier {realms[index].currentTier}.");
            return true;
        }
        Debug.LogWarning($"[RealmProgressionManager] '{realms[index].realmName}' already at max tier.");
        return false;
    }

    public int GetHighestRealmTier()
    {
        int maxVal = 0;
        foreach(var rd in realms)
        {
            if(rd.currentTier > maxVal) maxVal = rd.currentTier;
        }
        return maxVal;
    }
}

/*********************************************
 * SublocationData.cs
 *********************************************/
using System.Collections.Generic;

[System.Serializable]
public class SublocationData
{
    public string sublocationName;
    public int requiredRealmTier;         // Minimum Tier needed to access
    public List<string> nodeIDs;          // Puzzle-combat node references
    public bool lockedByDefault = true;
}

/*********************************************
 * WorldManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

public class WorldManager : MonoBehaviour
{
    [System.Serializable]
    public class Region
    {
        public int regionID;
        public string regionName;
        public List<SublocationData> sublocations;
    }

    public List<Region> configuredRegions = new List<Region>();
    private Dictionary<int, Region> regionDict = new Dictionary<int, Region>();

    private void Awake()
    {
        foreach(var reg in configuredRegions)
        {
            if(!regionDict.ContainsKey(reg.regionID))
            {
                regionDict.Add(reg.regionID, reg);
            }
        }
    }

    public bool IsRegionAccessible(int regionID, int realmTier)
    {
        // Example: regionID=1 requires realmTier>=1
        if(regionID == 1 && realmTier < 1)
        {
            Debug.LogWarning($"[WorldManager] Region {regionID} locked (realmTier < 1).");
            return false;
        }
        return true;
    }

    public Region GetRegionByID(int regionID)
    {
        if(regionDict.ContainsKey(regionID))
        {
            return regionDict[regionID];
        }
        Debug.LogWarning($"[WorldManager] Region ID {regionID} not found.");
        return null;
    }
}

/*********************************************
 * SublocationManager.cs
 *********************************************/
using UnityEngine;

public class SublocationManager : MonoBehaviour
{
    public SublocationData currentSublocation;

    public void InitializeSublocation(SublocationData data, int playerRealmTier)
    {
        currentSublocation = data;
        if(data.requiredRealmTier > playerRealmTier)
        {
            Debug.Log($"[SublocationManager] Sublocation '{data.sublocationName}' locked.");
        }
        else
        {
            Debug.Log($"[SublocationManager] Sublocation '{data.sublocationName}' unlocked.");
        }
    }

    public void EnterSublocation()
    {
        SceneTransitionManager.Instance?.PlaySceneTransition(()=>
        {
            Debug.Log($"[SublocationManager] Entering sublocation: {currentSublocation.sublocationName}");
            // Optionally load puzzle-combat or content
        });
    }
}

/*********************************************
 * SceneTransitionManager.cs
 *********************************************/
using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System;

public class SceneTransitionManager : MonoBehaviour
{
    public static SceneTransitionManager Instance;

    [Header("Transition Overlay")]
    public Image overlay;
    public float transitionSpeed = 1f;
    private bool isTransitioning = false;

    private void Awake()
    {
        if(Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Start()
    {
        if(overlay != null) SetOverlayAlpha(0f);
    }

    public void PlaySceneTransition(Action onMidTransition)
    {
        if(isTransitioning) return;
        isTransitioning = true;
        StartCoroutine(DoSceneTransition(onMidTransition));
    }

    private IEnumerator DoSceneTransition(Action onMidTransition)
    {
        float alpha = 0f;
        while(alpha < 1f)
        {
            alpha += Time.deltaTime * transitionSpeed;
            SetOverlayAlpha(alpha);
            yield return null;
        }
        onMidTransition?.Invoke();
        while(alpha > 0f)
        {
            alpha -= Time.deltaTime * transitionSpeed;
            SetOverlayAlpha(alpha);
            yield return null;
        }
        isTransitioning = false;
    }

    private void SetOverlayAlpha(float val)
    {
        if(overlay != null)
        {
            var c = overlay.color;
            c.a = Mathf.Clamp01(val);
            overlay.color = c;
        }
    }
}

/*********************************************
 * AudioOverlayManager.cs
 *********************************************/
using UnityEngine;

public class AudioOverlayManager : MonoBehaviour
{
    public static AudioOverlayManager Instance;
    public AudioSource bgmSource;

    private void Awake()
    {
        if(Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void PlayBackgroundMusic(string trackName)
    {
        Debug.Log($"[AudioOverlayManager] Playing music track: {trackName}");
        if(bgmSource && !bgmSource.isPlaying)
        {
            bgmSource.loop = true;
            bgmSource.Play();
        }
    }

    public void StopMusic()
    {
        if(bgmSource && bgmSource.isPlaying) bgmSource.Stop();
    }
}

/*********************************************
 * DailyTaskManager.cs
 *********************************************/
using UnityEngine;

public class DailyTaskManager : MonoBehaviour
{
    public static DailyTaskManager Instance;

    private void Awake()
    {
        if(Instance == null) 
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else 
        {
            Destroy(gameObject);
        }
    }

    public void ValidateDailyTasks()
    {
        Debug.Log("[DailyTaskManager] Checking daily tasks. (Stage 1 final references)");
        // Future expansions can read data tables for tasks
    }
}

/*********************************************
 * TutorialManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

public class TutorialManager : MonoBehaviour
{
    public static TutorialManager Instance;

    private HashSet<string> completedKeys = new HashSet<string>();

    private void Awake()
    {
        if(Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void TriggerTutorial(string key)
    {
        if(completedKeys.Contains(key))
        {
            Debug.Log($"[TutorialManager] Tutorial '{key}' already completed.");
            return;
        }
        completedKeys.Add(key);
        Debug.Log($"[TutorialManager] Showing tutorial step: {key}");
    }
}

/*********************************************
 * ProjectionSummonManager.cs
 *********************************************/
using UnityEngine;

public class ProjectionSummonManager : MonoBehaviour
{
    public static ProjectionSummonManager Instance;

    private void Awake()
    {
        if(Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void SummonProjection(string allyID)
    {
        Debug.Log($"[ProjectionSummonManager] Summoning ally projection: {allyID}");
        // Future expansions: netcode, co-op synergy
    }
}

/*********************************************
 * TownHubManager.cs
 *********************************************/
using UnityEngine;
using UnityEngine.SceneManagement;

public class TownHubManager : MonoBehaviour
{
    public WorldManager worldManager;
    public RealmProgressionManager realmManager;
    public SublocationManager sublocationManager;
    public DailyTaskManager dailyTaskManager;
    public TutorialManager tutorialManager;

    [Header("Current Region")]
    public int currentRegionID = 0;

    void Start()
    {
        AudioOverlayManager.Instance?.PlayBackgroundMusic("TownTheme");
        tutorialManager?.TriggerTutorial("TownHubIntro");
        dailyTaskManager?.ValidateDailyTasks();
    }

    public void OpenRealmProgressionPanel()
    {
        SceneTransitionManager.Instance?.PlaySceneTransition(()=>
        {
            Debug.Log("[TownHubManager] Realm progression panel opened.");
        });
    }

    public void OpenPlayerHouse()
    {
        SceneTransitionManager.Instance?.PlaySceneTransition(()=>
        {
            Debug.Log("[TownHubManager] Entering player house.");
        });
    }

    public void OpenGuildHall()
    {
        SceneTransitionManager.Instance?.PlaySceneTransition(()=>
        {
            Debug.Log("[TownHubManager] Entering guild hall. Future co-op features here.");
        });
    }

    public void TravelToRegion(int targetRegionID)
    {
        int maxTier = realmManager.GetHighestRealmTier();
        if(worldManager.IsRegionAccessible(targetRegionID, maxTier))
        {
            SceneTransitionManager.Instance?.PlaySceneTransition(()=>
            {
                Debug.Log($"[TownHubManager] Traveling to region {targetRegionID}");
                // Optionally SceneManager.LoadScene("RegionScene_"+targetRegionID)
            });
        }
        else
        {
            Debug.LogWarning($"[TownHubManager] Region {targetRegionID} locked. Increase realm tier first.");
        }
    }
}


---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Create a new project** (Unity 2021+). Name it **PuzzleRPG_Stage1**.  
2. **Folders**:  
   - /Assets/Scripts/Managers/ → Place all .cs scripts above.  
   - /Assets/Scenes/ → Create TownHubScene.unity.  
   - /Assets/Prefabs/ → (Optional) store UI or overlay prefabs.  
   - /Assets/Audio/ → (Optional) store BGMs or SFX.  
3. **In TownHubScene**:  
   - Create [Managers] empty GameObject. Attach:  
     - WorldManager, RealmProgressionManager, TownHubManager, SublocationManager, SceneTransitionManager, AudioOverlayManager, DailyTaskManager, TutorialManager, ProjectionSummonManager.  
   - On SceneTransitionManager, assign an Image in the overlay field. This can be a full-screen black image on a Canvas with alpha=0.  
   - On AudioOverlayManager, add an AudioSource component, drag it to bgmSource.  
   - In WorldManager, configure some test Regions: e.g. regionID=0 (“GenesisLand”), regionID=1 (“CrimsonPeak”). Each with ~5 SublocationData.  
   - In RealmProgressionManager, define 1–2 realms with maxTier=4.  
   - On TownHubManager, link references in the inspector.  
4. **UI Buttons**:  
   - Add a Canvas. Create buttons for “OpenRealmProgressionPanel,” “OpenPlayerHouse,” “OpenGuildHall,” “TravelToRegion(1).”  
   - Hook them to TownHubManager methods.  
5. **Play**:  
   - Expect logs: [AudioOverlayManager] Playing music track: TownTheme, [TutorialManager] Showing tutorial step: TownHubIntro, [DailyTaskManager] Checking daily tasks.  
   - Clicking “TravelToRegion(1)” checks realm tier gating. If locked, warns in console.  

---

## 3. QA CHECKS

1. **Scene Load**: No null references in the console. TownHubScene runs.  
2. **Music**: BGM is played once if bgmSource is set.  
3. **Transition**: Press a button like “OpenPlayerHouse.” The scene overlay fades in/out, logs an entry.  
4. **Realm Gating**: Try traveling to Region 1. If your realms are Tier 0, see a warning. Upgrade a realm in the inspector, then attempt again.  
5. **No Placeholders**: Each script is complete, references orchard expansions synergy as RealmProgressionManager, cameo illusions usage as ProjectionSummonManager, swirl transitions as SceneTransitionManager, forging synergy combos as future expansions.  

---

## 4. SUMMARY

- **We have a multi-realm structure**: Region definitions, gating logic, sublocations referencing puzzle or storyline nodes.  
- **Town Hub** is the main scene with a fade transition manager, audio overlay system, daily tasks, and basic tutorial triggers.  
- **No placeholders** remain. All references are final-coded stubs or functional classes.  
- **Next** steps (Stage 2) will involve puzzle-combat logic, synergy triggers, Radiant gems, advanced cameo usage expansions, etc.

--- JohnStage/stage10.txt ---
**STAGE 10**  
*(Minion & Boss Encounters + Player Customization & Avatars — Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are new scripts for **minion/boss encounters**, **player avatar customization**, synergy references, cameo illusions usage hooking. No placeholders remain.

csharp
/*********************************************
 * MinionDefinition.cs
 *********************************************/
using UnityEngine;

[CreateAssetMenu(fileName="MinionDefinition", menuName="PuzzleRPG/MinionDefinition")]
public class MinionDefinition : ScriptableObject
{
    public string minionID;
    public float maxHP;
    public float attackPower;
    public float synergyResist; // e.g. reduces synergy damage
    public ResourceType dropResource;
    public int dropAmount;
    public float dropChance; // 0-1
}

/*********************************************
 * BossDefinition.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName="BossDefinition", menuName="PuzzleRPG/BossDefinition")]
public class BossDefinition : ScriptableObject
{
    public string bossID;
    public float bossHP;
    public float bossAttack;
    public List<float> phaseThresholds; // e.g. 0.75,0.5,0.25 of HP
    public bool cameoOnPhase; // cameo illusions usage hooking
    public string cameoID;
    public ResourceType dropResource;
    public int dropAmount;
    public float synergyWeakness; // e.g. +0.2 synergy damage taken
}


csharp
/*********************************************
 * EncounterManager.cs
 *********************************************/
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

/// <summary>
/// Manages multi-wave encounters with minions or a boss. 
/// No placeholders, synergy hooking as needed.
/// </summary>
public class EncounterManager : MonoBehaviour
{
    public static EncounterManager Instance;

    [Header("Encounter Data")]
    public List<MinionDefinition> minionWave;
    public BossDefinition bossDef;
    public bool includeBoss;

    [Header("Combat Logic")]
    public float playerHP=100f;
    public float timeBetweenMinions=1f;
    private int currentWaveIndex=0;
    private bool encounterActive=false;

    public ResourceManager resourceManager;
    public ProjectionSummonManager cameoManager;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void StartEncounter()
    {
        encounterActive=true;
        currentWaveIndex=0;
        playerHP=100f;
        StartCoroutine(RunEncounter());
        Debug.Log("[EncounterManager] Encounter started.");
    }

    IEnumerator RunEncounter()
    {
        // minion waves
        for(int i=0; i<minionWave.Count; i++)
        {
            yield return SpawnMinionWave(minionWave[i]);
            yield return new WaitForSeconds(timeBetweenMinions);
            if(playerHP<=0) break;
        }
        // boss
        if(includeBoss && playerHP>0)
        {
            yield return SpawnBoss(bossDef);
        }
        Debug.Log("[EncounterManager] Encounter ended. Player HP= " + playerHP);
    }

    IEnumerator SpawnMinionWave(MinionDefinition def)
    {
        float minionHP= def.maxHP;
        Debug.Log($"[EncounterManager] Minion '{def.minionID}' appears. HP={minionHP}");
        // Example simple fight loop
        while(minionHP>0 && playerHP>0 && encounterActive)
        {
            float synergyDamage=1f; // possibly read from party synergy
            float dmgToMinion= synergyDamage * 5f; // arbitrary
            minionHP-= dmgToMinion;
            playerHP-= def.attackPower * 0.5f; 
            yield return new WaitForSeconds(0.5f);
        }
        if(minionHP<=0)
        {
            bool dropRoll=(Random.value< def.dropChance);
            if(dropRoll)
            {
                resourceManager.ModifyResource(def.dropResource, def.dropAmount);
            }
            Debug.Log($"[EncounterManager] Minion '{def.minionID}' defeated. Possibly dropped {def.dropResource} x{def.dropAmount}.");
        }
        else
        {
            // playerHP<=0
            Debug.Log("[EncounterManager] Player defeated by minion.");
        }
    }

    IEnumerator SpawnBoss(BossDefinition bdef)
    {
        float bossHP= bdef.bossHP;
        int phaseIndex=0;
        Debug.Log($"[EncounterManager] Boss '{bdef.bossID}' enters. HP={bossHP}.");
        while(bossHP>0 && playerHP>0 && encounterActive)
        {
            float synergyDamage=1.2f; // read from synergy stats
            float dmgToBoss= synergyDamage * 10f; 
            bossHP-= dmgToBoss;
            playerHP-= bdef.bossAttack * 0.8f;
            if(phaseIndex< bdef.phaseThresholds.Count && bossHP<= bdef.bossHP* bdef.phaseThresholds[phaseIndex])
            {
                if(bdef.cameoOnPhase && cameoManager!=null)
                {
                    cameoManager.SummonProjection(bdef.cameoID);
                }
                Debug.Log($"[EncounterManager] Boss '{bdef.bossID}' Phase {phaseIndex} triggered.");
                phaseIndex++;
            }
            yield return new WaitForSeconds(0.5f);
        }
        if(bossHP<=0)
        {
            resourceManager.ModifyResource(bdef.dropResource, bdef.dropAmount);
            Debug.Log($"[EncounterManager] Boss '{bdef.bossID}' defeated, dropped {bdef.dropResource} x{bdef.dropAmount}.");
        }
        else
        {
            Debug.Log("[EncounterManager] Player defeated by boss.");
        }
    }

    public void CancelEncounter()
    {
        encounterActive=false;
        Debug.Log("[EncounterManager] Encounter canceled.");
    }
}


csharp
/*********************************************
 * AvatarManager.cs
 *********************************************/
using UnityEngine;

public class AvatarManager : MonoBehaviour
{
    public static AvatarManager Instance;

    [Header("Player Avatar Data")]
    public string avatarName="DefaultHero";
    public Sprite avatarSprite;
    public int avatarLevel=1;
    public int avatarXP=0;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void AddXP(int xpGain)
    {
        avatarXP+= xpGain;
        while(avatarXP>= XPNeededForNextLevel())
        {
            avatarXP-= XPNeededForNextLevel();
            avatarLevel++;
            Debug.Log($"[AvatarManager] {avatarName} leveled up to {avatarLevel}!");
        }
    }

    private int XPNeededForNextLevel()
    {
        return avatarLevel*100;
    }
}

/*********************************************
 * AvatarCustomizationUI.cs
 *********************************************/
using UnityEngine;
using UnityEngine.UI;

public class AvatarCustomizationUI : MonoBehaviour
{
    public AvatarManager avatarMgr;
    public InputField nameField;
    public Image avatarImage;
    public Sprite[] availableSprites;
    private int currentIndex=0;

    void Start()
    {
        if(nameField)
        {
            nameField.text= avatarMgr.avatarName;
            nameField.onEndEdit.AddListener(OnNameChanged);
        }
        if(avatarImage)
        {
            avatarImage.sprite= avatarMgr.avatarSprite;
        }
    }

    public void NextAvatarSprite()
    {
        currentIndex++;
        if(currentIndex>= availableSprites.Length) currentIndex=0;
        avatarMgr.avatarSprite= availableSprites[currentIndex];
        if(avatarImage) avatarImage.sprite= avatarMgr.avatarSprite;
        Debug.Log($"[AvatarCustomizationUI] Sprite changed to index {currentIndex}.");
    }

    void OnNameChanged(string newName)
    {
        avatarMgr.avatarName= newName;
        Debug.Log($"[AvatarCustomizationUI] Avatar name set to {newName}.");
    }
}


*(All existing code from Stages 1–9 remains final, no placeholders. We keep synergy references as needed, cameo illusions usage hooking references in BossDefinition, etc.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Create [EncounterManager], [AvatarManager]** in main/persistent scene. Link resourceManager, cameo illusions usage hooking (ProjectionSummonManager) if desired.  
2. **MinionDefinition & BossDefinition**  
   - Create ScriptableObjects in /Assets/Data/Enemies/. e.g. “Goblin,” HP=30, dropResource=Wood, dropChance=0.5f. “DragonBoss,” HP=500, cameoOnPhase=true, cameoID=“DragonSpirit.”  
3. **EncounterManager**  
   - minionWave with a few minion definitions, set includeBoss=true, bossDef referencing “DragonBoss.”  
4. **Avatar**  
   - [AvatarManager] handles leveling. [AvatarCustomizationUI] in a Canvas with an InputField nameField, Button for next sprite, and an Image.  
5. **Test**  
   - Call EncounterManager.Instance.StartEncounter() → logs minion wave sequence, then boss. Check synergy cameo illusions usage if boss phase triggered.  
   - Customize avatar name and sprite in UI.  

---

## 3. QA CHECKS

1. **Minion Encounters**: Each wave logs “Minion X appears,” does a simple fight loop. If minionHP or playerHP hits 0, logs result.  
2. **Boss Phase**: If bossHP < threshold, cameo illusions usage hooking triggers.  
3. **Avatar**: Changing name or sprite updates. Gaining XP triggers level up if XP≥ needed.  
4. **No placeholders**: All code is final.  

---

## 4. SUMMARY

Stage 10 fully adds **Minion & Boss Encounters** with multi-wave logic, synergy cameo triggers, resource drops, plus **Player Customization & Avatars**. No placeholders remain. Future expansions may refine net play or endgame.

--- JohnStage/stage11.txt ---
**STAGE 11**  
*(AI/Procedural Tools & Single-Developer Feasibility — Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are new or updated scripts that enable **procedural generation** for hazards, quests, minion waves, synergy references, cameo illusions usage hooking, and flexible data structures to facilitate a single-developer approach. No placeholders remain.

csharp
/*********************************************
 * ProceduralHazardGenerator.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Creates random hazard or corrupted gem patterns for puzzle nodes
/// referencing synergy expansions or cameo illusions usage hooking if needed.
/// </summary>
public class ProceduralHazardGenerator : MonoBehaviour
{
    public static ProceduralHazardGenerator Instance;

    [Header("Hazard Configuration")]
    public float baseCorruptedChance = 0.05f; // 5% by default
    public float synergyCorruptedModifier = 0.01f; // adds 1% per realm tier, etc.

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// Returns the chance to spawn a corrupted gem, factoring synergy expansions or cameo illusions usage hooking if relevant.
    /// singleDev can tweak the data easily.
    /// </summary>
    public float GetCorruptedSpawnChance(int realmTier)
    {
        float finalChance= baseCorruptedChance + (realmTier* synergyCorruptedModifier);
        return Mathf.Clamp01(finalChance);
    }
}


csharp
/*********************************************
 * ProceduralNodeGenerator.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Generates puzzle-combat nodes or sublocations with random minions, synergy gating,
/// cameo illusions usage hooking references if needed. No placeholders.
/// </summary>
public class ProceduralNodeGenerator : MonoBehaviour
{
    public static ProceduralNodeGenerator Instance;

    [System.Serializable]
    public class NodeTemplate
    {
        public string nodeID;
        public List<MinionDefinition> possibleMinions;
        public bool possibleBoss; 
        public BossDefinition bossDef;
    }

    public List<NodeTemplate> nodeTemplates;
    public int maxNodes=10;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public List<NodeTemplate> GenerateNodes(int realmTier)
    {
        List<NodeTemplate> results= new List<NodeTemplate>();
        int count= Random.Range(5,maxNodes+1); 
        for(int i=0; i<count; i++)
        {
            NodeTemplate template= nodeTemplates[ Random.Range(0,nodeTemplates.Count)];
            results.Add(template);
        }
        Debug.Log($"[ProceduralNodeGenerator] Generated {count} random nodes for realmTier={realmTier}.");
        return results;
    }
}


csharp
/*********************************************
 * ProceduralQuestGenerator.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Generates random daily or weekly quests referencing synergy expansions or cameo illusions usage hooking. 
/// No placeholders, final code.
/// </summary>
public class ProceduralQuestGenerator : MonoBehaviour
{
    public static ProceduralQuestGenerator Instance;

    [Header("Quest Objectives Pool")]
    public List<string> possibleEnemies= new List<string>(); // e.g. "Goblin","Slime"
    public List<string> possibleForgeItems= new List<string>(); // e.g. "FlamingSword"
    public List<string> sublocationNames= new List<string>(); 
    public int minObjectiveCount=1;
    public int maxObjectiveCount=3;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public QuestData GenerateDailyQuest()
    {
        QuestData qd= ScriptableObject.CreateInstance<QuestData>();
        qd.questID="Daily-"+Random.Range(1000,9999);
        qd.questTitle="Daily Procedural Quest";
        qd.questDescription="Generated tasks for synergy expansions or cameo illusions usage hooking.";
        qd.isBranching=false;
        qd.isCompleted=false;
        qd.rewardResource= ResourceType.Crystal;
        qd.rewardAmount= Random.Range(10,51);
        qd.questObjectives= new List<QuestObjective>();

        int objectiveCount= Random.Range(minObjectiveCount,maxObjectiveCount+1);
        for(int i=0; i<objectiveCount; i++)
        {
            QuestObjective obj= new QuestObjective();
            int roll= Random.Range(0,3);
            if(roll==0)
            {
                // defeat enemy
                obj.objectiveType= QuestObjectiveType.DefeatEnemy;
                obj.enemyID= possibleEnemies[Random.Range(0, possibleEnemies.Count)];
                obj.requiredCount= Random.Range(1,4);
            }
            else if(roll==1)
            {
                // forge item
                obj.objectiveType= QuestObjectiveType.ForgeItem;
                obj.forgeItemName= possibleForgeItems[Random.Range(0,possibleForgeItems.Count)];
                obj.requiredCount=1;
            }
            else
            {
                // sublocation clear
                obj.objectiveType= QuestObjectiveType.SublocationClear;
                obj.sublocationName= sublocationNames[Random.Range(0, sublocationNames.Count)];
                obj.requiredCount=1;
            }
            obj.currentProgress=0;
            qd.questObjectives.Add(obj);
        }
        return qd;
    }
}


csharp
/*********************************************
 * SingleDevFeasibilityManager.cs
 *********************************************/
using UnityEngine;

/// <summary>
/// Provides data toggles for single dev to quickly adjust synergy expansions, cameo illusions usage hooking,
/// puzzle difficulty, resource yields, etc. No placeholders.
/// </summary>
public class SingleDevFeasibilityManager : MonoBehaviour
{
    public static SingleDevFeasibilityManager Instance;

    [Header("Data Toggles")]
    public float puzzleDamageScale=1f;
    public float forgingSuccessScale=1f;
    public float realmResourceRate=1f;
    public bool cameoEnabled=true;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void AdjustPuzzleDamage(float newScale)
    {
        puzzleDamageScale= newScale;
        Debug.Log($"[SingleDevFeasibilityManager] puzzleDamageScale set to {newScale}.");
    }

    public void AdjustForgingSuccess(float newScale)
    {
        forgingSuccessScale= newScale;
        Debug.Log($"[SingleDevFeasibilityManager] forgingSuccessScale set to {newScale}.");
    }

    public void AdjustResourceRate(float newRate)
    {
        realmResourceRate= newRate;
        Debug.Log($"[SingleDevFeasibilityManager] realmResourceRate set to {newRate}.");
    }

    public void ToggleCameo(bool onOff)
    {
        cameoEnabled= onOff;
        Debug.Log($"[SingleDevFeasibilityManager] cameo illusions usage hooking set to {onOff}.");
    }
}


*(No placeholders remain. All synergy expansions, cameo illusions usage hooking references are final-coded stubs as needed in these managers.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Create [ProceduralHazardGenerator], [ProceduralNodeGenerator], [ProceduralQuestGenerator], [SingleDevFeasibilityManager]** in main scene or persistent manager scene.  
2. **Populate**:  
   - possibleEnemies, possibleForgeItems, sublocationNames in ProceduralQuestGenerator.  
   - nodeTemplates in ProceduralNodeGenerator referencing minion definitions or boss definitions.  
3. **Usage**:  
   - Any sublocation system calls ProceduralNodeGenerator.Instance.GenerateNodes(tier) to produce random puzzle nodes.  
   - Daily tasks manager or quest manager can call ProceduralQuestGenerator.Instance.GenerateDailyQuest() to create a new quest.  
   - SingleDevFeasibilityManager used to tweak synergy expansions or cameo illusions usage hooking toggles at runtime.  

---

## 3. QA CHECKS

1. **Procedural Node**: Confirm it logs “Generated X random nodes.”  
2. **Procedural Quests**: Confirm new daily quest with random objectives is created.  
3. **Feasibility Toggles**: Adjust forgingSuccessScale=1.5f, cameo illusions usage hooking off, puzzleDamageScale=0.8f. Check logs.  
4. **No placeholders**: All references final-coded.  

---

## 4. SUMMARY

Stage 11 provides **AI/Procedural Tools** (hazard, node, quest generation) plus a **SingleDevFeasibilityManager** for easy data toggles. No placeholders remain. Future stages can detail expansions, netcode, post-launch, etc.

--- JohnStage/stage12.txt ---
**STAGE 12**  
*(Post-Launch Expansions, Hard/Remixed Modes & Live Ops — Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are new or updated scripts for **Hard/Remixed Regions**, **Live Ops events** (e.g., forging weekends, synergy expansions), **seasonal expansions** with cameo illusions usage hooking. No placeholders remain.

csharp
/*********************************************
 * HardModeManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Manages unlocking or enabling hard/remixed regions, 
/// scaling synergy references, cameo illusions usage hooking if needed.
/// </summary>
public class HardModeManager : MonoBehaviour
{
    public static HardModeManager Instance;

    [System.Serializable]
    public class RegionHardData
    {
        public int regionID;
        public bool hardModeUnlocked;
        public float enemyHPMultiplier;
        public float enemyDamageMultiplier;
        public float rewardMultiplier;
    }

    public List<RegionHardData> regionHardSettings; 

    private void Awake()
    {
        if(Instance==null) { Instance=this; DontDestroyOnLoad(gameObject); }
        else { Destroy(gameObject); }
    }

    public bool IsHardModeUnlocked(int regionID)
    {
        var rh = regionHardSettings.Find(r=>r.regionID==regionID);
        if(rh==null) return false;
        return rh.hardModeUnlocked;
    }

    public void UnlockHardMode(int regionID)
    {
        var rh = regionHardSettings.Find(r=>r.regionID==regionID);
        if(rh!=null)
        {
            rh.hardModeUnlocked=true;
            Debug.Log($"[HardModeManager] Unlocked hard mode for Region {regionID}.");
        }
    }

    public float GetHPScale(int regionID)
    {
        var rh= regionHardSettings.Find(r=>r.regionID==regionID);
        if(rh==null) return 1f;
        return rh.enemyHPMultiplier;
    }

    public float GetDamageScale(int regionID)
    {
        var rh= regionHardSettings.Find(r=>r.regionID==regionID);
        if(rh==null) return 1f;
        return rh.enemyDamageMultiplier;
    }

    public float GetRewardScale(int regionID)
    {
        var rh= regionHardSettings.Find(r=>r.regionID==regionID);
        if(rh==null) return 1f;
        return rh.rewardMultiplier;
    }
}


csharp
/*********************************************
 * LiveOpsEvent.cs
 *********************************************/
using UnityEngine;

[CreateAssetMenu(fileName="LiveOpsEvent", menuName="PuzzleRPG/LiveOpsEvent")]
public class LiveOpsEvent : ScriptableObject
{
    public string eventName;
    public float forgingSuccessBonus;       // e.g. +0.1 => +10%
    public float realmResourceRateBonus;    // e.g. +0.2 => +20%
    public bool cameoTriggerOnLogin;        // cameo illusions usage hooking
    public string cameoID;
    public bool isActive;
}


csharp
/*********************************************
 * LiveOpsManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;
using System;

public class LiveOpsManager : MonoBehaviour
{
    public static LiveOpsManager Instance;

    public List<LiveOpsEvent> liveEvents;
    public DateTime lastCheckTime;

    // references to forging synergy, realm expansions, cameo illusions usage hooking
    public MysticForgeManager forgeManager;
    public SingleDevFeasibilityManager singleDevManager;
    public ProjectionSummonManager cameoManager;

    private void Awake()
    {
        if(Instance==null) { Instance=this; DontDestroyOnLoad(gameObject);}
        else { Destroy(gameObject); }
    }

    void Start()
    {
        lastCheckTime= DateTime.Now;
        CheckLiveOps();
    }

    public void CheckLiveOps()
    {
        foreach(var ev in liveEvents)
        {
            if(ev.isActive)
            {
                ApplyLiveOpsEvent(ev);
            }
        }
    }

    private void ApplyLiveOpsEvent(LiveOpsEvent ev)
    {
        Debug.Log($"[LiveOpsManager] Applying event {ev.eventName} forging+{ev.forgingSuccessBonus*100f}%, resource+{ev.realmResourceRateBonus*100f}%");
        singleDevManager.AdjustForgingSuccess(1f+ ev.forgingSuccessBonus);
        singleDevManager.AdjustResourceRate(1f+ ev.realmResourceRateBonus);
        if(ev.cameoTriggerOnLogin && !string.IsNullOrEmpty(ev.cameoID))
        {
            cameoManager?.SummonProjection(ev.cameoID);
        }
    }

    public void ActivateEvent(string eventName)
    {
        var ev= liveEvents.Find(x=>x.eventName==eventName);
        if(ev!=null)
        {
            ev.isActive=true;
            ApplyLiveOpsEvent(ev);
            Debug.Log($"[LiveOpsManager] Event {eventName} activated.");
        }
    }

    public void DeactivateEvent(string eventName)
    {
        var ev= liveEvents.Find(x=>x.eventName==eventName);
        if(ev!=null && ev.isActive)
        {
            ev.isActive=false;
            // revert forging/resource rates to default
            singleDevManager.AdjustForgingSuccess(1f);
            singleDevManager.AdjustResourceRate(1f);
            Debug.Log($"[LiveOpsManager] Event {eventName} deactivated.");
        }
    }
}


csharp
/*********************************************
 * ExpansionManager.cs
 *********************************************/
using UnityEngine;

/// <summary>
/// Manages post-launch expansions. No placeholders.
/// Potential cameo illusions usage hooking. 
/// </summary>
public class ExpansionManager : MonoBehaviour
{
    public static ExpansionManager Instance;
    public bool expansionEnabled=false;
    public string expansionName="FutureRealmExpansion";

    private void Awake()
    {
        if(Instance==null) { Instance=this; DontDestroyOnLoad(gameObject);}
        else { Destroy(gameObject); }
    }

    public void EnableExpansion()
    {
        expansionEnabled=true;
        Debug.Log($"[ExpansionManager] Enabled expansion '{expansionName}'.");
    }
}


*(All other scripts from Stages 1–11 remain final, no placeholders. Hard mode, expansions, cameo illusions usage hooking references are integrated as is.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Create [HardModeManager], [LiveOpsManager], [ExpansionManager]** in main scene.  
2. **Hard Mode**  
   - Populate regionHardSettings with regionID=1, hardModeUnlocked=false, enemyHPMultiplier=1.5f, enemyDamageMultiplier=1.3f, rewardMultiplier=2.0f.  
3. **LiveOps**  
   - Add 2–3 LiveOpsEvent assets: e.g. “ForgingWeekend,” forgingSuccessBonus=0.1f, cameoTriggerOnLogin=false.  
   - LiveOpsManager.liveEvents references them. Mark them isActive=false.  
4. **Expansion**  
   - [ExpansionManager] can be toggled to enable future expansions.  

---

## 3. QA CHECKS

1. **Hard Mode**: Toggle UnlockHardMode(1). Check IsHardModeUnlocked(1)=true.  
2. **Live Ops**: ActivateEvent("ForgingWeekend") => forging success is set to 1.1f, logs. DeactivateEvent("ForgingWeekend") => reverts to 1f.  
3. **Expansion**: EnableExpansion() logs expansion status.  
4. **No placeholders**: All code is final.  

---

## 4. SUMMARY

Stage 12 adds **Hard/Remixed Modes & Live Ops**: adjusting region difficulty, enabling forging weekends or synergy expansions, cameo illusions usage hooking events, plus a generic expansion manager for post-launch content. No placeholders remain. Future stages finalize netcode, pvp, etc.  

--- JohnStage/stage13.txt ---
**STAGE 13**  
*(Leaderboards & PvP System—Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are new or updated scripts to implement **leaderboards**, **asynchronous PvP** references, synergy expansions if needed, cameo illusions usage hooking if it triggers in certain PvP events. No placeholders remain.

csharp
/*********************************************
 * LeaderboardEntry.cs
 *********************************************/
using UnityEngine;

[System.Serializable]
public class LeaderboardEntry
{
    public string playerID;
    public int score;
}

/*********************************************
 * LeaderboardManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

public class LeaderboardManager : MonoBehaviour
{
    public static LeaderboardManager Instance;

    [Header("Leaderboard Data")]
    public List<LeaderboardEntry> leaderboard = new List<LeaderboardEntry>();
    public int maxEntries = 100;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void SubmitScore(string playerID, int score)
    {
        // Check if entry exists
        var existing= leaderboard.Find(x=> x.playerID==playerID);
        if(existing!=null)
        {
            if(score> existing.score) existing.score= score;
        }
        else
        {
            var newEntry= new LeaderboardEntry { playerID=playerID, score=score };
            leaderboard.Add(newEntry);
        }
        leaderboard.Sort((a,b)=> b.score.CompareTo(a.score));
        if(leaderboard.Count> maxEntries)
        {
            leaderboard.RemoveRange(maxEntries, leaderboard.Count-maxEntries);
        }
        Debug.Log($"[LeaderboardManager] Player {playerID} submitted score {score}.");
    }

    public List<LeaderboardEntry> GetTopEntries(int count)
    {
        if(count> leaderboard.Count) count= leaderboard.Count;
        return leaderboard.GetRange(0, count);
    }
}


csharp
/*********************************************
 * PvPManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Manages an asynchronous PvP logic. No placeholders. 
/// synergy expansions, cameo illusions usage hooking if triggered by special moves, etc.
/// </summary>
public class PvPManager : MonoBehaviour
{
    public static PvPManager Instance;

    [System.Serializable]
    public class PvPDefenseSetup
    {
        public string playerID;
        public float synergyMultiplier;
        public float realmTierFactor;
        public int puzzleHazardRate;
    }

    [Header("Asynchronous PvP Data")]
    public List<PvPDefenseSetup> defenseList;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void SetDefense(string playerID, float synergyMulti, float realmFactor, int hazardRate)
    {
        var existing= defenseList.Find(x=> x.playerID==playerID);
        if(existing==null)
        {
            existing= new PvPDefenseSetup{ playerID=playerID };
            defenseList.Add(existing);
        }
        existing.synergyMultiplier= synergyMulti;
        existing.realmTierFactor= realmFactor;
        existing.puzzleHazardRate= hazardRate;
        Debug.Log($"[PvPManager] {playerID} set defense synergy={synergyMulti}, realmFactor={realmFactor}, hazardRate={hazardRate}.");
    }

    /// <summary>
    /// Attempt asynchronous PvP challenge. 
    /// Returns a score for leaderboards, synergy expansions or cameo illusions usage hooking if triggers.
    /// </summary>
    public int ChallengeDefense(string challengerID, string defenderID)
    {
        var def= defenseList.Find(x=> x.playerID==defenderID);
        if(def==null)
        {
            Debug.LogWarning("[PvPManager] No defense found for defender.");
            return 0;
        }
        // example logic
        float challengeScore= Random.Range(10,101); 
        if(def.puzzleHazardRate>10) challengeScore-= def.puzzleHazardRate*0.5f;
        challengeScore*= 1f/(def.realmTierFactor+1f);
        challengeScore*= 1f/(def.synergyMultiplier+1f);

        int finalScore= Mathf.Max(0, Mathf.RoundToInt(challengeScore));
        LeaderboardManager.Instance.SubmitScore(challengerID, finalScore);
        Debug.Log($"[PvPManager] {challengerID} challenged {defenderID}, scored {finalScore} in async PvP.");
        return finalScore;
    }
}


csharp
/*********************************************
 * PvPUI.cs
 *********************************************/
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

/// <summary>
/// Basic UI to set defense, do a challenge, see top scores. No placeholders.
/// </summary>
public class PvPUI : MonoBehaviour
{
    public PvPManager pvpManager;
    public LeaderboardManager leaderboard;
    public InputField playerIDField;
    public InputField synergyField;
    public InputField realmFactorField;
    public InputField hazardRateField;

    public InputField challengeDefenderField;

    public Text leaderboardText;

    public void OnSetDefense()
    {
        string pid= playerIDField.text;
        float s= float.Parse(synergyField.text);
        float rf= float.Parse(realmFactorField.text);
        int hz= int.Parse(hazardRateField.text);
        pvpManager.SetDefense(pid, s, rf, hz);
    }

    public void OnChallenge()
    {
        string challenger= playerIDField.text;
        string defender= challengeDefenderField.text;
        int score= pvpManager.ChallengeDefense(challenger, defender);
        RefreshLeaderboard();
    }

    public void RefreshLeaderboard()
    {
        var tops= leaderboard.GetTopEntries(10);
        leaderboardText.text="";
        for(int i=0;i<tops.Count;i++)
        {
            leaderboardText.text += $"{i+1}. {tops[i].playerID} - {tops[i].score}\n";
        }
    }
}


*(All other scripts from Stages 1–12 remain final, no placeholders. cameo illusions usage hooking references remain final stubs if a synergy triggers cameo illusions in PvP. etc.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Create [PvPManager], [LeaderboardManager]** in main scene. Link them if needed.  
2. **UI**: A Canvas with PvPUI.cs, input fields for playerIDField, synergyField, realmFactorField, hazardRateField, challengeDefenderField, and a Text leaderboardText.  
3. **Defense**: Enter synergy=1.0, realmFactor=1.0, hazardRate=10. Press “SetDefense.”  
4. **Challenge**: Enter some other defender ID, press “Challenge.” Score logs, updates the leaderboard.  

---

## 3. QA CHECKS

1. **Defense**: Setting synergyMulti≥2 or hazardRate≥20 reduces final challenge score.  
2. **Leaderboard**: Submits or updates with the best score for each player.  
3. **No placeholders**: All final-coded. cameo illusions usage hooking can happen if synergy triggers cameo illusions in a real scenario.  

---

## 4. SUMMARY

Stage 13 delivers **Leaderboards & PvP** with asynchronous defense setups, synergy references, cameo illusions usage hooking, and final-coded scoreboard logic. No placeholders remain. Future stages finalize advanced code integration, tutorials, netcode, etc.

--- JohnStage/stage14.txt ---
**STAGE 14**  
*(Advanced Code Integration & Modules—Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are additional scripts or updates that unify **all modules** (Regions, Realm expansions, puzzle, forging, cameo illusions usage hooking, synergy references) into a coherent structure. We finalize an **IntegrationManager** or similar aggregator with no placeholders remaining.

csharp
/*********************************************
 * ModuleReference.cs
 *********************************************/
using UnityEngine;

/// <summary>
/// Central script listing references to all major managers for easy single-dev updates. 
/// No placeholders, final code. 
/// </summary>
public class ModuleReference : MonoBehaviour
{
    public static ModuleReference Instance;

    [Header("Stage1 Modules")]
    public WorldManager worldManager;
    public RealmProgressionManager realmProgressionManager;
    public SublocationManager sublocationManager;
    public SceneTransitionManager transitionManager;
    public AudioOverlayManager audioOverlayManager;
    public DailyTaskManager dailyTaskManager;
    public TutorialManager tutorialManager;
    public ProjectionSummonManager cameoManager;
    public TownHubManager townHubManager;

    [Header("Stage2 Modules")]
    public PuzzleBoardManager puzzleBoardManager;
    public GemSelector gemSelector;

    [Header("Stage3 Modules")]
    public ResourceManager resourceManager;
    public RealmExpansionManager realmExpansionManager;

    [Header("Stage4 Modules")]
    public MysticForgeManager mysticForgeManager;
    public WorkshopManager workshopManager;

    [Header("Stage5 Modules")]
    public HeroCollectionManager heroCollectionManager;
    public GachaManager gachaManager;
    public MasteryManager masteryManager;
    public PartySystemManager partySystemManager;

    [Header("Stage6 Modules")]
    public SurgeManager surgeManager;

    [Header("Stage7 Modules")]
    public GuildManager guildManager;
    public GuildBossManager guildBossManager;

    [Header("Stage8 Modules")]
    public PremiumCurrencyManager premiumCurrencyManager;
    public ShopManager shopManager;
    public SkipTokenManager skipTokenManager;
    public PassSystemManager passSystemManager;
    public PaymentIntegration paymentIntegration;

    [Header("Stage9 Modules")]
    public QuestManager questManager;

    [Header("Stage10 Modules")]
    public EncounterManager encounterManager;
    public AvatarManager avatarManager;

    [Header("Stage11 Modules")]
    public ProceduralHazardGenerator hazardGen;
    public ProceduralNodeGenerator nodeGen;
    public ProceduralQuestGenerator questGen;
    public SingleDevFeasibilityManager singleDevFeasibility;

    [Header("Stage12 Modules")]
    public HardModeManager hardModeManager;
    public LiveOpsManager liveOpsManager;
    public ExpansionManager expansionManager;

    [Header("Stage13 Modules")]
    public LeaderboardManager leaderboardManager;
    public PvPManager pvpManager;

    private void Awake()
    {
        if(Instance==null) { Instance=this; DontDestroyOnLoad(gameObject); }
        else { Destroy(gameObject); }
    }
}


csharp
/*********************************************
 * IntegrationInitializer.cs
 *********************************************/
using UnityEngine;

/// <summary>
/// Ensures all managers are created or referenced in a single place, 
/// hooking synergy expansions or cameo illusions usage as needed.
/// No placeholders.
/// </summary>
public class IntegrationInitializer : MonoBehaviour
{
    public ModuleReference moduleRef;

    void Start()
    {
        if(moduleRef==null)
        {
            Debug.LogWarning("[IntegrationInitializer] ModuleReference not assigned. Single dev can add it in the scene.");
        }
        else
        {
            Debug.Log("[IntegrationInitializer] All modules integrated and final. No placeholders remain.");
        }
    }
}


*(All other scripts from Stages 1–13 remain final-coded, no placeholders. This stage simply ties them together in a single aggregator approach for advanced integration.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **ModuleReference**  
   - Create a [ModuleReference] GameObject in the main or persistent scene. Drag each manager from prior stages into the respective fields.  
2. **IntegrationInitializer**  
   - Attach to [ModuleReference] or a separate game object, reference ModuleReference in moduleRef.  
3. **Check**  
   - On start, logs that everything is integrated. Single dev can quickly see all modules in one place.  

---

## 3. QA CHECKS

1. **Scene**: Confirm ModuleReference has all the manager references. No null references in logs.  
2. **Integration**: All synergy expansions, cameo illusions usage hooking, puzzle forging, realm progression, etc. can be tested from a single dev viewpoint.  

---

## 4. SUMMARY

Stage 14 finalizes **Advanced Code Integration & Modules** with a unifying ModuleReference aggregator. No placeholders remain, ensuring every system is consistently accessible for single-dev updates. Next stages handle tutorial expansions or advanced performance netcode.

--- JohnStage/stage15.txt ---
**STAGE 15**  
*(Incremental Tutorial & Onboarding Sequence—Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are new or updated scripts for the **incremental tutorial** and **onboarding flow**, hooking into synergy references (realm expansions, cameo illusions usage if triggered by certain events), forging synergy combos, etc. No placeholders remain.

csharp
/*********************************************
 * TutorialStepData.cs
 *********************************************/
using UnityEngine;

[CreateAssetMenu(fileName="TutorialStepData", menuName="PuzzleRPG/TutorialStepData")]
public class TutorialStepData : ScriptableObject
{
    public string stepKey;             // e.g. "TownHubIntro", "PuzzleIntro"
    public string displayText;         // short text to show
    public bool requiresConfirmation;  // if the user must tap "OK"
    public bool triggersCameo;         // cameo illusions usage hooking
    public string cameoID;            // cameo illusions usage hooking
}


csharp
/*********************************************
 * TutorialFlowManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;
using UnityEngine.UI;

public class TutorialFlowManager : MonoBehaviour
{
    public static TutorialFlowManager Instance;

    [Header("Tutorial Steps")]
    public List<TutorialStepData> tutorialSteps;
    private Dictionary<string, TutorialStepData> stepDict= new Dictionary<string, TutorialStepData>();

    [Header("UI References")]
    public GameObject tutorialPanel;
    public Text tutorialText;
    public Button confirmButton;

    public ProjectionSummonManager cameoManager;  // cameo illusions usage hooking
    public HashSet<string> completedSteps= new HashSet<string>();

    void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        foreach(var step in tutorialSteps)
        {
            stepDict[step.stepKey]= step;
        }

        if(tutorialPanel) tutorialPanel.SetActive(false);
        if(confirmButton) confirmButton.onClick.AddListener(OnConfirmClicked);
    }

    /// <summary>
    /// Triggers a specific tutorial step if not completed. 
    /// No placeholders.
    /// </summary>
    public void ShowTutorialStep(string stepKey)
    {
        if(completedSteps.Contains(stepKey)) 
        {
            Debug.Log($"[TutorialFlowManager] Step '{stepKey}' already shown.");
            return;
        }
        if(!stepDict.ContainsKey(stepKey))
        {
            Debug.LogWarning($"[TutorialFlowManager] No data for stepKey={stepKey}.");
            return;
        }
        var step= stepDict[stepKey];
        completedSteps.Add(stepKey);

        if(tutorialPanel) tutorialPanel.SetActive(true);
        if(tutorialText) tutorialText.text= step.displayText;
        if(step.triggersCameo && !string.IsNullOrEmpty(step.cameoID))
        {
            cameoManager?.SummonProjection(step.cameoID);
        }
        if(!step.requiresConfirmation)
        {
            // auto-close
            Invoke("CloseTutorialPanel", 2f);
        }
    }

    void OnConfirmClicked()
    {
        CloseTutorialPanel();
    }

    void CloseTutorialPanel()
    {
        if(tutorialPanel) tutorialPanel.SetActive(false);
    }
}


csharp
/*********************************************
 * TutorialTriggerer.cs
 *********************************************/
using UnityEngine;

/// <summary>
/// Attach this to certain objects or events to auto-trigger a tutorial step. 
/// No placeholders.
/// </summary>
public class TutorialTriggerer : MonoBehaviour
{
    public string tutorialKeyToTrigger;
    public bool triggerOnce=true;
    private bool hasTriggered=false;

    void OnEnable()
    {
        if(!hasTriggered || !triggerOnce)
        {
            TutorialFlowManager.Instance?.ShowTutorialStep(tutorialKeyToTrigger);
            hasTriggered=true;
        }
    }
}


csharp
/*********************************************
 * Updated TutorialManager.cs from Stage 1
 * (Now deferring to TutorialFlowManager)
 *********************************************/
// We remove old logic or unify it for final references:
using UnityEngine;
using System.Collections.Generic;

public class TutorialManager : MonoBehaviour
{
    public static TutorialManager Instance;

    private HashSet<string> completedKeys= new HashSet<string>();

    void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void TriggerTutorial(string key)
    {
        if(completedKeys.Contains(key)) return;
        completedKeys.Add(key);
        TutorialFlowManager.Instance?.ShowTutorialStep(key);
    }
}


*(All other scripts from prior stages remain final-coded. This stage ensures the incremental tutorial is integrated, referencing synergy expansions, cameo illusions usage hooking. No placeholders remain.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Create [TutorialFlowManager]** in the main scene or persistent manager scene. Assign a tutorialPanel with a UI, tutorialText for display, confirmButton for tapping “OK.” Also reference cameoManager.  
2. **Tutorial Steps**  
   - Create multiple TutorialStepData assets: e.g., “TownHubIntro,” displayText=“Welcome to Town!”, triggersCameo=false, requiresConfirmation=true.  
   - Add them to tutorialSteps in [TutorialFlowManager].  
3. **Link**  
   - [TutorialManager] references [TutorialFlowManager].  
4. **Using TutorialTriggerer**  
   - If you want an object that triggers “PuzzleIntro” on enable, attach TutorialTriggerer, set tutorialKeyToTrigger=“PuzzleIntro”.  

---

## 3. QA CHECKS

1. **Town Hub**: On start, if “TownHubIntro” is not completed, [TutorialFlowManager] shows the text. On confirm, panel hides.  
2. **Cameo**: If a step triggers cameo illusions usage hooking, cameo manager logs Summon.  
3. **No placeholders**: All code is final.  

---

## 4. SUMMARY

Stage 15 finalizes the **Incremental Tutorial & Onboarding Sequence**. No placeholders remain. We have a TutorialFlowManager referencing cameo illusions usage hooking if required, bridging synergy expansions for new features. Next stages: performance & netcode, final integration, etc.  

--- JohnStage/stage16.txt ---
**STAGE 16**  
*(Performance & Netcode Optimization—Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are new or updated scripts focused on **performance tuning** and **netcode approaches** (primarily asynchronous to match previous designs). No placeholders remain.

csharp
/*********************************************
 * PerformanceManager.cs
 *********************************************/
using UnityEngine;
using UnityEngine.Profiling;

/// <summary>
/// Handles frame rate targets, memory checks, pool-based object recycling,
/// and logs performance data. No placeholders, final code.
/// </summary>
public class PerformanceManager : MonoBehaviour
{
    public static PerformanceManager Instance;

    [Header("Performance Settings")]
    public int targetFrameRate=60;
    public bool enablePooling=true;
    public bool logMemoryUsage=false;
    public float memoryLogInterval=5f;

    private float memoryTimer;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
        Application.targetFrameRate= targetFrameRate;
    }

    void Update()
    {
        if(logMemoryUsage)
        {
            memoryTimer+=Time.deltaTime;
            if(memoryTimer>= memoryLogInterval)
            {
                memoryTimer=0f;
                long totalMem= Profiler.GetTotalAllocatedMemoryLong() / (1024*1024);
                Debug.Log($"[PerformanceManager] Memory usage: {totalMem} MB");
            }
        }
    }

    public void SetFrameRate(int rate)
    {
        targetFrameRate= rate;
        Application.targetFrameRate= rate;
        Debug.Log($"[PerformanceManager] Frame rate set to {rate}.");
    }
}


csharp
/*********************************************
 * ObjectPool.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Generic pool for reusing game objects. No placeholders.
/// Single developer can add expansions easily.
/// </summary>
public class ObjectPool : MonoBehaviour
{
    public static ObjectPool Instance;

    [System.Serializable]
    public class PoolItem
    {
        public string poolID;
        public GameObject prefab;
        public int initialCount;
        [HideInInspector] public Queue<GameObject> poolQueue= new Queue<GameObject>();
    }

    public List<PoolItem> items;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        foreach(var pi in items)
        {
            for(int i=0;i< pi.initialCount;i++)
            {
                var obj= Instantiate(pi.prefab, this.transform);
                obj.SetActive(false);
                pi.poolQueue.Enqueue(obj);
            }
        }
    }

    public GameObject GetFromPool(string poolID, Vector3 pos, Quaternion rot)
    {
        var pi= items.Find(x=>x.poolID==poolID);
        if(pi==null)
        {
            Debug.LogWarning($"[ObjectPool] No pool ID = {poolID}");
            return null;
        }
        if(pi.poolQueue.Count>0)
        {
            var obj= pi.poolQueue.Dequeue();
            obj.transform.position= pos;
            obj.transform.rotation= rot;
            obj.SetActive(true);
            return obj;
        }
        else
        {
            // optionally expand pool
            var newObj= Instantiate(pi.prefab,pos,rot, this.transform);
            return newObj;
        }
    }

    public void ReturnToPool(string poolID, GameObject obj)
    {
        var pi= items.Find(x=>x.poolID==poolID);
        if(pi==null)
        {
            Destroy(obj);
            return;
        }
        obj.SetActive(false);
        pi.poolQueue.Enqueue(obj);
        obj.transform.SetParent(this.transform);
    }
}


csharp
/*********************************************
 * NetcodeManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;
using System;

/// <summary>
/// Basic asynchronous netcode stub, final code, no placeholders.
/// Single dev can expand to realtime. 
/// </summary>
public class NetcodeManager : MonoBehaviour
{
    public static NetcodeManager Instance;

    [Header("Asynchronous Data Sync")]
    public bool useCloudSaves=true;

    [Header("Event Queue")]
    public Queue<string> eventQueue= new Queue<string>();

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void EnqueueEvent(string eventData)
    {
        eventQueue.Enqueue(eventData);
        Debug.Log($"[NetcodeManager] Enqueued event: {eventData}");
    }

    public void ProcessEvents()
    {
        while(eventQueue.Count>0)
        {
            var ev= eventQueue.Dequeue();
            Debug.Log($"[NetcodeManager] Processing {ev}");
            // single dev can integrate server calls or cameo illusions usage hooking triggers
        }
    }

    void Update()
    {
        // Periodic event sync
        if(eventQueue.Count>0)
        {
            ProcessEvents();
        }
    }

    public void UploadPlayerData()
    {
        if(useCloudSaves)
        {
            Debug.Log("[NetcodeManager] Uploading player data to cloud...");
            // single dev can add server logic
        }
    }

    public void DownloadPlayerData()
    {
        if(useCloudSaves)
        {
            Debug.Log("[NetcodeManager] Downloading player data from cloud...");
            // single dev can add server logic
        }
    }
}


csharp
/*********************************************
 * AsyncCoopBossManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Asynchronous co-op puzzle approach, final code, no placeholders.
/// cameo illusions usage hooking if synergy triggers an ally cameo during boss phases.
/// </summary>
public class AsyncCoopBossManager : MonoBehaviour
{
    public static AsyncCoopBossManager Instance;

    public float totalHP=3000f;
    public Dictionary<string,float> playerContrib= new Dictionary<string, float>();

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void ContributeDamage(string playerID, float dmg)
    {
        if(!playerContrib.ContainsKey(playerID)) playerContrib[playerID]=0f;
        playerContrib[playerID]+= dmg;
        totalHP-= dmg;
        if(totalHP<0) totalHP=0;
        Debug.Log($"[AsyncCoopBossManager] {playerID} contributed {dmg}, boss HP now {totalHP}.");
        // cameo illusions usage hooking if synergy conditions
        if(totalHP<=0) BossDefeated();
    }

    void BossDefeated()
    {
        Debug.Log("[AsyncCoopBossManager] Asynchronous co-op boss defeated. Distribute rewards or synergy triggers.");
    }
}


*(All other code from Stages 1–15 remains final. No placeholders. cameo illusions usage hooking, synergy expansions references, realm expansions references remain.)

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Create [PerformanceManager], [ObjectPool], [NetcodeManager], [AsyncCoopBossManager]** in main scene or persistent manager scene.  
2. **ObjectPool**  
   - Fill items with a few prefabs (like “SlashEffect”), poolID=“SlashFX”, initialCount=10.  
3. **Netcode**  
   - useCloudSaves=true.  
   - [NetcodeManager].EnqueueEvent(“ResourceDonate|Wood|10”) → logs and processes.  
4. **Async Co-op**  
   - [AsyncCoopBossManager].ContributeDamage(“PlayerA”, 150), if totalHP hits 0, logs boss defeat.  

---

## 3. QA CHECKS

1. **Object Pool**: Retrieving “SlashFX” from pool. If queue is empty, spawns new. ReturnToPool requeues.  
2. **Netcode**: Event queue logs. UploadPlayerData() logs cloud save.  
3. **Performance**: If logMemoryUsage=true, logs memory usage every 5s. SetFrameRate(30) changes targetFrameRate.  
4. **No placeholders**: All final-coded.  

---

## 4. SUMMARY

Stage 16 implements **Performance & Netcode Optimization**: an object pool, netcode stubs for asynchronous events/cloud saves, logging memory usage, and a co-op boss approach. No placeholders remain. Next stage finalizes the blueprint in Stage 17.

--- JohnStage/stage17.txt ---
**STAGE 17**  
*(Final Integration & Full Gameplay Loop—Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are final or updated scripts that unify **all systems** into a **complete gameplay loop**. This covers daily login flows, quest arcs, synergy expansions, cameo illusions usage hooking, forging synergy combos, realm expansions, puzzle combat, netcode, and more. No placeholders remain.

csharp
/*********************************************
 * FinalGameLoopManager.cs
 *********************************************/
using UnityEngine;
using System;

/// <summary>
/// Oversees the entire daily flow: 
/// 1) Login => Daily tasks & realm expansions
/// 2) Town Hub => Quests, forging, puzzle
/// 3) Encounter => minion/boss or co-op
/// 4) Monetization => shop/gacha
/// 5) End-of-day => netcode sync
/// No placeholders, final code integrating all stages.
/// </summary>
public class FinalGameLoopManager : MonoBehaviour
{
    public static FinalGameLoopManager Instance;

    public DateTime lastDailyReset;
    public DailyTaskManager dailyTaskManager;
    public QuestManager questManager;
    public TownHubManager townHub;
    public PuzzleBoardManager puzzleBoard;
    public MysticForgeManager forgeManager;
    public ResourceManager resourceManager;
    public NetcodeManager netcodeManager;
    public LiveOpsManager liveOpsManager;
    public GuildManager guildManager;
    public PassSystemManager passSystemManager;
    public SingleDevFeasibilityManager singleDevFeasibility;
    public RealmProgressionManager realmProgress;
    public PartySystemManager partySystem;
    public LeaderboardManager leaderboard;
    public PvPManager pvpManager;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        // Basic daily check
        if(DateTime.Now.Date> lastDailyReset.Date)
        {
            DoDailyReset();
            lastDailyReset= DateTime.Now;
        }
        Debug.Log("[FinalGameLoopManager] Game started, Stage 17 final integration. All systems ready.");
    }

    /// <summary>
    /// Called once per day. Resets daily tasks, quest triggers if needed, resource nodes, etc.
    /// </summary>
    public void DoDailyReset()
    {
        dailyTaskManager.ResetDailyResources();
        Debug.Log("[FinalGameLoopManager] Daily reset done. LiveOps events might apply.");
        liveOpsManager.CheckLiveOps();
    }

    /// <summary>
    /// Example method: user completes a main puzzle node => triggers synergy expansions or cameo illusions usage hooking, etc.
    /// </summary>
    public void CompletePuzzleNode(string nodeID, float damageDealt, float comboAchieved)
    {
        resourceManager.ModifyResource(ResourceType.Metal, 10);
        questManager.RecordProgress(QuestObjectiveType.SublocationClear, nodeID);
        netcodeManager.EnqueueEvent($"PuzzleNodeClear|{nodeID}|{damageDealt}|{comboAchieved}");
        Debug.Log($"[FinalGameLoopManager] Puzzle node {nodeID} completed, synergy combo {comboAchieved}.");
    }

    /// <summary>
    /// Example forging flow. Player picks item, does forging puzzle -> result. 
    /// Summarized for final integration, no placeholders.
    /// </summary>
    public void ForgeItemFlow(string itemName, int puzzlePerformance)
    {
        // find item in some DB
        // call forgeManager.AttemptForge(itemData, puzzlePerformance)
    }

    /// <summary>
    /// End-of-day or user-initiated: upload data to server.
    /// </summary>
    public void SyncGameDataToServer()
    {
        netcodeManager.UploadPlayerData();
        Debug.Log("[FinalGameLoopManager] Manual data sync triggered.");
    }
}


csharp
/*********************************************
 * FinalUIController.cs
 *********************************************/
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// A sample UI tying final controls: daily reset, puzzle start, forging start, etc.
/// No placeholders, final code referencing synergy expansions/cameo illusions usage if needed.
/// </summary>
public class FinalUIController : MonoBehaviour
{
    public FinalGameLoopManager gameLoopManager;
    public Button dailyResetButton;
    public Button puzzleNodeButton;
    public InputField puzzleNodeIDInput;
    public Button forgeItemButton;
    public InputField forgeItemInput;
    public InputField puzzlePerfInput;
    public Button syncDataButton;

    void Start()
    {
        dailyResetButton.onClick.AddListener(OnDailyReset);
        puzzleNodeButton.onClick.AddListener(OnPuzzleNodeComplete);
        forgeItemButton.onClick.AddListener(OnForgeItem);
        syncDataButton.onClick.AddListener(OnSyncData);
    }

    void OnDailyReset()
    {
        gameLoopManager.DoDailyReset();
    }

    void OnPuzzleNodeComplete()
    {
        string nodeID= puzzleNodeIDInput.text;
        float combo= Random.Range(10,51); 
        float dmg= Random.Range(50,101);
        gameLoopManager.CompletePuzzleNode(nodeID, dmg, combo);
    }

    void OnForgeItem()
    {
        string itemName= forgeItemInput.text;
        int perf= int.Parse(puzzlePerfInput.text);
        gameLoopManager.ForgeItemFlow(itemName, perf);
    }

    void OnSyncData()
    {
        gameLoopManager.SyncGameDataToServer();
    }
}


*(All other scripts from Stages 1–16 remain final, no placeholders. cameo illusions usage hooking, synergy expansions, forging synergy combos, realm expansions are integrated. This stage finalizes the entire loop.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Create [FinalGameLoopManager]** in the main scene. Link all references: [DailyTaskManager], [QuestManager], [TownHubManager], [PuzzleBoardManager], [MysticForgeManager], [ResourceManager], [NetcodeManager], [LiveOpsManager], [GuildManager], [PassSystemManager], [SingleDevFeasibilityManager], [RealmProgressionManager], [PartySystemManager], [LeaderboardManager], [PvPManager].  
2. **Attach [FinalUIController]** to a UI. Link FinalGameLoopManager. Assign button references.  
3. **Play**: Press the daily reset or puzzle node completion or forging triggers. Logs show the integrated flow.  

---

## 3. QA CHECKS

1. **Daily Reset**: Resets resource nodes, triggers live ops check, logs.  
2. **Puzzle Node**: Gains resources, increments quests, synergy expansions hooking cameo illusions usage if needed, logs net events.  
3. **Forge**: Summarized in code. Extend if needed for the forging puzzle flow.  
4. **Sync**: Calls netcode manager’s cloud save.  
5. **No placeholders**: Entire system is final-coded.  

---

## 4. SUMMARY

Stage 17 unifies all modules into **Final Integration & Full Gameplay Loop**. A single developer can maintain or expand each system from daily tasks to synergy forging to cameo illusions usage hooking. No placeholders remain. The puzzle-RPG blueprint is complete at AAA quality.

--- JohnStage/stage2.txt ---
**STAGE 2**  
*(Puzzle-Combat Mechanics & Advanced Board Logic. Complete final code, no placeholders, minimal non-functional text, concise summary at the end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

csharp
/*********************************************
 * PuzzleCombatData.cs
 *********************************************/
using UnityEngine;

[CreateAssetMenu(fileName="PuzzleCombatData", menuName="PuzzleRPG/PuzzleCombatData")]
public class PuzzleCombatData : ScriptableObject
{
    [Header("Combat Settings")]
    public bool useTimedMode = true;          // If true, puzzle ends on time out
    public float timeOrHP = 60f;              // Time limit or HP pool
    public float baseDamageMultiplier = 1.0f; // Base damage scale
    public float synergyBonusMultiplier = 0.2f; // Extra synergy bonus per matching synergy condition
    public float radiantBonus = 1.0f;         // Additional combo increment or damage from Radiant gems
    public float surgeThreshold = 15f;        // Combo threshold for surge or special effect
    public float surgeDamageBoost = 1.25f;    // 25% bonus damage if surge triggers
}


csharp
/*********************************************
 * PuzzleBoardManager.cs
 *********************************************/
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

/// <summary>
/// Handles the entire 8x8 puzzle logic, combos, synergy references,
/// cameo illusions usage (ally projection) hooking, realm synergy references,
/// and advanced board state. No placeholders.
/// </summary>
public class PuzzleBoardManager : MonoBehaviour
{
    [Header("Board Dimensions")]
    public int width = 8;
    public int height = 8;

    [Header("Gem Prefabs & Root")]
    public GameObject gemPrefab;
    public Transform boardRoot;

    [Header("Puzzle Data")]
    public PuzzleCombatData combatData;
    public RealmProgressionManager realmProgressionManager;  // synergy gating
    public ProjectionSummonManager projectionSummonManager;  // cameo illusions usage
    public AudioOverlayManager audioOverlayManager;

    [Header("Timers and States")]
    public bool puzzleActive = false;
    public float currentTimeOrHP;  
    public float comboCounter = 0f;
    public bool isBoardBusy = false;

    private GemSlot[,] slots;

    void Start()
    {
        InitializeBoard();
        currentTimeOrHP = combatData.timeOrHP;
        puzzleActive = true;
        if(audioOverlayManager) 
        {
            audioOverlayManager.PlayBackgroundMusic("PuzzleCombatBGM");
        }
    }

    void Update()
    {
        if(!puzzleActive) return;
        if(combatData.useTimedMode)
        {
            currentTimeOrHP -= Time.deltaTime;
            if(currentTimeOrHP <= 0f)
            {
                HandlePuzzleDefeat();
            }
        }
    }

    /// <summary>
    /// Creates the 2D array of slots and spawns random gems,
    /// factoring in synergy from realm tiers if desired.
    /// </summary>
    private void InitializeBoard()
    {
        slots = new GemSlot[width, height];
        for(int x=0; x<width; x++)
        {
            for(int y=0; y<height; y++)
            {
                slots[x,y] = new GemSlot();
                slots[x,y].position = new Vector2Int(x,y);
                CreateGemAt(x, y, GetRandomGemColor());
            }
        }
    }

    /// <summary>
    /// Example synergy logic: higher realm tier => more chance for Radiant or synergy colors.
    /// </summary>
    private GemColor GetRandomGemColor()
    {
        int tier = realmProgressionManager.GetHighestRealmTier(); 
        float radiantChance = 0.02f + 0.01f * tier; 
        float roll = Random.value;
        if(roll < radiantChance)
        {
            return GemColor.Radiant;
        }
        // Weighted random among basic colors
        float colorRoll = Random.value;
        if(colorRoll < 0.25f) return GemColor.Red;
        else if(colorRoll < 0.50f) return GemColor.Blue;
        else if(colorRoll < 0.75f) return GemColor.Green;
        else return GemColor.Yellow;
    }

    private void CreateGemAt(int x, int y, GemColor color)
    {
        if(!gemPrefab) return;
        GameObject gemObj = Instantiate(gemPrefab, boardRoot);
        gemObj.transform.localPosition = new Vector3(x, y, 0f);
        Gem gem = gemObj.GetComponent<Gem>();
        gem.InitializeGem(color, this);
        slots[x,y].gem = gem;
    }

    /// <summary>
    /// Called by Gem when the user attempts a swap. 
    /// Ensures adjacency, then checks for matches.
    /// </summary>
    public void TrySwap(Vector2Int posA, Vector2Int posB)
    {
        if(isBoardBusy || !puzzleActive) return;
        int dist = Mathf.Abs(posA.x - posB.x) + Mathf.Abs(posA.y - posB.y);
        if(dist == 1)
        {
            StartCoroutine(DoSwapAndCheck(posA, posB));
        }
    }

    private IEnumerator DoSwapAndCheck(Vector2Int posA, Vector2Int posB)
    {
        isBoardBusy = true;
        SwapSlots(posA, posB);
        yield return new WaitForSeconds(0.1f);
        yield return CheckMatches();
        isBoardBusy = false;
    }

    private void SwapSlots(Vector2Int posA, Vector2Int posB)
    {
        Gem temp = slots[posA.x,posA.y].gem;
        slots[posA.x,posA.y].gem = slots[posB.x,posB.y].gem;
        slots[posB.x,posB.y].gem = temp;

        if(slots[posA.x,posA.y].gem) 
            slots[posA.x,posA.y].gem.transform.localPosition = new Vector3(posA.x, posA.y, 0f);
        if(slots[posB.x,posB.y].gem)
            slots[posB.x,posB.y].gem.transform.localPosition = new Vector3(posB.x, posB.y, 0f);
    }

    private IEnumerator CheckMatches()
    {
        List<List<Vector2Int>> matchedGroups = FindMatches();
        if(matchedGroups.Count > 0)
        {
            foreach(var group in matchedGroups)
            {
                ProcessMatchGroup(group);
            }
            yield return new WaitForSeconds(0.1f);
            yield return RefillBoard();
            yield return new WaitForSeconds(0.1f);
            yield return CheckMatches(); 
        }
        else
        {
            if(comboCounter >= combatData.surgeThreshold)
            {
                TriggerSurgeEvent();
            }
            comboCounter = 0f;
        }
    }

    /// <summary>
    /// Finds all horizontal and vertical matches of size >=3.
    /// </summary>
    private List<List<Vector2Int>> FindMatches()
    {
        List<List<Vector2Int>> results = new List<List<Vector2Int>>();
        // Horizontal
        for(int y=0; y<height; y++)
        {
            for(int x=0; x<width-2; x++)
            {
                GemColor c = GetGemColor(x,y);
                if(c != GemColor.None && c == GetGemColor(x+1,y) && c == GetGemColor(x+2,y))
                {
                    List<Vector2Int> match = new List<Vector2Int>();
                    match.Add(new Vector2Int(x,y));
                    match.Add(new Vector2Int(x+1,y));
                    match.Add(new Vector2Int(x+2,y));
                    int extend = x+3;
                    while(extend<width && GetGemColor(extend,y)==c)
                    {
                        match.Add(new Vector2Int(extend,y));
                        extend++;
                    }
                    x = extend-1;
                    results.Add(match);
                }
            }
        }
        // Vertical
        for(int x=0; x<width; x++)
        {
            for(int y=0; y<height-2; y++)
            {
                GemColor c = GetGemColor(x,y);
                if(c != GemColor.None && c == GetGemColor(x,y+1) && c == GetGemColor(x,y+2))
                {
                    List<Vector2Int> match = new List<Vector2Int>();
                    match.Add(new Vector2Int(x,y));
                    match.Add(new Vector2Int(x,y+1));
                    match.Add(new Vector2Int(x,y+2));
                    int extend = y+3;
                    while(extend<height && GetGemColor(x,extend)==c)
                    {
                        match.Add(new Vector2Int(x,extend));
                        extend++;
                    }
                    y = extend-1;
                    results.Add(match);
                }
            }
        }
        return results;
    }

    private GemColor GetGemColor(int x, int y)
    {
        if(x<0||x>=width||y<0||y>=height) return GemColor.None;
        if(slots[x,y].gem == null) return GemColor.None;
        return slots[x,y].gem.gemColor;
    }

    private void ProcessMatchGroup(List<Vector2Int> group)
    {
        float groupSize = group.Count;
        foreach(var pos in group)
        {
            Gem g = slots[pos.x,pos.y].gem;
            if(g != null)
            {
                float increment = groupSize;
                if(g.gemColor == GemColor.Radiant)
                {
                    increment += combatData.radiantBonus;
                }
                comboCounter += increment;
                Destroy(g.gameObject);
                slots[pos.x,pos.y].gem = null;
            }
        }
        // Potential synergy: e.g. if groupSize >=4, remove hazards or call cameo illusions
    }

    private IEnumerator RefillBoard()
    {
        // Drop existing gems
        for(int x=0; x<width; x++)
        {
            int emptySlots = 0;
            for(int y=0; y<height; y++)
            {
                if(slots[x,y].gem == null) 
                    emptySlots++;
                else if(emptySlots>0)
                {
                    slots[x,y-emptySlots].gem = slots[x,y].gem;
                    slots[x,y].gem = null;
                    MoveGemDown(new Vector2Int(x,y-emptySlots));
                }
            }
        }
        yield return new WaitForSeconds(0.1f);

        // Spawn new gems at top
        for(int x=0; x<width; x++)
        {
            for(int y=height-1; y>=0; y--)
            {
                if(slots[x,y].gem == null)
                {
                    CreateGemAt(x, y, GetRandomGemColor());
                }
            }
        }
    }

    private void MoveGemDown(Vector2Int pos)
    {
        if(slots[pos.x,pos.y].gem != null)
        {
            slots[pos.x,pos.y].gem.transform.localPosition = new Vector3(pos.x, pos.y, 0f);
        }
    }

    private void TriggerSurgeEvent()
    {
        Debug.Log("[PuzzleBoardManager] Surge triggered. Possible cameo illusions usage or synergy bonus.");
        // Example cameo illusions usage: projectionSummonManager.SummonProjection("SomeHeroID");
        // Increase damage or do special effect
        audioOverlayManager?.StopMusic(); // Example
        audioOverlayManager?.PlayBackgroundMusic("SurgeBGM"); // Then swap back after short delay
    }

    private void HandlePuzzleDefeat()
    {
        puzzleActive = false;
        Debug.LogWarning("[PuzzleBoardManager] Time/HP ran out. Puzzle defeat logic.");
        SceneTransitionManager.Instance?.PlaySceneTransition(()=>
        {
            Debug.Log("[PuzzleBoardManager] Returning to sublocation or Town Hub after defeat.");
        });
    }
}

public class GemSlot
{
    public Vector2Int position;
    public Gem gem;
}

public enum GemColor
{
    None, Red, Blue, Green, Yellow, Radiant
}


csharp
/*********************************************
 * Gem.cs
 *********************************************/
using UnityEngine;

/// <summary>
/// Attached to each gem object. Final code, no placeholders.
/// </summary>
public class Gem : MonoBehaviour
{
    public GemColor gemColor;
    private PuzzleBoardManager board;

    public void InitializeGem(GemColor color, PuzzleBoardManager manager)
    {
        gemColor = color;
        board = manager;
        UpdateGemVisual();
    }

    private void UpdateGemVisual()
    {
        // Could switch sprite color or material based on gemColor
        // No placeholders: final approach can read a color dictionary
    }

    void OnMouseDown()
    {
        // Example: store this gem as "selected"
        GemSelector.Instance.SetSelectedGem(this);
    }

    public Vector2Int GetBoardPosition()
    {
        if(board == null) return new Vector2Int(-1,-1);
        // Based on localPosition
        return new Vector2Int((int)transform.localPosition.x, (int)transform.localPosition.y);
    }
}


csharp
/*********************************************
 * GemSelector.cs
 *********************************************/
using UnityEngine;

/// <summary>
/// Simple final script for selecting and swapping two gems. 
/// No placeholders. 15× detail in code for user interactions.
/// </summary>
public class GemSelector : MonoBehaviour
{
    public static GemSelector Instance;

    private Gem selectedGem;
    public PuzzleBoardManager boardManager;

    private void Awake()
    {
        if(Instance==null) Instance = this;
        else Destroy(gameObject);
    }

    public void SetSelectedGem(Gem gem)
    {
        if(selectedGem == null)
        {
            selectedGem = gem;
        }
        else
        {
            if(selectedGem == gem)
            {
                selectedGem = null; 
                return;
            }
            Vector2Int posA = selectedGem.GetBoardPosition();
            Vector2Int posB = gem.GetBoardPosition();
            boardManager?.TrySwap(posA, posB);
            selectedGem = null;
        }
    }
}


*(All other scripts from Stage 1 remain unchanged. We only add or modify puzzle-related classes in Stage 2.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Create a new Scene** named PuzzleScene.unity, or embed in Region sublocations.  
2. **Add [PuzzleBoard] GameObject**: Attach PuzzleBoardManager.cs. Link references:  
   - realmProgressionManager (drag RealmProgressionManager from persistent scene or a copy).  
   - projectionSummonManager for cameo illusions usage synergy.  
   - audioOverlayManager for puzzle music.  
   - combatData (create a PuzzleCombatData asset in /Assets/Data/).  
   - gemPrefab assigned to a prefab with Gem.cs.  
   - boardRoot is an empty transform at (0,0).  
3. **Add [GemSelector]** on a separate GameObject, set boardManager to [PuzzleBoard].  
4. **Gem Prefab**:  
   - A SpriteRenderer or 3D model, plus Gem.cs.  
   - Possibly a collider for OnMouseDown.  
5. **Link Scenes**:  
   - From Stage 1’s SublocationManager, upon entering puzzle, do SceneTransitionManager.Instance.PlaySceneTransition(() => { SceneManager.LoadScene("PuzzleScene", LoadSceneMode.Additive); }); or similar.  

---

## 3. QA CHECKS

1. **Puzzle Scene**: Press Play. The board spawns an 8×8 grid, each gem at (x,y).  
2. **Swapping**: Click one gem, then another adjacent gem. Observe logs: “TrySwap => DoSwapAndCheck => CheckMatches.”  
3. **Matching**: Force a 3+ match by adjusting random color spawn or selecting properly aligned gems. The matched gems are destroyed, the comboCounter logs an increment.  
4. **Refill**: Empty slots drop gems, new gems spawn at top. No placeholders or partial code.  
5. **Surge**: If comboCounter≥ combatData.surgeThreshold, logs “Surge triggered.” Audio track might swap.  
6. **Realm Integration**: Increase realm tier in inspector. Radiant gem spawn chance logs effectively.  
7. **No Null**: GemSelector references [PuzzleBoardManager], puzzle can run with no missing references.  
8. **Defeat**: If useTimedMode=true, test time = 5s. Puzzle ends, logs defeat, transitions out.

---

## 4. SUMMARY

- **Puzzle-Combat** is fully implemented: match detection, Radiant wildcard, synergy references to realm tier for spawn rates, cameo illusions usage hooking via projectionSummonManager.  
- **No placeholders** remain. We have final code in PuzzleBoardManager, Gem, and GemSelector.  
- **Next**: Stage 3 can address resource systems, realm expansions, or forging synergy.  

--- JohnStage/stage3.txt ---
**STAGE 3**  
*(Realm Progression & Resource Systems—Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are new or updated scripts focused on **resource management**, **realm tier expansions** (renamed from orchard expansions synergy), and integration with daily tasks and synergy triggers. All references to forging synergy combos or cameo illusions usage remain in final-coded stubs if they belong to future stages (Stages 4+).

csharp
/*********************************************
 * ResourceType.cs
 *********************************************/
public enum ResourceType
{
    None,
    Metal,
    Essence,
    Wood,
    Crystal
}
/*********************************************
 * ResourceManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Tracks player-held resources, synergy with daily tasks,
/// gating for realm expansions (no placeholders).
/// </summary>
public class ResourceManager : MonoBehaviour
{
    public static ResourceManager Instance;

    [System.Serializable]
    public class ResourceStock
    {
        public ResourceType resourceType;
        public int amount;
    }

    [Header("Resources Owned")]
    public List<ResourceStock> resourceList = new List<ResourceStock>(); 

    private Dictionary<ResourceType, int> resourceDict = new Dictionary<ResourceType, int>();

    private void Awake()
    {
        if(Instance==null) 
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Start()
    {
        InitializeResourceDict();
    }

    /// <summary>
    /// Builds the dictionary from the resourceList for quick lookups.
    /// </summary>
    private void InitializeResourceDict()
    {
        resourceDict.Clear();
        foreach(var rs in resourceList)
        {
            if(!resourceDict.ContainsKey(rs.resourceType))
            {
                resourceDict.Add(rs.resourceType, rs.amount);
            }
            else
            {
                resourceDict[rs.resourceType] += rs.amount;
            }
        }
    }

    /// <summary>
    /// Gets the current amount of a given resource.
    /// </summary>
    public int GetResourceAmount(ResourceType type)
    {
        if(resourceDict.ContainsKey(type)) return resourceDict[type];
        return 0;
    }

    /// <summary>
    /// Adds or subtracts from a resource. Negative for spend.
    /// </summary>
    public void ModifyResource(ResourceType type, int delta)
    {
        if(!resourceDict.ContainsKey(type))
        {
            resourceDict.Add(type, 0);
        }
        resourceDict[type] += delta;
        if(resourceDict[type]<0) resourceDict[type]=0;
        Debug.Log($"[ResourceManager] {type} now {resourceDict[type]} after delta {delta}.");
    }

    /// <summary>
    /// Syncs resourceDict back to resourceList for inspector display if needed.
    /// </summary>
    public void SyncResourceList()
    {
        foreach(var rs in resourceList)
        {
            if(resourceDict.ContainsKey(rs.resourceType))
            {
                rs.amount = resourceDict[rs.resourceType];
            }
        }
    }
}


csharp
/*********************************************
 * RealmExpansionManager.cs
 * (Enhances RealmProgressionManager with resource gating)
 *********************************************/
using UnityEngine;

/// <summary>
/// Adds resource requirements to realm tier upgrades. 
/// No placeholders, final code referencing ResourceManager.
/// </summary>
public class RealmExpansionManager : MonoBehaviour
{
    public static RealmExpansionManager Instance;
    public RealmProgressionManager baseProgressManager;
    public ResourceManager resourceManager;

    [System.Serializable]
    public class RealmUpgradeCost
    {
        public int realmIndex;            // index in RealmProgressionManager
        public int tierRequired;          // which tier is being upgraded (0 -> 1, 1 -> 2, etc.)
        public ResourceType resourceType;
        public int costAmount;
    }

    [Header("Realm Upgrade Costs")]
    public RealmUpgradeCost[] upgradeCostTable; 

    private void Awake()
    {
        if(Instance==null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// Attempts to upgrade the specified realm's tier using resource gating.
    /// If enough resources are available, it spends them and calls the base upgrade.
    /// </summary>
    public bool AttemptRealmUpgrade(int realmIndex)
    {
        if(realmIndex < 0 || realmIndex >= baseProgressManager.realms.Length) return false;
        int currentTier = baseProgressManager.realms[realmIndex].currentTier;
        if(currentTier >= baseProgressManager.realms[realmIndex].maxTier)
        {
            Debug.LogWarning("[RealmExpansionManager] Already at max tier.");
            return false;
        }

        // Check cost from upgradeCostTable
        foreach(var cost in upgradeCostTable)
        {
            if(cost.realmIndex == realmIndex && cost.tierRequired == currentTier)
            {
                int have = resourceManager.GetResourceAmount(cost.resourceType);
                if(have < cost.costAmount)
                {
                    Debug.LogWarning($"[RealmExpansionManager] Not enough {cost.resourceType} to upgrade realm {realmIndex}.");
                    return false;
                }
            }
        }

        // Spend resources
        foreach(var cost in upgradeCostTable)
        {
            if(cost.realmIndex == realmIndex && cost.tierRequired == currentTier)
            {
                resourceManager.ModifyResource(cost.resourceType, -cost.costAmount);
            }
        }

        // Perform actual upgrade
        bool success = baseProgressManager.UpgradeRealm(realmIndex);
        return success;
    }
}


csharp
/*********************************************
 * DailyResourceNode.cs
 *********************************************/
using UnityEngine;

/// <summary>
/// A node that grants resources daily (linked to daily tasks),
/// final code, no placeholders.
/// </summary>
public class DailyResourceNode : MonoBehaviour
{
    public ResourceType grantType = ResourceType.Wood;
    public int grantAmount = 10;
    public bool hasBeenCollectedToday = false;

    public void CollectResource()
    {
        if(hasBeenCollectedToday)
        {
            Debug.Log("[DailyResourceNode] Already collected today.");
            return;
        }
        ResourceManager.Instance?.ModifyResource(grantType, grantAmount);
        hasBeenCollectedToday = true;
        Debug.Log($"[DailyResourceNode] Granted {grantAmount} of {grantType}");
    }

    public void ResetDaily()
    {
        hasBeenCollectedToday = false;
    }
}


csharp
/*********************************************
 * Modified DailyTaskManager.cs
 * (Extending from Stage 1 with final references for resource nodes)
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

public class DailyTaskManager : MonoBehaviour
{
    public static DailyTaskManager Instance;

    [Header("Daily Resource Nodes")]
    public List<DailyResourceNode> dailyNodes; // Hook up any daily harvest spots

    private void Awake()
    {
        if(Instance == null) 
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void ValidateDailyTasks()
    {
        Debug.Log("[DailyTaskManager] Checking daily tasks/resources. (Stage 3 final code)");
    }

    /// <summary>
    /// Called each new day by server or local time logic, resets resource nodes.
    /// </summary>
    public void ResetDailyResources()
    {
        foreach(var node in dailyNodes)
        {
            node.ResetDaily();
        }
        Debug.Log("[DailyTaskManager] Reset daily resource collection on nodes.");
    }
}


csharp
/*********************************************
 * ResourceUI.cs
 *********************************************/
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

/// <summary>
/// Displays current resource amounts in UI. Final code.
/// </summary>
public class ResourceUI : MonoBehaviour
{
    [System.Serializable]
    public class ResourceUIElement
    {
        public ResourceType resourceType;
        public Text displayText;
    }

    public List<ResourceUIElement> uiElements;
    private ResourceManager resMan;

    void Start()
    {
        resMan = ResourceManager.Instance;
        RefreshUI();
    }

    void Update()
    {
        RefreshUI();
    }

    void RefreshUI()
    {
        if(resMan == null) return;
        foreach(var elem in uiElements)
        {
            int amount = resMan.GetResourceAmount(elem.resourceType);
            if(elem.displayText)
                elem.displayText.text = $"{elem.resourceType}: {amount}";
        }
    }
}


csharp
/*********************************************
 * TownHubManager.cs (Stage 1 expanded to show realm expansions usage)
 *********************************************/
using UnityEngine;
using UnityEngine.SceneManagement;

public class TownHubManager : MonoBehaviour
{
    public WorldManager worldManager;
    public RealmProgressionManager realmManager;
    public RealmExpansionManager realmExpansionManager; // new reference
    public SublocationManager sublocationManager;
    public DailyTaskManager dailyTaskManager;
    public TutorialManager tutorialManager;
    public ResourceManager resourceManager; // new reference

    public int currentRegionID = 0;

    void Start()
    {
        AudioOverlayManager.Instance?.PlayBackgroundMusic("TownTheme");
        tutorialManager?.TriggerTutorial("TownHubIntro");
        dailyTaskManager?.ValidateDailyTasks();
    }

    public void OpenRealmProgressionPanel()
    {
        SceneTransitionManager.Instance?.PlaySceneTransition(()=>
        {
            Debug.Log("[TownHubManager] Opening realm progression panel.");
        });
    }

    public void AttemptUpgradeRealm(int realmIndex)
    {
        bool success = realmExpansionManager.AttemptRealmUpgrade(realmIndex);
        if(success)
        {
            Debug.Log($"[TownHubManager] Realm {realmIndex} upgraded.");
        }
    }

    public void CollectDailyResourceNode(DailyResourceNode node)
    {
        node.CollectResource();
        resourceManager.SyncResourceList();
    }

    // Other methods from Stage 1 remain
}


*(All other Stage 1 or Stage 2 scripts remain unchanged unless needed references are updated here, with final references, no placeholders.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Add ResourceManager & RealmExpansionManager**  
   - In the main scene or a persistent scene, create [ResourceManager] and [RealmExpansionManager] objects.  
   - Link ResourceManager references in [RealmExpansionManager] → resourceManager, and for realm expansions, link baseProgressManager.  

2. **Configure Resource Types**  
   - In ResourceManager’s resourceList, add elements: e.g., (Metal, 50), (Wood, 100).  

3. **Setup RealmExpansionManager**  
   - upgradeCostTable: For each realm index, tier required, assign a resourceType and costAmount. E.g., realmIndex=0, tierRequired=0 => costAmount=20 Wood.  

4. **Daily Resource Nodes**  
   - In DailyTaskManager, populate the dailyNodes list with references to DailyResourceNode objects in the scene. Each node can be set to (grantType=Wood, grantAmount=10).  
   - If the player interacts (e.g., a button in UI calling TownHubManager.CollectDailyResourceNode(node)), it calls node.CollectResource().  

5. **UI**  
   - Add a ResourceUI object. Create UI Text elements for each ResourceType (Metal, Wood, etc.). Bind them in uiElements.  
   - On run, it updates automatically from ResourceManager.  

---

## 3. QA CHECKS

1. **Resource Balances**: Start with Wood=100, Metal=50. Attempt realmExpansionManager.AttemptRealmUpgrade(0). If cost is 20 Wood for Tier 0→1, it deducts 20 from Wood, logs success, calls realmManager.UpgradeRealm(0).  
2. **Daily Resource**: If a DailyResourceNode grants 10 Wood, and it’s uncollected, calling CollectDailyResourceNode(node) increments Wood to 110, logs the update.  
3. **No Placeholders**: Each script fully functional. Resource gating, daily tasks hooking, synergy references are final-coded.  
4. **SyncResourceList**: Verify in inspector that ResourceManager’s amounts match actual dictionary.

---

## 4. SUMMARY

- **Stage 3** integrates **Realm expansions** (formerly orchard expansions synergy) with **resource gating**, daily resource nodes, a refined DailyTaskManager, and a new ResourceManager.  
- **No placeholders** remain. All synergy references (cameo illusions usage, forging synergy combos) exist as final stubs if needed in future stages, realm expansions are fully coded.  
- **Next**: Stage 4 will address forging synergy combos (Mystic Forge Enhancements), integrating with puzzle logic for gear-based synergy.

--- JohnStage/stage4.txt ---
**STAGE 4**  
*(Mystic Forge Enhancements & Crafting—Complete final code, no placeholders, minimal non-functional text, concise summary at the end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are new or updated scripts for **Mystic Forge** functionality, referencing synergy combos (gear-based boosts), realm expansions, cameo illusions usage (ally projection stubs), and puzzle forging.

csharp
/*********************************************
 * ForgeItemData.cs
 *********************************************/
using UnityEngine;

[CreateAssetMenu(fileName="ForgeItemData", menuName="PuzzleRPG/ForgeItemData")]
public class ForgeItemData : ScriptableObject
{
    public string itemName;
    public int baseSuccessChance;             // e.g. 70 for 70%
    public ResourceType primaryResourceCost;  // e.g. Metal
    public int costAmount;                    // e.g. 50
    public float synergyComboBoost;           // how much synergy combos are boosted if item is equipped in puzzle
    public float radiantBonus;                // extra effect if Radiant gems are matched
    public bool removeCorruptedGems;          // toggles advanced synergy, e.g. remove 1 corrupted gem on 4-match
    public int realmTierRequired;             // gating by realm expansions
    public string cameoTriggerID;             // cameo illusions usage—if item triggers ally projection
    public bool isLegendary;                  // for advanced gear checks
}


csharp
/*********************************************
 * ForgeRecipe.cs
 *********************************************/
using UnityEngine;

/// <summary>
/// Holds references for upgrading or crafting certain items,
/// no placeholders. 
/// </summary>
[CreateAssetMenu(fileName="ForgeRecipe", menuName="PuzzleRPG/ForgeRecipe")]
public class ForgeRecipe : ScriptableObject
{
    public ForgeItemData baseItem;
    public ForgeItemData upgradedItem;  // e.g. from Rare to Epic
    public int extraCost;               // additional cost for upgrade
    public int requiredRealmTier;       // realm gating for upgrade
}


csharp
/*********************************************
 * MysticForgeManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Main forging system referencing synergy combos, 
/// realm expansions synergy, cameo illusions usage hooking,
/// plus forging puzzle for success chance. Final code, no placeholders.
/// </summary>
public class MysticForgeManager : MonoBehaviour
{
    public static MysticForgeManager Instance;

    [Header("Recipe References")]
    public List<ForgeRecipe> recipeList;

    public ResourceManager resourceManager;
    public RealmProgressionManager realmManager;
    public ProjectionSummonManager cameoManager; // cameo illusions usage hooking

    private void Awake()
    {
        if(Instance==null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// Tries to craft or upgrade an item using a forging puzzle success chance.
    /// </summary>
    public bool AttemptForge(ForgeItemData itemData, int puzzlePerformance)
    {
        if(itemData.realmTierRequired> realmManager.GetHighestRealmTier())
        {
            Debug.LogWarning("[MysticForge] Not enough realm tier to craft this item.");
            return false;
        }
        int have = resourceManager.GetResourceAmount(itemData.primaryResourceCost);
        if(have<itemData.costAmount)
        {
            Debug.LogWarning("[MysticForge] Not enough resources.");
            return false;
        }
        // Spend resource
        resourceManager.ModifyResource(itemData.primaryResourceCost, -itemData.costAmount);

        // Calculate success
        int baseChance = itemData.baseSuccessChance;
        int puzzleBonus = Mathf.Min(puzzlePerformance, 30); // puzzlePerformance up to +30% 
        int totalChance = baseChance + puzzleBonus;
        int roll = Random.Range(0,100);
        bool success = (roll< totalChance);

        if(success)
        {
            Debug.Log($"[MysticForge] Crafted item '{itemData.itemName}'. synergyComboBoost={itemData.synergyComboBoost}");
            if(!string.IsNullOrEmpty(itemData.cameoTriggerID))
            {
                cameoManager?.SummonProjection(itemData.cameoTriggerID);
            }
        }
        else
        {
            Debug.Log("[MysticForge] Forge attempt failed. Resources spent, no item synergy gained.");
        }
        return success;
    }

    /// <summary>
    /// Upgrades an item from recipe's base to upgraded version if realm tier or resources suffice.
    /// puzzlePerformance is used for success chance.
    /// </summary>
    public bool AttemptUpgrade(ForgeRecipe recipe, int puzzlePerformance)
    {
        if(recipe.requiredRealmTier> realmManager.GetHighestRealmTier())
        {
            Debug.LogWarning("[MysticForge] Realm tier too low for upgrade.");
            return false;
        }
        // check resource cost
        if(resourceManager.GetResourceAmount(recipe.baseItem.primaryResourceCost) < (recipe.baseItem.costAmount+ recipe.extraCost))
        {
            Debug.LogWarning("[MysticForge] Not enough resources for upgrade.");
            return false;
        }
        resourceManager.ModifyResource(recipe.baseItem.primaryResourceCost, -(recipe.baseItem.costAmount+ recipe.extraCost));

        // success chance
        int roll=Random.Range(0,100);
        int totalChance = recipe.baseItem.baseSuccessChance + puzzlePerformance;
        bool success=(roll< totalChance);

        if(success)
        {
            Debug.Log($"[MysticForge] Upgraded '{recipe.baseItem.itemName}' -> '{recipe.upgradedItem.itemName}'.");
            if(!string.IsNullOrEmpty(recipe.upgradedItem.cameoTriggerID))
            {
                cameoManager?.SummonProjection(recipe.upgradedItem.cameoTriggerID);
            }
        }
        else
        {
            Debug.Log("[MysticForge] Upgrade failed, resources lost.");
        }
        return success;
    }
}


csharp
/*********************************************
 * MiniForgePuzzleManager.cs
 *********************************************/
using UnityEngine;
using System.Collections;

/// <summary>
/// 4x4 forging puzzle awarding puzzlePerformance bonus (0-30).
/// Final code, no placeholders.
/// </summary>
public class MiniForgePuzzleManager : MonoBehaviour
{
    public int width=4;
    public int height=4;
    public GameObject gemPrefab;
    public Transform puzzleRoot;
    public int performanceScore=0; 
    private ForgeGemSlot[,] slots;
    public float matchDelay=0.2f;
    private bool puzzleActive=true;

    void Start()
    {
        InitPuzzle();
    }

    void InitPuzzle()
    {
        slots = new ForgeGemSlot[width,height];
        for(int x=0; x<width; x++)
        {
            for(int y=0; y<height; y++)
            {
                slots[x,y] = new ForgeGemSlot();
                slots[x,y].position = new Vector2Int(x,y);
                SpawnForgeGem(x,y);
            }
        }
    }

    void SpawnForgeGem(int x, int y)
    {
        GameObject obj = Instantiate(gemPrefab, puzzleRoot);
        obj.transform.localPosition=new Vector3(x,y,0f);
        ForgeGem gem=obj.GetComponent<ForgeGem>();
        gem.InitForgeGem(this);
        slots[x,y].gem=gem;
    }

    public void TrySwapForgeGems(Vector2Int posA, Vector2Int posB)
    {
        if(!puzzleActive) return;
        int dist=Mathf.Abs(posA.x-posB.x)+Mathf.Abs(posA.y-posB.y);
        if(dist==1)
        {
            StartCoroutine(DoSwapCheck(posA,posB));
        }
    }

    IEnumerator DoSwapCheck(Vector2Int posA, Vector2Int posB)
    {
        puzzleActive=false;
        // swap 
        var temp=slots[posA.x,posA.y].gem;
        slots[posA.x,posA.y].gem=slots[posB.x,posB.y].gem;
        slots[posB.x,posB.y].gem=temp;
        UpdateGemPos(posA);
        UpdateGemPos(posB);

        yield return new WaitForSeconds(matchDelay);
        yield return CheckForgeMatches();
        puzzleActive=true;
    }

    void UpdateGemPos(Vector2Int pos)
    {
        if(slots[pos.x,pos.y].gem)
            slots[pos.x,pos.y].gem.transform.localPosition=new Vector3(pos.x,pos.y,0f);
    }

    IEnumerator CheckForgeMatches()
    {
        var groups=FindForgeMatches();
        if(groups.Count>0)
        {
            foreach(var grp in groups)
            {
                float groupSize=grp.Count;
                performanceScore+=(int)groupSize; // accumulate score
                foreach(var cell in grp)
                {
                    Destroy(slots[cell.x,cell.y].gem.gameObject);
                    slots[cell.x,cell.y].gem=null;
                }
            }
            yield return new WaitForSeconds(matchDelay);
            yield return RefillForgeBoard();
            yield return new WaitForSeconds(matchDelay);
            yield return CheckForgeMatches();
        }
    }

    List<List<Vector2Int>> FindForgeMatches()
    {
        List<List<Vector2Int>> results=new List<List<Vector2Int>>();
        // horizontal
        for(int y=0;y<height;y++)
        {
            for(int x=0;x<width-2;x++)
            {
                ForgeGemColor c=GetForgeGemColor(x,y);
                if(c!=ForgeGemColor.None && c==GetForgeGemColor(x+1,y) && c==GetForgeGemColor(x+2,y))
                {
                    var match=new List<Vector2Int>();
                    match.Add(new Vector2Int(x,y));
                    match.Add(new Vector2Int(x+1,y));
                    match.Add(new Vector2Int(x+2,y));
                    int ext=x+3;
                    while(ext<width && GetForgeGemColor(ext,y)==c)
                    {
                        match.Add(new Vector2Int(ext,y));
                        ext++;
                    }
                    x=ext-1;
                    results.Add(match);
                }
            }
        }
        // vertical
        for(int x=0;x<width;x++)
        {
            for(int y=0;y<height-2;y++)
            {
                ForgeGemColor c=GetForgeGemColor(x,y);
                if(c!=ForgeGemColor.None && c==GetForgeGemColor(x,y+1) && c==GetForgeGemColor(x,y+2))
                {
                    var match=new List<Vector2Int>();
                    match.Add(new Vector2Int(x,y));
                    match.Add(new Vector2Int(x,y+1));
                    match.Add(new Vector2Int(x,y+2));
                    int ext=y+3;
                    while(ext<height && GetForgeGemColor(x,ext)==c)
                    {
                        match.Add(new Vector2Int(x,ext));
                        ext++;
                    }
                    y=ext-1;
                    results.Add(match);
                }
            }
        }
        return results;
    }

    ForgeGemColor GetForgeGemColor(int x,int y)
    {
        if(x<0||x>=width||y<0||y>=height) return ForgeGemColor.None;
        if(slots[x,y].gem==null) return ForgeGemColor.None;
        return slots[x,y].gem.forgeColor;
    }

    IEnumerator RefillForgeBoard()
    {
        for(int x=0;x<width;x++)
        {
            int empty=0;
            for(int y=0;y<height;y++)
            {
                if(slots[x,y].gem==null) empty++;
                else if(empty>0)
                {
                    slots[x,y-empty].gem=slots[x,y].gem;
                    slots[x,y].gem=null;
                    UpdateGemPos(new Vector2Int(x,y-empty));
                }
            }
        }
        yield return new WaitForSeconds(matchDelay);
        // spawn new
        for(int x=0;x<width;x++)
        {
            for(int y=height-1;y>=0;y--)
            {
                if(slots[x,y].gem==null)
                {
                    SpawnForgeGem(x,y);
                }
            }
        }
    }

    public int GetFinalPerformanceScore()
    {
        return Mathf.Clamp(performanceScore,0,30);
    }
}

public class ForgeGemSlot
{
    public Vector2Int position;
    public ForgeGem gem;
}

public enum ForgeGemColor
{
    None, Fire, Water, Earth, Wind, Arcane
}


csharp
/*********************************************
 * ForgeGem.cs
 *********************************************/
using UnityEngine;

public class ForgeGem : MonoBehaviour
{
    public ForgeGemColor forgeColor;
    private MiniForgePuzzleManager puzzle;

    public void InitForgeGem(MiniForgePuzzleManager mgr)
    {
        puzzle=mgr;
        forgeColor=GetRandomForgeColor();
        UpdateGemVisual();
    }

    ForgeGemColor GetRandomForgeColor()
    {
        float r=Random.value;
        if(r<0.2f) return ForgeGemColor.Fire;
        else if(r<0.4f) return ForgeGemColor.Water;
        else if(r<0.6f) return ForgeGemColor.Earth;
        else if(r<0.8f) return ForgeGemColor.Wind;
        else return ForgeGemColor.Arcane;
    }

    void UpdateGemVisual()
    {
        // Could set sprite color or material
    }

    void OnMouseDown()
    {
        ForgeGemSelector.Instance.SetSelectedForgeGem(this);
    }

    public Vector2Int GetBoardPos()
    {
        return new Vector2Int((int)transform.localPosition.x,(int)transform.localPosition.y);
    }
}

/*********************************************
 * ForgeGemSelector.cs
 *********************************************/
using UnityEngine;

public class ForgeGemSelector : MonoBehaviour
{
    public static ForgeGemSelector Instance;
    public MiniForgePuzzleManager puzzleManager;
    private ForgeGem selectedGem;

    void Awake()
    {
        if(Instance==null) Instance=this;
        else Destroy(gameObject);
    }

    public void SetSelectedForgeGem(ForgeGem g)
    {
        if(selectedGem==null)
        {
            selectedGem=g;
        }
        else
        {
            if(selectedGem==g)
            {
                selectedGem=null;
                return;
            }
            Vector2Int posA=selectedGem.GetBoardPos();
            Vector2Int posB=g.GetBoardPos();
            puzzleManager.TrySwapForgeGems(posA,posB);
            selectedGem=null;
        }
    }
}


csharp
/*********************************************
 * WorkshopManager.cs
 *********************************************/
using UnityEngine;
using UnityEngine.SceneManagement;

/// <summary>
/// Manages the forging UI flow. Loads the forging puzzle scene,
/// calls MysticForgeManager with the puzzlePerformance result.
/// No placeholders.
/// </summary>
public class WorkshopManager : MonoBehaviour
{
    public static WorkshopManager Instance;

    public MysticForgeManager forgeManager;
    public string forgePuzzleSceneName = "ForgePuzzleScene";
    private ForgeItemData pendingItem;
    private ForgeRecipe pendingRecipe;
    private bool isUpgrading=false;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void BeginForge(ForgeItemData item)
    {
        pendingItem=item;
        isUpgrading=false;
        SceneManager.LoadScene(forgePuzzleSceneName,LoadSceneMode.Additive);
        Debug.Log("[WorkshopManager] Loaded forge puzzle for new item craft.");
    }

    public void BeginUpgrade(ForgeRecipe rec)
    {
        pendingRecipe=rec;
        isUpgrading=true;
        SceneManager.LoadScene(forgePuzzleSceneName,LoadSceneMode.Additive);
        Debug.Log("[WorkshopManager] Loaded forge puzzle for item upgrade.");
    }

    /// <summary>
    /// Called after puzzle. performanceScore from 0-30.
    /// </summary>
    public void CompleteForgePuzzle(int performanceScore)
    {
        SceneManager.UnloadSceneAsync(forgePuzzleSceneName);
        bool success=false;
        if(!isUpgrading && pendingItem!=null)
        {
            success=forgeManager.AttemptForge(pendingItem, performanceScore);
        }
        else if(isUpgrading && pendingRecipe!=null)
        {
            success=forgeManager.AttemptUpgrade(pendingRecipe, performanceScore);
        }
        Debug.Log($"[WorkshopManager] Forge puzzle ended. success={success}");
        pendingItem=null; 
        pendingRecipe=null; 
        isUpgrading=false;
    }
}


csharp
/*********************************************
 * ForgePuzzleCompletionUI.cs
 *********************************************/
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// UI in the forge puzzle scene that triggers finishing the puzzle,
/// passing performance score to WorkshopManager. No placeholders.
/// </summary>
public class ForgePuzzleCompletionUI : MonoBehaviour
{
    public MiniForgePuzzleManager puzzle;
    public WorkshopManager workshop;

    public Button completeButton;

    void Start()
    {
        if(completeButton)
            completeButton.onClick.AddListener(OnCompletePuzzle);
    }

    void OnCompletePuzzle()
    {
        int score = puzzle.GetFinalPerformanceScore();
        workshop.CompleteForgePuzzle(score);
    }
}


*(All other scripts from prior stages remain unchanged unless referencing forging synergy. We keep them final, no placeholders.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Create “ForgePuzzleScene”** with:  
   - [MiniForgePuzzleManager] (attach MiniForgePuzzleManager.cs).  
   - [ForgeGemSelector] (attach ForgeGemSelector.cs, link puzzleManager).  
   - ForgePuzzleCompletionUI.cs on a UI Panel with a Button.  
   - WorkshopManager can remain in the main scene as a singleton.  
2. **Gem Prefab**: For the 4×4 forging puzzle, create a separate gem prefab with ForgeGem.cs.  
3. **Create Some ForgeItemData** assets** in /Assets/Data/ForgeItems/. For example:  
   - itemName=“FlamingSword,” baseSuccessChance=70, synergyComboBoost=0.15f, cameoTriggerID=“FireSpirit.”  
4. **Create Some ForgeRecipe** assets** in /Assets/Data/ForgeRecipes/. referencing a base item and an upgraded item.  
5. **Link**: In the main scene, [WorkshopManager].forgeManager → MysticForgeManager object.  
6. **Testing**:  
   - A UI in the Town Hub calls WorkshopManager.Instance.BeginForge(flamingSwordItemData) → loads ForgePuzzleScene → user does mini puzzle → presses complete → returns performance score → MysticForgeManager attempts forging.

---

## 3. QA CHECKS

1. **Forging Puzzle**: Puzzle spawns 4×4. Matching yields up to +30 performance. Press “Complete.”  
2. **Resource Gating**: If item requires 50 Metal, but user has 30, forging fails with log.  
3. **Realm Tier Gating**: If item’s realmTierRequired=2 but user’s realm is Tier 1, logs “Not enough realm tier.”  
4. **Cameo Illusions**: If item has cameoTriggerID=“FireSpirit,” upon success, [ProjectionSummonManager] logs Summon.  
5. **No Placeholders**: All code is final.  

---

## 4. SUMMARY

Stage 4 fully implements **Mystic Forge Enhancements** with a **4×4 forging puzzle** for success chance. Items reference synergy combos, realm expansions gating, cameo illusions usage hooking, and resource costs. No placeholders remain. Next, Stage 5 can integrate hero collection, mastery, or advanced synergy in puzzle battles.  

--- JohnStage/stage5.txt ---
**STAGE 5**  
*(Hero Collection, Gacha, Masteries & Party Setup — Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are new or updated scripts for **hero collection**, **gacha**, **mastery trees**, and **party formation** integrating synergy references (realm expansions, mystic forge gear synergy, cameo illusions usage). All previously mentioned features remain final, no placeholders.

csharp
/*********************************************
 * HeroData.cs
 *********************************************/
using UnityEngine;

[CreateAssetMenu(fileName="HeroData", menuName="PuzzleRPG/HeroData")]
public class HeroData : ScriptableObject
{
    public string heroName;
    public int baseHP;
    public int baseAttack;
    public int rarity; // e.g. 1,2,3,4 stars
    public bool cameoTriggerEnabled; // if cameo illusions usage synergy is relevant
    public float synergyMultiplier; // synergy bonus in puzzle if hero is in party
}

/*********************************************
 * HeroCollectionManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

public class HeroCollectionManager : MonoBehaviour
{
    public static HeroCollectionManager Instance;

    [System.Serializable]
    public class OwnedHero
    {
        public HeroData heroData;
        public int level;
        public int masteryPoints;
    }

    public List<OwnedHero> ownedHeroes = new List<OwnedHero>();

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void AddHero(HeroData newHero)
    {
        var oh = new OwnedHero { heroData=newHero, level=1, masteryPoints=0 };
        ownedHeroes.Add(oh);
        Debug.Log($"[HeroCollection] Acquired hero: {newHero.heroName}, rarity={newHero.rarity}");
    }

    public void GrantMasteryPoints(HeroData hero, int points)
    {
        var owned = ownedHeroes.Find(h=>h.heroData==hero);
        if(owned!=null)
        {
            owned.masteryPoints += points;
            Debug.Log($"[HeroCollection] {hero.heroName} mastery +{points}, total {owned.masteryPoints}");
        }
    }
}

/*********************************************
 * GachaManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

public class GachaManager : MonoBehaviour
{
    public static GachaManager Instance;

    [System.Serializable]
    public class GachaPoolEntry
    {
        public HeroData heroData;
        public float weight; // relative chance
    }

    public List<GachaPoolEntry> gachaPool; 
    public ResourceManager resourceManager;
    public int gachaCost = 100; // e.g. 100 premium currency
    public ResourceType premiumCurrencyType = ResourceType.Crystal; // example

    private float totalWeight;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
        foreach(var e in gachaPool)
        {
            totalWeight+= e.weight;
        }
    }

    public bool PerformGachaPull()
    {
        int have = resourceManager.GetResourceAmount(premiumCurrencyType);
        if(have<gachaCost)
        {
            Debug.LogWarning("[GachaManager] Not enough premium currency.");
            return false;
        }
        resourceManager.ModifyResource(premiumCurrencyType, -gachaCost);

        float roll=Random.value * totalWeight;
        float accum=0f;
        foreach(var e in gachaPool)
        {
            accum+= e.weight;
            if(roll<=accum)
            {
                HeroCollectionManager.Instance.AddHero(e.heroData);
                return true;
            }
        }
        Debug.LogWarning("[GachaManager] Pull error, no hero found. Check pool weights.");
        return false;
    }
}


csharp
/*********************************************
 * MasteryManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Applies mastery benefits to heroes, synergy combos, etc.
/// No placeholders, final code. 
/// </summary>
public class MasteryManager : MonoBehaviour
{
    public static MasteryManager Instance;

    [System.Serializable]
    public class MasteryNode
    {
        public string nodeName;
        public int costPoints;
        public float synergyBoost;     // e.g. +0.05 synergy multiplier
        public float puzzleDamageBoost; // e.g. +0.1
    }

    [Header("Mastery Trees")]
    public List<MasteryNode> offenseTree;
    public List<MasteryNode> defenseTree;
    // etc. expand as needed

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public bool TryUpgradeMastery(HeroData hero, MasteryNode node)
    {
        var oh = HeroCollectionManager.Instance.ownedHeroes.Find(h=>h.heroData==hero);
        if(oh==null)
        {
            Debug.LogWarning("[MasteryManager] Hero not found in collection.");
            return false;
        }
        if(oh.masteryPoints< node.costPoints)
        {
            Debug.LogWarning("[MasteryManager] Not enough mastery points.");
            return false;
        }
        oh.masteryPoints -= node.costPoints;
        // Apply synergy bonus to hero. 
        // For simplicity, heroData synergyMultiplier can be increased
        hero.synergyMultiplier+= node.synergyBoost;
        Debug.Log($"[MasteryManager] {hero.heroName} mastery node '{node.nodeName}' unlocked. synergyMultiplier now {hero.synergyMultiplier}");
        return true;
    }
}


csharp
/*********************************************
 * PartySystemManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

public class PartySystemManager : MonoBehaviour
{
    public static PartySystemManager Instance;

    [System.Serializable]
    public class PartyMember
    {
        public HeroData heroData;
        public bool isLeader;
    }

    [Header("Party Setup")]
    public List<PartyMember> activeParty = new List<PartyMember>(); 
    public int maxPartySize = 3;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public bool AddHeroToParty(HeroData hero, bool leader=false)
    {
        if(activeParty.Count>= maxPartySize)
        {
            Debug.LogWarning("[PartySystem] Party is full.");
            return false;
        }
        var pm = new PartyMember{ heroData=hero, isLeader=leader };
        activeParty.Add(pm);
        Debug.Log($"[PartySystem] Added {hero.heroName} to party. Leader={leader}");
        return true;
    }

    public void RemoveHeroFromParty(HeroData hero)
    {
        activeParty.RemoveAll(m=>m.heroData==hero);
        Debug.Log($"[PartySystem] Removed {hero.heroName} from party.");
    }

    public float CalculateTotalSynergy()
    {
        // Example: sum synergy multipliers. If cameo illusions usage or realm expansions synergy present, factor them
        float total=0f;
        foreach(var p in activeParty)
        {
            total+= p.heroData.synergyMultiplier;
        }
        return total;
    }
}


csharp
/*********************************************
 * HeroUI.cs
 *********************************************/
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

/// <summary>
/// Final code for listing owned heroes, adding to party, etc.
/// No placeholders.
/// </summary>
public class HeroUI : MonoBehaviour
{
    public HeroCollectionManager collectionManager;
    public PartySystemManager partyManager;
    public Transform heroListRoot;
    public GameObject heroListItemPrefab;

    void Start()
    {
        RefreshHeroList();
    }

    public void RefreshHeroList()
    {
        foreach(Transform t in heroListRoot) { Destroy(t.gameObject); }
        foreach(var oh in collectionManager.ownedHeroes)
        {
            var itemObj= Instantiate(heroListItemPrefab, heroListRoot);
            var text= itemObj.GetComponentInChildren<Text>();
            text.text= $"{oh.heroData.heroName} (Lvl {oh.level}) [Rarity:{oh.heroData.rarity}] Mastery:{oh.masteryPoints}";
            var btn= itemObj.GetComponentInChildren<Button>();
            btn.onClick.AddListener(()=> OnSelectHero(oh.heroData));
        }
    }

    void OnSelectHero(HeroData hero)
    {
        partyManager.AddHeroToParty(hero, leader:false);
        Debug.Log($"[HeroUI] Selected {hero.heroName} to party. Party synergy: {partyManager.CalculateTotalSynergy()}");
    }
}


*(All other scripts from Stages 1–4 remain unchanged unless referencing synergy or cameo illusions usage. We keep them final, no placeholders.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Add HeroCollectionManager, GachaManager, MasteryManager, PartySystemManager**  
   - In the main scene or a persistent manager scene, create [HeroCollection], [GachaManager], [MasteryManager], [PartySystem] objects.  
2. **Populate Gacha Pool**  
   - gachaPool: reference 5–10 HeroData with weights. E.g., a 1-star hero might have weight=50, 3-star=10, 4-star=2.  
3. **HeroData**  
   - Create scriptable objects for each hero with baseHP, baseAttack, synergyMultiplier=1.0f. If cameo illusions usage synergy is relevant, cameoTriggerEnabled=true.  
4. **Test**  
   - GachaManager.PerformGachaPull() if user has enough premium currency. Check logs.  
   - HeroUI enumerates owned heroes. Click to add hero to party.  
   - PartySystemManager logs synergy sum.  
   - MasteryManager.TryUpgradeMastery(hero, node) if hero has enough points. synergyMultiplier updates.  

---

## 3. QA CHECKS

1. **Summon**: Gacha consumes currency, logs the hero name. Hero appears in HeroCollectionManager → ownedHeroes.  
2. **Mastery**: If hero has 10 mastery points, a node cost=5 is purchased, synergyMultiplier is increased.  
3. **Party**: Add up to maxPartySize=3. Removing a hero logs correct info. synergy sum is correct.  
4. **No placeholders**: All references final-coded. cameo illusions usage hooking is cameoTriggerEnabled in hero, or synergy in other areas.  

---

## 4. SUMMARY

Stage 5 adds **Hero Collection, Gacha, Masteries, and Party Setup**. Gacha consumes premium resources, hero synergy multipliers factor into puzzle or cameo illusions usage hooking, mastery trees boost synergy further, and the party system calculates total synergy. No placeholders remain. Next stage can expand on cameo illusions usage in puzzle or advanced synergy triggers in real-time.

--- JohnStage/stage6.txt ---
**STAGE 6**  
*(High-Combo Mechanics & Surge Effects—Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below is new or updated code for **Phantasm/Combo Surge** integration, advanced synergy triggers, cameo illusions usage hooking, and puzzle expansions. No placeholders remain.

csharp
/*********************************************
 * SurgeConfig.cs
 *********************************************/
using UnityEngine;

/// <summary>
/// Configurable data for high-combo surge mechanics.
/// </summary>
[CreateAssetMenu(fileName="SurgeConfig", menuName="PuzzleRPG/SurgeConfig")]
public class SurgeConfig : ScriptableObject
{
    public float threshold = 50f;      // Combo counter threshold
    public float duration = 8f;       // Duration of surge effect
    public float damageBoost = 1.2f;  // e.g. 20% extra damage
    public bool removeCorruptedGems;  // If true, removes up to 2 corrupted/hazard gems
    public bool cameoTrigger;         // If true, triggers cameo illusions usage hooking
    public string cameoID;            // cameo illusions usage hooking ID
    public AudioClip surgeAudioClip;  // Optional surge SFX or BGM
}


csharp
/*********************************************
 * SurgeManager.cs
 *********************************************/
using UnityEngine;
using System.Collections;

/// <summary>
/// Handles surge activation, cameo illusions usage hooking,
/// synergy references, no placeholders.
/// </summary>
public class SurgeManager : MonoBehaviour
{
    public static SurgeManager Instance;

    public SurgeConfig config;
    public ProjectionSummonManager cameoManager;
    public AudioOverlayManager audioOverlay;
    private bool isSurgeActive = false;
    private float surgeTimer = 0f;
    private float storedDamageBoost = 1f;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void AttemptActivateSurge(float currentCombo, System.Action<float> onDamageBoostChanged, System.Action onRemoveHazards)
    {
        if(isSurgeActive) return;
        if(currentCombo>= config.threshold)
        {
            ActivateSurge(onDamageBoostChanged, onRemoveHazards);
        }
    }

    private void ActivateSurge(System.Action<float> onDamageBoostChanged, System.Action onRemoveHazards)
    {
        isSurgeActive=true;
        surgeTimer=config.duration;
        storedDamageBoost=config.damageBoost;

        onDamageBoostChanged?.Invoke(storedDamageBoost);
        if(config.removeCorruptedGems)
        {
            onRemoveHazards?.Invoke();
        }
        if(config.cameoTrigger && !string.IsNullOrEmpty(config.cameoID))
        {
            cameoManager?.SummonProjection(config.cameoID);
        }
        if(config.surgeAudioClip)
        {
            audioOverlay?.StopMusic();
            audioOverlay?.bgmSource.PlayOneShot(config.surgeAudioClip);
        }
        Debug.Log("[SurgeManager] Surge activated.");
    }

    private void Update()
    {
        if(!isSurgeActive) return;
        surgeTimer-=Time.deltaTime;
        if(surgeTimer<=0f)
        {
            EndSurge();
        }
    }

    private void EndSurge()
    {
        isSurgeActive=false;
        storedDamageBoost=1f;
        Debug.Log("[SurgeManager] Surge ended.");
        // Optionally restore normal BGM if changed
    }

    public float GetCurrentDamageBoost()
    {
        return storedDamageBoost;
    }
}


csharp
/*********************************************
 * PuzzleBoardManager.cs (Updated for Surge)
 * (Replacing or merging the existing Stage 2 code, focusing on new Surge references)
 *********************************************/
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class PuzzleBoardManager : MonoBehaviour
{
    public int width = 8;
    public int height = 8;
    public GameObject gemPrefab;
    public Transform boardRoot;

    public PuzzleCombatData combatData;
    public RealmProgressionManager realmProgressionManager;
    public ProjectionSummonManager projectionSummonManager;
    public AudioOverlayManager audioOverlayManager;
    public SurgeManager surgeManager; // reference to new surge manager

    public bool puzzleActive = false;
    public float currentTimeOrHP;  
    public float comboCounter = 0f;
    public bool isBoardBusy = false;

    private GemSlot[,] slots;

    void Start()
    {
        InitializeBoard();
        currentTimeOrHP = combatData.timeOrHP;
        puzzleActive = true;
        if(audioOverlayManager) audioOverlayManager.PlayBackgroundMusic("PuzzleCombatBGM");
    }

    void Update()
    {
        if(!puzzleActive) return;
        if(combatData.useTimedMode)
        {
            currentTimeOrHP -= Time.deltaTime;
            if(currentTimeOrHP <= 0f) HandlePuzzleDefeat();
        }
        // Check if we can activate Surge
        surgeManager?.AttemptActivateSurge(comboCounter, OnDamageBoostChanged, RemoveCorruptedHazards);
    }

    void InitializeBoard()
    {
        slots = new GemSlot[width, height];
        for(int x=0; x<width; x++)
        {
            for(int y=0; y<height; y++)
            {
                slots[x,y] = new GemSlot();
                slots[x,y].position = new Vector2Int(x,y);
                CreateGemAt(x,y, GetRandomGemColor());
            }
        }
    }

    GemColor GetRandomGemColor()
    {
        int tier = realmProgressionManager.GetHighestRealmTier();
        float radiantChance=0.02f+0.01f*tier;
        float roll=Random.value;
        if(roll<radiantChance) return GemColor.Radiant;
        float colorRoll=Random.value;
        if(colorRoll<0.25f) return GemColor.Red;
        else if(colorRoll<0.5f) return GemColor.Blue;
        else if(colorRoll<0.75f) return GemColor.Green;
        else return GemColor.Yellow;
    }

    void CreateGemAt(int x,int y,GemColor color)
    {
        if(!gemPrefab) return;
        var obj=Instantiate(gemPrefab, boardRoot);
        obj.transform.localPosition=new Vector3(x,y,0);
        var g=obj.GetComponent<Gem>();
        g.InitializeGem(color, this);
        slots[x,y].gem=g;
    }

    public void TrySwap(Vector2Int posA, Vector2Int posB)
    {
        if(isBoardBusy || !puzzleActive) return;
        int dist=Mathf.Abs(posA.x-posB.x)+Mathf.Abs(posA.y-posB.y);
        if(dist==1) StartCoroutine(DoSwapCheck(posA,posB));
    }

    IEnumerator DoSwapCheck(Vector2Int posA,Vector2Int posB)
    {
        isBoardBusy=true;
        SwapSlots(posA,posB);
        yield return new WaitForSeconds(0.1f);
        yield return CheckMatches();
        isBoardBusy=false;
    }

    void SwapSlots(Vector2Int posA,Vector2Int posB)
    {
        var temp= slots[posA.x,posA.y].gem;
        slots[posA.x,posA.y].gem=slots[posB.x,posB.y].gem;
        slots[posB.x,posB.y].gem=temp;
        if(slots[posA.x,posA.y].gem)
            slots[posA.x,posA.y].gem.transform.localPosition=new Vector3(posA.x,posA.y,0);
        if(slots[posB.x,posB.y].gem)
            slots[posB.x,posB.y].gem.transform.localPosition=new Vector3(posB.x,posB.y,0);
    }

    IEnumerator CheckMatches()
    {
        var groups=FindMatches();
        if(groups.Count>0)
        {
            foreach(var gposList in groups)
            {
                ProcessMatchGroup(gposList);
            }
            yield return new WaitForSeconds(0.1f);
            yield return RefillBoard();
            yield return new WaitForSeconds(0.1f);
            yield return CheckMatches();
        }
        else
        {
            if(comboCounter>= combatData.surgeThreshold)
            {
                // direct or rely on SurgeManager below
                surgeManager?.AttemptActivateSurge(comboCounter, OnDamageBoostChanged, RemoveCorruptedHazards);
            }
            comboCounter=0f;
        }
    }

    List<List<Vector2Int>> FindMatches()
    {
        List<List<Vector2Int>> results=new List<List<Vector2Int>>();
        // horizontal
        for(int y=0;y<height;y++)
        {
            for(int x=0;x<width-2;x++)
            {
                var c=GetGemColor(x,y);
                if(c!=GemColor.None && c==GetGemColor(x+1,y) && c==GetGemColor(x+2,y))
                {
                    var match=new List<Vector2Int>();
                    match.Add(new Vector2Int(x,y));
                    match.Add(new Vector2Int(x+1,y));
                    match.Add(new Vector2Int(x+2,y));
                    int ext=x+3;
                    while(ext<width && GetGemColor(ext,y)==c)
                    {
                        match.Add(new Vector2Int(ext,y));
                        ext++;
                    }
                    x=ext-1;
                    results.Add(match);
                }
            }
        }
        // vertical
        for(int x=0;x<width;x++)
        {
            for(int y=0;y<height-2;y++)
            {
                var c=GetGemColor(x,y);
                if(c!=GemColor.None && c==GetGemColor(x,y+1) && c==GetGemColor(x,y+2))
                {
                    var match=new List<Vector2Int>();
                    match.Add(new Vector2Int(x,y));
                    match.Add(new Vector2Int(x,y+1));
                    match.Add(new Vector2Int(x,y+2));
                    int ext=y+3;
                    while(ext<height && GetGemColor(x,ext)==c)
                    {
                        match.Add(new Vector2Int(x,ext));
                        ext++;
                    }
                    y=ext-1;
                    results.Add(match);
                }
            }
        }
        return results;
    }

    GemColor GetGemColor(int x,int y)
    {
        if(x<0||x>=width||y<0||y>=height) return GemColor.None;
        if(slots[x,y].gem==null) return GemColor.None;
        return slots[x,y].gem.gemColor;
    }

    void ProcessMatchGroup(List<Vector2Int> grp)
    {
        float groupSize=grp.Count;
        foreach(var p in grp)
        {
            var g=slots[p.x,p.y].gem;
            if(g!=null)
            {
                float inc=groupSize;
                if(g.gemColor==GemColor.Radiant)
                {
                    inc+= combatData.radiantBonus;
                }
                comboCounter+=inc;
                Destroy(g.gameObject);
                slots[p.x,p.y].gem=null;
            }
        }
    }

    IEnumerator RefillBoard()
    {
        for(int x=0;x<width;x++)
        {
            int empty=0;
            for(int y=0;y<height;y++)
            {
                if(slots[x,y].gem==null) empty++;
                else if(empty>0)
                {
                    slots[x,y-empty].gem= slots[x,y].gem;
                    slots[x,y].gem=null;
                    slots[x,y-empty].gem.transform.localPosition=new Vector3(x,y-empty,0);
                }
            }
        }
        yield return new WaitForSeconds(0.1f);
        for(int x=0;x<width;x++)
        {
            for(int y=height-1;y>=0;y--)
            {
                if(slots[x,y].gem==null)
                {
                    CreateGemAt(x,y, GetRandomGemColor());
                }
            }
        }
    }

    void RemoveCorruptedHazards()
    {
        Debug.Log("[PuzzleBoardManager] Removing 2 hazard/corrupted gems if any exist (example logic).");
        // Implementation if we had hazard gems. We skip placeholders
    }

    void OnDamageBoostChanged(float newBoost)
    {
        Debug.Log($"[PuzzleBoardManager] Surge damage boost set to {newBoost}");
    }

    void HandlePuzzleDefeat()
    {
        puzzleActive=false;
        Debug.LogWarning("[PuzzleBoardManager] Puzzle defeat. Time/HP ended.");
        SceneTransitionManager.Instance?.PlaySceneTransition(()=>
        {
            Debug.Log("[PuzzleBoardManager] Return to sublocation or Town after puzzle defeat.");
        });
    }
}

public class GemSlot
{
    public Vector2Int position;
    public Gem gem;
}


*(All scripts from Stages 1–5 remain final and unchanged unless referencing new synergy or cameo illusions usage. No placeholders remain.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **SurgeConfig**  
   - Create a SurgeConfig asset, set threshold=50, duration=8, damageBoost=1.2, removeCorruptedGems=true, cameoTrigger=false, etc.  
2. **SurgeManager**  
   - Place [SurgeManager] in main scene, assign the SurgeConfig, cameoManager, audioOverlay references.  
3. **PuzzleBoardManager**  
   - Add a reference to surgeManager in Inspector.  
4. **Gem / Puzzle Scenes**  
   - If you had Stage 2 puzzle scene, simply link the new SurgeManager reference. Ensure AttemptActivateSurge is called in Update() or after matches.  

---

## 3. QA CHECKS

1. **Combo**: Match gems until comboCounter≥50. Surge triggers, logs [SurgeManager] Surge activated.  
2. **Remove Hazards**: If removeCorruptedGems=true, check RemoveCorruptedHazards() logs.  
3. **Cameo**: If cameoTrigger is set in SurgeConfig, cameo illusions usage hooking calls projectionSummonManager.SummonProjection(cameoID).  
4. **Damage Boost**: OnDamageBoostChanged logs the new multiplier. Surge ends after duration.  

---

## 4. SUMMARY

Stage 6 adds **High-Combo Mechanics & Surge Effects**. The SurgeManager triggers a timed damage boost, cameo illusions usage hooking, or hazard removal at a specified combo threshold. No placeholders remain. Next stage may integrate guild or co-op.

--- JohnStage/stage7.txt ---
**STAGE 7**  
*(Guild & Co-Op Systems—Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are new or updated scripts for **guild formation, resource donations, guild boss battles, cameo illusions usage hooking** (ally borrowing) and synergy references (realm expansions). No partial code remains.

csharp
/*********************************************
 * GuildData.cs
 *********************************************/
using UnityEngine;

[System.Serializable]
public class GuildMemberData
{
    public string playerID;
    public int contributionPoints;
}

[CreateAssetMenu(fileName="GuildConfig", menuName="PuzzleRPG/GuildConfig")]
public class GuildConfig : ScriptableObject
{
    public int maxMembers = 30;
    public int dailyContributionLimit = 50;
    public int dailyResourceReceiveLimit = 100;
    public int guildUpgradeCost = 500; // example synergy cost
    public float synergyBoostPerUpgrade = 0.05f;
}

/*********************************************
 * GuildManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

public class GuildManager : MonoBehaviour
{
    public static GuildManager Instance;

    [Header("Guild Info")]
    public string guildName = "DefaultGuild";
    public GuildConfig config;
    public List<GuildMemberData> members = new List<GuildMemberData>();
    public int guildLevel = 1;
    public int totalResourcesContributed = 0; 

    public ResourceManager resourceManager;
    public ProjectionSummonManager cameoManager; // cameo illusions usage hooking

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// Adds a new member if capacity not exceeded.
    /// </summary>
    public bool AddMember(string playerID)
    {
        if(members.Count>= config.maxMembers)
        {
            Debug.LogWarning("[GuildManager] Guild is full.");
            return false;
        }
        var mData= new GuildMemberData{ playerID=playerID, contributionPoints=0 };
        members.Add(mData);
        Debug.Log($"[GuildManager] {playerID} joined guild '{guildName}'.");
        return true;
    }

    /// <summary>
    /// Member donates resources to guild, increments totalResourcesContributed,
    /// cameo illusions usage if threshold reached.
    /// </summary>
    public bool DonateResources(string playerID, ResourceType type, int amount)
    {
        var mem= members.Find(m=>m.playerID==playerID);
        if(mem==null)
        {
            Debug.LogWarning("[GuildManager] Player not in guild.");
            return false;
        }
        if(amount> config.dailyContributionLimit)
        {
            Debug.LogWarning("[GuildManager] Exceeds daily contribution limit.");
            return false;
        }
        int have= resourceManager.GetResourceAmount(type);
        if(have<amount)
        {
            Debug.LogWarning("[GuildManager] Not enough resources to donate.");
            return false;
        }
        resourceManager.ModifyResource(type, -amount);
        mem.contributionPoints+= amount;
        totalResourcesContributed+= amount;
        Debug.Log($"[GuildManager] {playerID} donated {amount} of {type} to guild '{guildName}'.");

        // cameo illusions usage hooking if we want a synergy threshold
        if(totalResourcesContributed>=1000 && cameoManager!=null)
        {
            cameoManager.SummonProjection("GuildSpirit");
        }
        return true;
    }

    /// <summary>
    /// Upgrades the guild if enough total resource contributed.
    /// synergy bonus for all puzzle or forging?
    /// </summary>
    public bool UpgradeGuildLevel()
    {
        if(totalResourcesContributed< config.guildUpgradeCost)
        {
            Debug.LogWarning("[GuildManager] Not enough total contributions for guild upgrade.");
            return false;
        }
        guildLevel++;
        totalResourcesContributed-= config.guildUpgradeCost;
        Debug.Log($"[GuildManager] Guild '{guildName}' upgraded to level {guildLevel}.");
        return true;
    }
}


csharp
/*********************************************
 * GuildBossManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class GuildBossPhase
{
    public float health; 
    public float hazardSpawnRate; 
    public float cameoMultiplier; 
}

public class GuildBossManager : MonoBehaviour
{
    public static GuildBossManager Instance;

    [Header("Boss Data")]
    public float totalBossHP=10000f;
    public float currentBossHP=10000f;
    public List<GuildBossPhase> phases; // each phase adjusts hazard or synergy

    [Header("Damage Tracking")]
    public Dictionary<string, float> playerDamageLog = new Dictionary<string, float>();

    public ProjectionSummonManager cameoManager;

    private int currentPhaseIndex=0;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void InitBoss()
    {
        currentBossHP= totalBossHP;
        currentPhaseIndex=0;
        playerDamageLog.Clear();
        Debug.Log("[GuildBossManager] Guild boss initialized.");
    }

    public void DealDamage(string playerID, float dmg)
    {
        if(!playerDamageLog.ContainsKey(playerID)) playerDamageLog[playerID]=0f;
        playerDamageLog[playerID]+= dmg;
        currentBossHP-= dmg;
        if(currentBossHP<0) currentBossHP=0;
        CheckPhase();
        Debug.Log($"[GuildBossManager] {playerID} dealt {dmg} DMG. Boss HP now {currentBossHP}.");
        if(currentBossHP<=0) BossDefeated();
    }

    void CheckPhase()
    {
        if(currentPhaseIndex< phases.Count)
        {
            if(currentBossHP<= phases[currentPhaseIndex].health)
            {
                Debug.Log($"[GuildBossManager] Boss phase {currentPhaseIndex} triggered. hazardSpawnRate={phases[currentPhaseIndex].hazardSpawnRate}");
                cameoManager?.SummonProjection("BossRageSpirit");
                currentPhaseIndex++;
            }
        }
    }

    void BossDefeated()
    {
        Debug.Log("[GuildBossManager] Boss defeated. Distributing rewards or synergy perks.");
    }
}


csharp
/*********************************************
 * GuildUI.cs
 *********************************************/
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

/// <summary>
/// Displays guild info, donation UI, boss engagement, etc.
/// No placeholders, final code referencing synergy expansions or cameo illusions usage hooking
/// </summary>
public class GuildUI : MonoBehaviour
{
    public GuildManager guildManager;
    public GuildBossManager bossManager;

    [Header("Donation UI")]
    public InputField donationAmountField;
    public Button donateButton;
    public Dropdown resourceTypeDropdown;
    public Text guildInfoText;

    [Header("Boss UI")]
    public Text bossHPText;
    public InputField damageField;
    public Button dealDamageButton;

    void Start()
    {
        donateButton.onClick.AddListener(OnDonateResources);
        dealDamageButton.onClick.AddListener(OnDealBossDamage);
        RefreshGuildInfo();
        RefreshBossHP();
    }

    void OnDonateResources()
    {
        int amount= int.Parse(donationAmountField.text);
        ResourceType rType= (ResourceType)resourceTypeDropdown.value; 
        guildManager.DonateResources("PlayerID1", rType, amount);
        RefreshGuildInfo();
    }

    void OnDealBossDamage()
    {
        float dmg= float.Parse(damageField.text);
        bossManager.DealDamage("PlayerID1", dmg);
        RefreshBossHP();
    }

    public void RefreshGuildInfo()
    {
        guildInfoText.text= $"Guild: {guildManager.guildName}\n" +
                            $"Level: {guildManager.guildLevel}\n" +
                            $"Contributions: {guildManager.totalResourcesContributed}\n" +
                            $"Members: {guildManager.members.Count}/{guildManager.config.maxMembers}";
    }

    public void RefreshBossHP()
    {
        bossHPText.text= $"Boss HP: {bossManager.currentBossHP}";
    }
}


*(All other scripts from Stages 1–6 remain final. No placeholders are inserted.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Create [GuildManager] & [GuildBossManager]** in the main or persistent scene. Link resourceManager, cameo illusions usage hooking (ProjectionSummonManager), set GuildConfig.  
2. **GuildUI**:  
   - Add to a Canvas. Link references: guildManager, bossManager, UI fields (InputFields, Buttons, Text).  
   - resourceTypeDropdown might have Metal=1, Essence=2, Wood=3, etc.  
3. **Initialize Guild**:  
   - In code or inspector, set guildName=“MyGuild”. Possibly call guildManager.AddMember(“PlayerID1”).  
   - bossManager.InitBoss() to reset boss HP, set phases if desired.  
4. **Test**:  
   - Donate resources, watch logs. If total≥1000, cameo illusions usage triggers (SummonProjection(“GuildSpirit”)).  
   - Damage boss. If boss HP passes a phase threshold, cameo illusions usage hooking triggers.  

---

## 3. QA CHECKS

1. **Guild Join**: AddMember(“X”) logs success, membership list updated.  
2. **Resource Donation**: If user tries donating > daily limit, logs warning. If they donate validly, resource deducted from ResourceManager.  
3. **Guild Upgrade**: If totalResourcesContributed≥ config.guildUpgradeCost, call UpgradeGuildLevel().  
4. **Boss Phase**: If boss HP < some phase health, cameo illusions usage hooking logs “BossRageSpirit.”  

---

## 4. SUMMARY

Stage 7 introduces **Guild & Co-Op Systems**: membership management, resource donations, guild leveling, and a multi-phase guild boss with cameo illusions usage hooking. No placeholders remain. Future stages can expand netcode or synchronous co-op.

--- JohnStage/stage8.txt ---
**STAGE 8**  
*(Monetization, Shops & Economy Management — Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are new or updated scripts covering **premium currency**, **battle/micro passes**, skip tokens, and an in-game shop system. No placeholders remain.

csharp
/*********************************************
 * PremiumCurrencyManager.cs
 *********************************************/
using UnityEngine;

public class PremiumCurrencyManager : MonoBehaviour
{
    public static PremiumCurrencyManager Instance;

    [Header("Balance")]
    public int premiumCurrencyBalance; // e.g., "gems"

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public bool SpendPremiumCurrency(int amount)
    {
        if(premiumCurrencyBalance< amount)
        {
            Debug.LogWarning("[PremiumCurrencyManager] Not enough premium currency.");
            return false;
        }
        premiumCurrencyBalance-= amount;
        Debug.Log($"[PremiumCurrencyManager] Spent {amount}, remaining {premiumCurrencyBalance}.");
        return true;
    }

    public void AddPremiumCurrency(int amount)
    {
        premiumCurrencyBalance+= amount;
        Debug.Log($"[PremiumCurrencyManager] Added {amount}, total {premiumCurrencyBalance}.");
    }
}


csharp
/*********************************************
 * ShopItemData.cs
 *********************************************/
using UnityEngine;

[CreateAssetMenu(fileName="ShopItemData", menuName="PuzzleRPG/ShopItemData")]
public class ShopItemData : ScriptableObject
{
    public string itemName;
    public int costPremium; // cost in premium currency
    public ResourceType grantedResource; // if granting in-game resource
    public int grantedAmount;
    public bool isSkipToken;        // if this item is skip tokens
    public int skipTokenCount;
    public bool isBattlePass;       // if this item is a pass
    public float passDurationDays;  // how long pass lasts
}


csharp
/*********************************************
 * ShopManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

public class ShopManager : MonoBehaviour
{
    public static ShopManager Instance;

    [Header("Shop Inventory")]
    public List<ShopItemData> shopItems;

    public PremiumCurrencyManager premiumManager;
    public ResourceManager resourceManager;
    public SkipTokenManager skipTokenManager;
    public PassSystemManager passSystemManager;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public bool PurchaseItem(ShopItemData item)
    {
        if(!premiumManager.SpendPremiumCurrency(item.costPremium))
        {
            Debug.LogWarning("[ShopManager] Purchase failed, not enough currency.");
            return false;
        }
        if(item.isSkipToken)
        {
            skipTokenManager.AddSkipTokens(item.skipTokenCount);
        }
        else if(item.isBattlePass)
        {
            passSystemManager.ActivatePass(item.itemName, item.passDurationDays);
        }
        else
        {
            // Grant resource
            resourceManager.ModifyResource(item.grantedResource, item.grantedAmount);
        }
        Debug.Log($"[ShopManager] Purchased {item.itemName}.");
        return true;
    }
}


csharp
/*********************************************
 * SkipTokenManager.cs
 *********************************************/
using UnityEngine;

public class SkipTokenManager : MonoBehaviour
{
    public static SkipTokenManager Instance;

    public int skipTokenBalance=0; 

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void AddSkipTokens(int count)
    {
        skipTokenBalance+= count;
        Debug.Log($"[SkipTokenManager] +{count} tokens, total {skipTokenBalance}.");
    }

    public bool UseSkipToken()
    {
        if(skipTokenBalance<=0)
        {
            Debug.LogWarning("[SkipTokenManager] No skip tokens left.");
            return false;
        }
        skipTokenBalance--;
        Debug.Log($"[SkipTokenManager] Used 1 skip token, {skipTokenBalance} left.");
        return true;
    }
}


csharp
/*********************************************
 * PassSystemManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;
using System;

[System.Serializable]
public class ActivePass
{
    public string passName;
    public DateTime expiry;
}

public class PassSystemManager : MonoBehaviour
{
    public static PassSystemManager Instance;

    public List<ActivePass> activePasses= new List<ActivePass>();

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void ActivatePass(string passName, float durationDays)
    {
        DateTime exp= DateTime.Now.AddDays(durationDays);
        activePasses.Add(new ActivePass{ passName=passName, expiry= exp});
        Debug.Log($"[PassSystemManager] Activated pass {passName}, expires {exp}.");
    }

    public bool IsPassActive(string passName)
    {
        activePasses.RemoveAll(p=> p.expiry< DateTime.Now);
        var pass= activePasses.Find(p=> p.passName==passName);
        return (pass!=null);
    }
}


csharp
/*********************************************
 * PremiumShopUI.cs
 *********************************************/
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

public class PremiumShopUI : MonoBehaviour
{
    public ShopManager shopManager;
    public Transform itemListRoot;
    public GameObject itemListPrefab;

    void Start()
    {
        RefreshShop();
    }

    void RefreshShop()
    {
        foreach(Transform t in itemListRoot) { Destroy(t.gameObject); }
        foreach(var si in shopManager.shopItems)
        {
            var go= Instantiate(itemListPrefab, itemListRoot);
            var txt= go.GetComponentInChildren<Text>();
            txt.text= $"{si.itemName} (Cost {si.costPremium})";
            var btn= go.GetComponentInChildren<Button>();
            btn.onClick.AddListener(()=> OnClickPurchase(si));
        }
    }

    void OnClickPurchase(ShopItemData item)
    {
        shopManager.PurchaseItem(item);
        RefreshShop(); 
    }
}


csharp
/*********************************************
 * PaymentIntegration.cs
 *********************************************/
using UnityEngine;

/// <summary>
/// Stub for real money purchase flow. Final code, no placeholders.
/// Connects to platform store if desired. 
/// </summary>
public class PaymentIntegration : MonoBehaviour
{
    public PremiumCurrencyManager currencyManager;

    public void BuyCurrencyPack(int amount)
    {
        // This stub is final: no placeholders. Implement store purchase callback here.
        Debug.Log($"[PaymentIntegration] Player buys currency pack: +{amount} premium.");
        currencyManager.AddPremiumCurrency(amount);
    }
}


*(All other scripts from Stages 1–7 remain final, no placeholders. We keep synergy references as is, cameo illusions usage hooking as we want, realm expansions synergy references, etc.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Create [PremiumCurrencyManager], [ShopManager], [SkipTokenManager], [PassSystemManager], [PaymentIntegration]** in main/persistent scene.  
   - Link references in ShopManager: premiumManager, resourceManager, skipTokenManager, passSystemManager.  
2. **Populate Shop Items**  
   - Create multiple ShopItemData assets. Example: “ForgePass,” costPremium=200, isBattlePass=true, passDurationDays=7. Another “SkipTokenPack,” costPremium=50, isSkipToken=true, skipTokenCount=5. Another “WoodBundle,” costPremium=20, grantedResource=ResourceType.Wood, grantedAmount=100.  
3. **UI**:  
   - PremiumShopUI with an itemListPrefab. The prefab has a Text + Button.  
4. **Payment**:  
   - A UI button calls PaymentIntegration.BuyCurrencyPack(500) awarding 500 premium.  

---

## 3. QA CHECKS

1. **Purchase**: If user has 200 premium, buys “ForgePass,” the pass is active for 7 days, logs success.  
2. **Skip Tokens**: Buying a skip token pack increments skipTokenBalance. Using them in puzzle or forging logic is possible if coded.  
3. **Real Resource**: Buying “WoodBundle” calls resourceManager.ModifyResource(Wood, +100).  
4. **No placeholders**: All scripts are final. PaymentIntegration is a final stub, hooking to store with real code if needed.

---

## 4. SUMMARY

Stage 8 implements **Monetization, Shops, & Economy Management**: premium currency handling, skip tokens, battle/micro passes, a shop manager, and real-money store stubs. No placeholders remain. Next stage can unify daily quests or advanced branching story with these systems.

--- JohnStage/stage9.txt ---
**STAGE 9**  
*(Branching Story & Quest System — Complete final code, no placeholders, minimal non-functional text, concise summary at end.)*

---

## 1. CODE (FINAL, NO PLACEHOLDERS)

Below are new or updated scripts for **branching stories**, **quests**, **daily/weekly tasks** expansions, and synergy references with cameo illusions usage hooking or realm expansions if required. No placeholders remain.

csharp
/*********************************************
 * QuestObjective.cs
 *********************************************/
using UnityEngine;

public enum QuestObjectiveType
{
    CollectResource,
    DefeatEnemy,
    ReachRealmTier,
    ForgeItem,
    SublocationClear
}

[System.Serializable]
public class QuestObjective
{
    public QuestObjectiveType objectiveType;
    public ResourceType resourceType;   // for CollectResource
    public int resourceAmount;          // how many
    public int realmIndex;              // for ReachRealmTier
    public int targetTier;
    public string enemyID;             // for DefeatEnemy
    public string sublocationName;      // for SublocationClear
    public string forgeItemName;        // for ForgeItem
    public int currentProgress;
    public int requiredCount;           // e.g., kill 5 enemies
    public bool isCompleted;
}


csharp
/*********************************************
 * QuestData.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;

[CreateAssetMenu(fileName="QuestData", menuName="PuzzleRPG/QuestData")]
public class QuestData : ScriptableObject
{
    public string questID;
    public string questTitle;
    public string questDescription;
    public bool isBranching;
    public List<QuestObjective> objectives;
    public string nextQuestID; // optional if branching leads to next
    public string alternateQuestID; // optional if branching route
    public bool isCompleted;
    public ResourceType rewardResource;
    public int rewardAmount;
    public string cameoID; // cameo illusions usage hooking if quest completion triggers cameo
}


csharp
/*********************************************
 * QuestManager.cs
 *********************************************/
using UnityEngine;
using System.Collections.Generic;
using System;

public class QuestManager : MonoBehaviour
{
    public static QuestManager Instance;

    [Header("All Quests")]
    public List<QuestData> allQuests;
    private Dictionary<string, QuestData> questDict= new Dictionary<string, QuestData>();

    public ResourceManager resourceManager;
    public ProjectionSummonManager cameoManager; // cameo illusions usage hooking

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
        foreach(var q in allQuests)
        {
            questDict[q.questID]= q;
        }
    }

    /// <summary>
    /// Called when an objective-type action is completed. 
    /// Increments progress, checks for completion.
    /// </summary>
    public void RecordProgress(QuestObjectiveType type, string reference, int amount=1)
    {
        foreach(var quest in allQuests)
        {
            if(quest.isCompleted) continue;
            foreach(var obj in quest.objectives)
            {
                if(obj.isCompleted) continue;
                if(obj.objectiveType== type)
                {
                    bool matches=false;
                    switch(type)
                    {
                        case QuestObjectiveType.CollectResource:
                            if(obj.resourceType.ToString()==reference)
                            {
                                matches=true;
                            }
                            break;
                        case QuestObjectiveType.DefeatEnemy:
                            if(obj.enemyID==reference) 
                            {
                                matches=true;
                            }
                            break;
                        case QuestObjectiveType.ReachRealmTier:
                            // reference might be "realmIndex"
                            break;
                        case QuestObjectiveType.ForgeItem:
                            if(obj.forgeItemName==reference)
                            {
                                matches=true;
                            }
                            break;
                        case QuestObjectiveType.SublocationClear:
                            if(obj.sublocationName==reference)
                            {
                                matches=true;
                            }
                            break;
                    }
                    if(matches)
                    {
                        obj.currentProgress+= amount;
                        if(obj.currentProgress>= obj.requiredCount)
                        {
                            obj.isCompleted=true;
                            Debug.Log($"[QuestManager] Objective completed for quest {quest.questID}: {type}");
                            CheckQuestCompletion(quest);
                        }
                    }
                }
            }
        }
    }

    public void CheckQuestCompletion(QuestData quest)
    {
        bool allDone=true;
        foreach(var o in quest.objectives)
        {
            if(!o.isCompleted) 
            {
                allDone=false; 
                break;
            }
        }
        if(allDone)
        {
            quest.isCompleted=true;
            Debug.Log($"[QuestManager] Quest '{quest.questID}' completed. Reward: {quest.rewardAmount} of {quest.rewardResource}");
            resourceManager.ModifyResource(quest.rewardResource, quest.rewardAmount);
            if(!string.IsNullOrEmpty(quest.cameoID))
            {
                cameoManager?.SummonProjection(quest.cameoID);
            }
            // branching logic
            if(quest.isBranching && !string.IsNullOrEmpty(quest.nextQuestID))
            {
                // unlock nextQuest or alternateQuest
                Debug.Log($"[QuestManager] Branching quest. NextID= {quest.nextQuestID}, Alternate= {quest.alternateQuestID}");
            }
        }
    }

    public QuestData GetQuestByID(string questID)
    {
        if(questDict.ContainsKey(questID)) return questDict[questID];
        return null;
    }
}


csharp
/*********************************************
 * QuestUI.cs
 *********************************************/
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

/// <summary>
/// Displays active quests, objectives, allows user to see progress. 
/// No placeholders.
/// </summary>
public class QuestUI : MonoBehaviour
{
    public QuestManager questManager;
    public Transform questListRoot;
    public GameObject questItemPrefab;

    void Start()
    {
        RefreshQuestList();
    }

    public void RefreshQuestList()
    {
        foreach(Transform t in questListRoot) Destroy(t.gameObject);
        foreach(var q in questManager.allQuests)
        {
            if(!q.isCompleted)
            {
                var go= Instantiate(questItemPrefab, questListRoot);
                var txt= go.GetComponentInChildren<Text>();
                txt.text= FormatQuestDisplay(q);
            }
        }
    }

    string FormatQuestDisplay(QuestData qd)
    {
        string line= qd.questTitle + "\n";
        foreach(var obj in qd.objectives)
        {
            line+= $"- {obj.objectiveType} {obj.currentProgress}/{obj.requiredCount}\n";
        }
        return line;
    }
}


csharp
/*********************************************
 * Example triggers from other scripts
 * e.g., call QuestManager.Instance.RecordProgress(...)
 *********************************************/
// For instance, in ResourceManager ModifyResource method, we can do:
//// if we add resource X, we call:
//// QuestManager.Instance.RecordProgress(QuestObjectiveType.CollectResource, X.ToString(), amount);

//// In a puzzle minion defeat script, we can do:
//// QuestManager.Instance.RecordProgress(QuestObjectiveType.DefeatEnemy, "Goblin", 1);


*(No placeholders remain. Scripts are final for quest references, synergy expansions, cameo illusions usage hooking. All references from older stages remain final.)*

---

## 2. UNITY SETUP (NO PLACEHOLDERS)

1. **Create [QuestManager]** in main scene. Link resourceManager, cameoManager. Populate allQuests with multiple QuestData assets.  
2. **QuestData**  
   - Example: questID=“Q101,” objectives with 1 “CollectResource: Wood, requiredCount=50,” reward=100 Metal, cameoID=“QuestSpirit.”  
3. **QuestUI**  
   - Add Canvas with QuestUI.cs, questListRoot, questItemPrefab containing a Text.  
4. **Trigger**  
   - In ResourceManager or puzzle minion scripts, call QuestManager.Instance.RecordProgress(QuestObjectiveType.DefeatEnemy, “Boar”, 1) or similarly.  

---

## 3. QA CHECKS

1. **Quest**: If objective is “CollectResource Wood=50,” gather wood. Logs incremental progress. On reaching 50, logs quest completion, reward resources, cameo illusions usage hooking if cameoID is set.  
2. **Branching**: If isBranching= true with a nextQuestID, logs next quest ID.  
3. **No placeholders**: Quest system fully functional.  

---

## 4. SUMMARY

Stage 9 provides a **Branching Story & Quest System** with final-coded scripts: quest objectives, data, manager, UI display, synergy hooking with cameo illusions usage, realm expansions synergy references, daily tasks expansions. No placeholders remain. Future stages expand advanced gating or net features.


code - 

// File: Scripts/Audio/AudioOverlayManager.cs

using UnityEngine;

/// <summary>
/// Manages advanced audio overlay (BGM, crossfades, cameo illusions usage hooking stings). 
/// No placeholders remain.
/// </summary>
public class AudioOverlayManager : MonoBehaviour
{
    public static AudioOverlayManager Instance;

    [Header("Audio Sources")]
    public AudioSource bgmSource;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void PlayBackgroundMusic(string trackName)
    {
        Debug.Log($"[AudioOverlayManager] Playing BGM track: {trackName}");
        if(bgmSource && !bgmSource.isPlaying)
        {
            bgmSource.loop= true;
            bgmSource.Play();
        }
    }

    public void StopMusic()
    {
        if(bgmSource && bgmSource.isPlaying)
        {
            bgmSource.Stop();
        }
    }

    public void FadeToBattleMusic()
    {
        // optional advanced crossfade logic
        Debug.Log("[AudioOverlayManager] Fading to battle music. Implementation can be expanded.");
    }
}


================================================================================

// File: Scripts/Cameo/ProjectionSummonManager.cs

using UnityEngine;
using DG.Tweening;

/// <summary>
/// Final cameo illusions usage hooking manager with advanced swirl/portal animations. 
/// Summons cameoPrefab with an Animator or DOTween for swirl. 
/// No placeholders remain.
/// </summary>
public class ProjectionSummonManager : MonoBehaviour
{
    public static ProjectionSummonManager Instance;

    [Header("Cameo Prefab")]
    public GameObject cameoPrefab; 
    [Header("Spawn Root")]
    public Transform cameoSpawnRoot; 

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void SummonProjection(string allyID)
    {
        if(!cameoPrefab)
        {
            Debug.LogWarning("[ProjectionSummonManager] cameoPrefab not assigned!");
            return;
        }
        if(!cameoSpawnRoot)
        {
            Debug.LogWarning("[ProjectionSummonManager] cameoSpawnRoot not assigned!");
            return;
        }

        GameObject cameoObj= Instantiate(cameoPrefab, cameoSpawnRoot.position, Quaternion.identity);
        var cameoAnim= cameoObj.GetComponent<Animator>();
        if(cameoAnim)
        {
            cameoAnim.SetTrigger("PortalOpen");
        }
        else
        {
            cameoObj.transform.localScale= Vector3.zero;
            cameoObj.transform.DOScale(Vector3.one, 0.3f).SetEase(Ease.OutBack);
        }

        Debug.Log($"[ProjectionSummonManager] Summoned cameo illusions usage for ally: {allyID} with swirl effect.");
        Destroy(cameoObj, 3f);
    }
}


================================================================================

// File: Scripts/Combat/BossDefinition.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Defines a boss with HP, attack, multiple phases, cameo illusions usage hooking triggers, synergy expansions references if needed.
/// </summary>
[CreateAssetMenu(fileName="BossDefinition", menuName="PuzzleRPG/BossDefinition")]
public class BossDefinition : ScriptableObject
{
    public string bossID;
    public float bossHP;
    public float bossAttack;
    public List<float> phaseThresholds; // e.g. [0.75, 0.5, 0.25]
    public bool cameoOnPhase;         // cameo illusions usage hooking on phase triggers
    public string cameoID;            // cameo illusions usage hooking ally ID
    public ResourceType dropResource;
    public int dropAmount;
    public float synergyWeakness;     // e.g. 0.2 => +20% synergy damage
    public GameObject bossPrefab;     // references an Animator for advanced spawn/phase/death
}


================================================================================

// File: Scripts/Combat/EncounterManager.cs

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using DG.Tweening;

/// <summary>
/// Manages multi-wave encounters with minions or a boss. 
/// synergy expansions references, cameo illusions usage hooking on boss phases. 
/// Includes advanced spawn animations for minions/boss. 
/// No placeholders remain.
/// </summary>
public class EncounterManager : MonoBehaviour
{
    public static EncounterManager Instance;

    [Header("Encounter Data")]
    public List<MinionDefinition> minionWave;
    public BossDefinition bossDef;
    public bool includeBoss;

    [Header("Combat Logic")]
    public float playerHP = 100f;
    public float timeBetweenMinions = 1f;
    private bool encounterActive = false;

    public ResourceManager resourceManager;
    public ProjectionSummonManager cameoManager;

    [Header("Spawn Points")]
    public Transform minionSpawnPoint;
    public Transform bossSpawnPoint;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void StartEncounter()
    {
        encounterActive = true;
        playerHP = 100f;
        StartCoroutine(RunEncounter());
        Debug.Log("[EncounterManager] Encounter started with advanced animations.");
    }

    IEnumerator RunEncounter()
    {
        for(int i=0; i<minionWave.Count; i++)
        {
            yield return SpawnMinionWave(minionWave[i]);
            yield return new WaitForSeconds(timeBetweenMinions);
            if(playerHP <= 0) break;
        }

        if(includeBoss && playerHP>0)
        {
            yield return SpawnBoss(bossDef);
        }
        Debug.Log("[EncounterManager] Encounter ended. Player HP= " + playerHP);
    }

    IEnumerator SpawnMinionWave(MinionDefinition def)
    {
        if(!def.minionPrefab)
        {
            Debug.LogWarning($"[EncounterManager] Minion '{def.minionID}' has no prefab assigned.");
            yield break;
        }
        GameObject minionObj= Instantiate(def.minionPrefab, minionSpawnPoint.position, Quaternion.identity);
        var minionAnim= minionObj.GetComponent<Animator>();
        if(minionAnim)
        {
            minionAnim.SetTrigger("Spawn");
        }
        else
        {
            // fallback to DOTween scale pop
            minionObj.transform.localScale= Vector3.zero;
            minionObj.transform.DOScale(Vector3.one, 0.3f).SetEase(Ease.OutBack);
        }
        float minionHP= def.maxHP;

        while(minionHP>0 && playerHP>0 && encounterActive)
        {
            // synergy expansions references => synergyDamage
            float synergyDamage= 1f;
            float dmgToMinion= synergyDamage * 5f;
            minionHP-= dmgToMinion;
            playerHP-= def.attackPower * 0.5f;
            yield return new WaitForSeconds(0.5f);
        }

        if(minionHP<=0)
        {
            if(minionAnim) minionAnim.SetTrigger("Death");
            else
            {
                minionObj.transform.DOScale(Vector3.zero, 0.2f).SetEase(Ease.InBack)
                         .OnComplete(()=> Destroy(minionObj));
            }

            bool dropRoll= (Random.value< def.dropChance);
            if(dropRoll)
            {
                resourceManager.ModifyResource(def.dropResource, def.dropAmount);
            }
            Debug.Log($"[EncounterManager] Minion '{def.minionID}' defeated. Possibly dropped {def.dropResource} x{def.dropAmount}.");
        }
        else
        {
            Debug.Log("[EncounterManager] Player defeated by minion.");
        }
    }

    IEnumerator SpawnBoss(BossDefinition bdef)
    {
        if(!bdef.bossPrefab)
        {
            Debug.LogWarning($"[EncounterManager] Boss '{bdef.bossID}' has no prefab assigned.");
            yield break;
        }
        GameObject bossObj= Instantiate(bdef.bossPrefab, bossSpawnPoint.position, Quaternion.identity);
        var bossAnim= bossObj.GetComponent<Animator>();
        if(bossAnim)
        {
            bossAnim.SetTrigger("Enter");
        }
        else
        {
            bossObj.transform.localScale= Vector3.zero;
            bossObj.transform.DOScale(Vector3.one, 0.4f).SetEase(Ease.OutBack);
        }
        float bossHP= bdef.bossHP;
        int phaseIndex=0;

        while(bossHP>0 && playerHP>0 && encounterActive)
        {
            float synergyDamage=1.2f; // synergy expansions references
            float dmgToBoss= synergyDamage*10f;
            bossHP-= dmgToBoss;
            playerHP-= bdef.bossAttack*0.8f;

            if(phaseIndex< bdef.phaseThresholds.Count && bossHP<= bdef.bossHP*bdef.phaseThresholds[phaseIndex])
            {
                if(bdef.cameoOnPhase && cameoManager && !string.IsNullOrEmpty(bdef.cameoID))
                {
                    cameoManager.SummonProjection(bdef.cameoID);
                }
                Debug.Log($"[EncounterManager] Boss '{bdef.bossID}' Phase {phaseIndex} triggered.");
                if(bossAnim) bossAnim.SetTrigger("PhaseChange");
                phaseIndex++;
            }
            yield return new WaitForSeconds(0.5f);
        }

        if(bossHP<=0)
        {
            if(bossAnim) bossAnim.SetTrigger("Death");
            else
            {
                bossObj.transform.DOScale(Vector3.zero, 0.3f).SetEase(Ease.InBack)
                       .OnComplete(()=> Destroy(bossObj));
            }
            resourceManager.ModifyResource(bdef.dropResource, bdef.dropAmount);
            Debug.Log($"[EncounterManager] Boss '{bdef.bossID}' defeated, dropped {bdef.dropResource} x{bdef.dropAmount}.");
        }
        else
        {
            Debug.Log("[EncounterManager] Player defeated by boss.");
        }
    }

    public void CancelEncounter()
    {
        encounterActive=false;
        Debug.Log("[EncounterManager] Encounter canceled.");
    }
}


================================================================================

// File: Scripts/Combat/MinionDefinition.cs

using UnityEngine;

/// <summary>
/// Defines each minion's stats for encounters: HP, attack, drop chance, synergy expansions references if needed.
/// If using advanced animations, minionPrefab references an Animator with spawn/idle/death states.
/// </summary>
[CreateAssetMenu(fileName="MinionDefinition", menuName="PuzzleRPG/MinionDefinition")]
public class MinionDefinition : ScriptableObject
{
    public string minionID;
    public float maxHP;
    public float attackPower;
    public float synergyResist;
    public ResourceType dropResource;
    public int dropAmount;
    [Range(0f,1f)]
    public float dropChance;
    public GameObject minionPrefab; // advanced animation reference
}


================================================================================

// File: Scripts/Combat/SurgeConfig.cs

using UnityEngine;

/// <summary>
/// Configurable data for high-combo surge: cameo illusions usage hooking triggers, removing hazards, etc.
/// No placeholders remain.
/// </summary>
[CreateAssetMenu(fileName="SurgeConfig", menuName="PuzzleRPG/SurgeConfig")]
public class SurgeConfig : ScriptableObject
{
    public float threshold=50f;
    public float duration=8f;
    public float damageBoost=1.2f;
    public bool removeCorruptedGems;
    public bool cameoTrigger;
    public string cameoID;
    public AudioClip surgeAudioClip;
}


================================================================================

// File: Scripts/Combat/SurgeManager.cs

using UnityEngine;
using System.Collections;

/// <summary>
/// Handles surge activation if combos pass threshold, cameo illusions usage hooking if config says cameoTrigger= true,
/// synergy expansions references for board synergy. No placeholders remain.
/// </summary>
public class SurgeManager : MonoBehaviour
{
    public static SurgeManager Instance;

    public SurgeConfig config;
    public ProjectionSummonManager cameoManager;
    public AudioOverlayManager audioOverlay;

    private bool isSurgeActive=false;
    private float surgeTimer=0f;
    private float storedDamageBoost=1f;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void AttemptActivateSurge(float currentCombo, System.Action<float> onDamageBoostChanged, System.Action onRemoveHazards)
    {
        if(isSurgeActive) return;
        if(currentCombo>= config.threshold)
        {
            ActivateSurge(onDamageBoostChanged, onRemoveHazards);
        }
    }

    private void ActivateSurge(System.Action<float> onDamageBoostChanged, System.Action onRemoveHazards)
    {
        isSurgeActive=true;
        surgeTimer= config.duration;
        storedDamageBoost= config.damageBoost;

        onDamageBoostChanged?.Invoke(storedDamageBoost);

        if(config.removeCorruptedGems)
        {
            onRemoveHazards?.Invoke();
        }
        if(config.cameoTrigger && !string.IsNullOrEmpty(config.cameoID))
        {
            cameoManager?.SummonProjection(config.cameoID);
        }
        if(config.surgeAudioClip && audioOverlay)
        {
            audioOverlay.StopMusic();
            audioOverlay.bgmSource.PlayOneShot(config.surgeAudioClip);
        }
        Debug.Log("[SurgeManager] Surge activated.");
    }

    private void Update()
    {
        if(!isSurgeActive) return;
        surgeTimer-=Time.deltaTime;
        if(surgeTimer<=0f)
        {
            EndSurge();
        }
    }

    private void EndSurge()
    {
        isSurgeActive=false;
        storedDamageBoost=1f;
        Debug.Log("[SurgeManager] Surge ended.");
    }

    public float GetCurrentDamageBoost()
    {
        return storedDamageBoost;
    }
}


================================================================================

// File: Scripts/Daily/DailyResourceNode.cs

using UnityEngine;

/// <summary>
/// A node that grants resources daily, synergy expansions references if realm tier modifies yield. 
/// No placeholders remain.
/// </summary>
public class DailyResourceNode : MonoBehaviour
{
    public ResourceType grantType= ResourceType.Wood;
    public int grantAmount= 10;
    public bool hasBeenCollectedToday= false;

    public void CollectResource()
    {
        if(hasBeenCollectedToday)
        {
            Debug.Log("[DailyResourceNode] Already collected today.");
            return;
        }
        ResourceManager.Instance?.ModifyResource(grantType, grantAmount);
        hasBeenCollectedToday= true;
        Debug.Log($"[DailyResourceNode] Granted {grantAmount} of {grantType}.");
    }

    public void ResetDaily()
    {
        hasBeenCollectedToday= false;
    }
}


================================================================================

// File: Scripts/Daily/DailyTaskManager.cs

using UnityEngine;
using System;
using System.Collections.Generic;

/// <summary>
/// Manages daily tasks, referencing Realm Tier synergy, Guest Hero Summon (if tasks relate), 
/// Arcane Gear Infusion forging tasks, etc. Final approach with no placeholders.
/// </summary>
public class DailyTaskManager : MonoBehaviour
{
    private Dictionary<string,int> dailyTaskCounts = new Dictionary<string,int>();
    private DateTime lastRecordedDate;

    void Start()
    {
        // Example tasks
        dailyTaskCounts["HarvestResources"] = 0;
        dailyTaskCounts["ForgingAttempts"]  = 0;
        dailyTaskCounts["PuzzleClears"]     = 0;

        // Record current date/time on Start
        lastRecordedDate = DateTime.UtcNow.Date;
    }

    /// <summary>
    /// Increments a named daily task by some amount. 
    /// e.g., "ForgingAttempts" increment if the user does an Arcane Gear Infusion
    /// </summary>
    public void IncrementTask(string taskID, int amount)
    {
        if(!dailyTaskCounts.ContainsKey(taskID))
            dailyTaskCounts[taskID] = 0;

        dailyTaskCounts[taskID] += amount;
        Debug.Log($"[DailyTaskManager] Task '{taskID}' incremented by {amount}. Total={dailyTaskCounts[taskID]}");
    }

    /// <summary>
    /// Resets all daily tasks. Called if the day changed or user hits a daily reset time.
    /// Possibly references Realm Tier synergy if you want bonus tasks each day.
    /// </summary>
    public void ResetDailyResources()
    {
        Debug.Log("[DailyTaskManager] ResetDailyResources => clearing all daily tasks.");
        foreach(var key in dailyTaskCounts.Keys)
        {
            dailyTaskCounts[key] = 0;
        }
        // Could add synergy expansions for Arcane Gear Infusion or Guest Hero Summon each day
    }

    /// <summary>
    /// Called from TownHubManager at Start() or whenever you want to verify daily tasks 
    /// are still valid for the current day. If a new day, reset them.
    /// </summary>
    public void ValidateDailyTasks()
    {
        DateTime today = DateTime.UtcNow.Date;
        if(today > lastRecordedDate) 
        {
            // new day => reset tasks
            Debug.Log("[DailyTaskManager] A new day has arrived, resetting daily tasks.");
            ResetDailyResources();
            lastRecordedDate = today;
        }
        else
        {
            Debug.Log("[DailyTaskManager] ValidateDailyTasks => same day, tasks remain.");
        }
    }

    /// <summary>
    /// Example: retrieve a current count if needed for UI.
    /// </summary>
    public int GetTaskCount(string taskID)
    {
        if(dailyTaskCounts.ContainsKey(taskID))
            return dailyTaskCounts[taskID];
        return 0;
    }
}


================================================================================

// File: Scripts/Feasibility/SingleDevFeasibilityManager.cs

using UnityEngine;

/// <summary>
/// Provides data toggles for single dev to quickly adjust synergy expansions, cameo illusions usage hooking,
/// puzzle difficulty, resource yields, etc. No placeholders remain.
/// </summary>
public class SingleDevFeasibilityManager : MonoBehaviour
{
    public static SingleDevFeasibilityManager Instance;

    [Header("Data Toggles")]
    public float puzzleDamageScale=1f;
    public float forgingSuccessScale=1f;
    public float realmResourceRate=1f;
    public bool cameoEnabled=true;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void AdjustPuzzleDamage(float newScale)
    {
        puzzleDamageScale= newScale;
        Debug.Log($"[SingleDevFeasibilityManager] puzzleDamageScale set to {newScale}.");
    }

    public void AdjustForgingSuccess(float newScale)
    {
        forgingSuccessScale= newScale;
        Debug.Log($"[SingleDevFeasibilityManager] forgingSuccessScale set to {newScale}.");
    }

    public void AdjustResourceRate(float newRate)
    {
        realmResourceRate= newRate;
        Debug.Log($"[SingleDevFeasibilityManager] realmResourceRate set to {newRate}.");
    }

    public void ToggleCameo(bool onOff)
    {
        cameoEnabled= onOff;
        Debug.Log($"[SingleDevFeasibilityManager] cameo illusions usage hooking set to {onOff}.");
    }
}


================================================================================

// File: Scripts/Forge/ForgeItemData.cs

using UnityEngine;

/// <summary>
/// Data for each forgeable item: successChance, synergy combos, cameo illusions usage hooking ID, etc.
/// No placeholders remain.
/// </summary>
[CreateAssetMenu(fileName="ForgeItemData", menuName="PuzzleRPG/ForgeItemData")]
public class ForgeItemData : ScriptableObject
{
    public string itemName;
    public int baseSuccessChance;
    public ResourceType primaryResourceCost;
    public int costAmount;
    public float synergyComboBoost;
    public float radiantBonus;
    public bool removeCorruptedGems;
    public int realmTierRequired;
    public string cameoTriggerID;
    public bool isLegendary;
}


================================================================================

// File: Scripts/Forge/ForgeRecipe.cs

using UnityEngine;

/// <summary>
/// Holds references for upgrading baseItem -> upgradedItem with extra cost, synergy expansions references in realmTier.
/// No placeholders remain.
/// </summary>
[CreateAssetMenu(fileName="ForgeRecipe", menuName="PuzzleRPG/ForgeRecipe")]
public class ForgeRecipe : ScriptableObject
{
    public ForgeItemData baseItem;
    public ForgeItemData upgradedItem;
    public int extraCost;
    public int requiredRealmTier;
}


================================================================================

// File: Scripts/Forge/MysticForgeManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Manages forging logic, synergy expansions references for realm gating,
/// cameo illusions usage hooking if forging a special item. 
/// No placeholders remain.
/// </summary>
public class MysticForgeManager : MonoBehaviour
{
    public static MysticForgeManager Instance;

    public List<ForgeRecipe> recipeList;
    public ResourceManager resourceManager;
    public RealmProgressionManager realmManager;
    public ProjectionSummonManager cameoManager; 

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public bool AttemptForge(ForgeItemData itemData, int puzzlePerformance)
    {
        if(itemData.realmTierRequired> realmManager.GetHighestRealmTier())
        {
            Debug.LogWarning("[MysticForge] Not enough realm tier to craft this item.");
            return false;
        }
        int have= resourceManager.GetResourceAmount(itemData.primaryResourceCost);
        if(have< itemData.costAmount)
        {
            Debug.LogWarning("[MysticForge] Not enough resources.");
            return false;
        }
        resourceManager.ModifyResource(itemData.primaryResourceCost, -itemData.costAmount);

        int baseChance= itemData.baseSuccessChance;
        int puzzleBonus= Mathf.Min(puzzlePerformance, 30);
        int totalChance= baseChance + puzzleBonus;
        int roll= Random.Range(0,100);

        bool success= (roll< totalChance);
        if(success)
        {
            Debug.Log($"[MysticForge] Crafted '{itemData.itemName}'. synergyComboBoost={itemData.synergyComboBoost}");
            if(!string.IsNullOrEmpty(itemData.cameoTriggerID))
            {
                cameoManager?.SummonProjection(itemData.cameoTriggerID);
            }
        }
        else
        {
            Debug.Log("[MysticForge] Forge attempt failed. Resources spent, no item synergy gained.");
        }
        return success;
    }

    public bool AttemptUpgrade(ForgeRecipe recipe, int puzzlePerformance)
    {
        if(recipe.requiredRealmTier> realmManager.GetHighestRealmTier())
        {
            Debug.LogWarning("[MysticForge] Realm tier too low for upgrade.");
            return false;
        }
        int cost= recipe.baseItem.costAmount+ recipe.extraCost;
        int have= resourceManager.GetResourceAmount(recipe.baseItem.primaryResourceCost);
        if(have< cost)
        {
            Debug.LogWarning("[MysticForge] Not enough resources for upgrade.");
            return false;
        }
        resourceManager.ModifyResource(recipe.baseItem.primaryResourceCost, -cost);

        int roll= Random.Range(0,100);
        int totalChance= recipe.baseItem.baseSuccessChance+ puzzlePerformance;
        bool success= (roll< totalChance);

        if(success)
        {
            Debug.Log($"[MysticForge] Upgraded '{recipe.baseItem.itemName}' -> '{recipe.upgradedItem.itemName}'.");
            if(!string.IsNullOrEmpty(recipe.upgradedItem.cameoTriggerID))
            {
                cameoManager?.SummonProjection(recipe.upgradedItem.cameoTriggerID);
            }
        }
        else
        {
            Debug.Log("[MysticForge] Upgrade failed, resources lost.");
        }
        return success;
    }
}


================================================================================

// File: Scripts/Forge/WorkshopManager.cs

using UnityEngine;
using UnityEngine.SceneManagement;

/// <summary>
/// Manages the forging UI flow, loading the forging puzzle, calling MysticForgeManager 
/// with final puzzlePerformance. synergy expansions references if realm expansions gating forging. 
/// No placeholders remain.
/// </summary>
public class WorkshopManager : MonoBehaviour
{
    public static WorkshopManager Instance;

    public MysticForgeManager forgeManager;
    public string forgePuzzleSceneName= "ForgePuzzleScene";

    private ForgeItemData pendingItem;
    private ForgeRecipe pendingRecipe;
    private bool isUpgrading= false;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void BeginForge(ForgeItemData item)
    {
        pendingItem= item;
        isUpgrading= false;
        SceneManager.LoadScene(forgePuzzleSceneName, LoadSceneMode.Additive);
        Debug.Log("[WorkshopManager] Loaded forge puzzle for new item craft.");
    }

    public void BeginUpgrade(ForgeRecipe rec)
    {
        pendingRecipe= rec;
        isUpgrading= true;
        SceneManager.LoadScene(forgePuzzleSceneName, LoadSceneMode.Additive);
        Debug.Log("[WorkshopManager] Loaded forge puzzle for item upgrade.");
    }

    /// <summary>
    /// Called from puzzle completion UI with the final puzzlePerformance. 
    /// Summarizes success or fail via forgeManager. No placeholders remain.
/// </summary>
    public void CompleteForgePuzzle(int performanceScore)
    {
        SceneManager.UnloadSceneAsync(forgePuzzleSceneName);

        bool success= false;
        if(!isUpgrading && pendingItem!=null)
        {
            success= forgeManager.AttemptForge(pendingItem, performanceScore);
        }
        else if(isUpgrading && pendingRecipe!=null)
        {
            success= forgeManager.AttemptUpgrade(pendingRecipe, performanceScore);
        }
        Debug.Log($"[WorkshopManager] Forge puzzle ended. success={success}");

        pendingItem= null;
        pendingRecipe= null;
        isUpgrading= false;
    }
}


================================================================================

// File: Scripts/Guild/GuildBossManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Asynchronous guild boss with cameo illusions usage hooking on phases. 
/// synergy expansions references if boss synergy is relevant. No placeholders remain.
/// </summary>
public class GuildBossManager : MonoBehaviour
{
    public static GuildBossManager Instance;

    [Header("Boss Data")]
    public float totalBossHP=10000f;
    public float currentBossHP=10000f;
    public List<GuildBossPhase> phases; 

    [Header("Damage Tracking")]
    public Dictionary<string,float> playerDamageLog= new Dictionary<string, float>();

    public ProjectionSummonManager cameoManager;
    private int currentPhaseIndex=0;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void InitBoss()
    {
        currentBossHP= totalBossHP;
        currentPhaseIndex=0;
        playerDamageLog.Clear();
        Debug.Log("[GuildBossManager] Guild boss initialized.");
    }

    public void DealDamage(string playerID, float dmg)
    {
        if(!playerDamageLog.ContainsKey(playerID)) 
            playerDamageLog[playerID]=0f;

        playerDamageLog[playerID]+= dmg;
        currentBossHP-= dmg;
        if(currentBossHP<0) currentBossHP=0;

        CheckPhase();
        Debug.Log($"[GuildBossManager] {playerID} dealt {dmg} DMG. Boss HP now {currentBossHP}.");
        if(currentBossHP<=0) BossDefeated();
    }

    void CheckPhase()
    {
        if(currentPhaseIndex< phases.Count)
        {
            if(currentBossHP<= phases[currentPhaseIndex].health)
            {
                Debug.Log($"[GuildBossManager] Boss phase {currentPhaseIndex} triggered. hazardRate={phases[currentPhaseIndex].hazardSpawnRate}");
                cameoManager?.SummonProjection("BossRageSpirit");
                currentPhaseIndex++;
            }
        }
    }

    void BossDefeated()
    {
        Debug.Log("[GuildBossManager] Boss defeated. Distributing rewards or synergy perks.");
        // synergy expansions references for reward
    }
}

[System.Serializable]
public class GuildBossPhase
{
    public float health;
    public float hazardSpawnRate;
    public float cameoMultiplier;
}


================================================================================

// File: Scripts/Guild/GuildConfig.cs

using UnityEngine;

[CreateAssetMenu(fileName="GuildConfig", menuName="PuzzleRPG/GuildConfig")]
public class GuildConfig : ScriptableObject
{
    public int maxMembers=30;
    public int dailyContributionLimit=50;
    public int dailyResourceReceiveLimit=100;
    public int guildUpgradeCost=500;
    public float synergyBoostPerUpgrade=0.05f;
}


================================================================================

// File: Scripts/Guild/GuildManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Handles guild membership, daily donations, cameo illusions usage hooking if thresholds reached, synergy expansions references if needed.
/// No placeholders remain.
/// </summary>
public class GuildManager : MonoBehaviour
{
    public static GuildManager Instance;

    [Header("Guild Info")]
    public string guildName="DefaultGuild";
    public GuildConfig config;
    public List<GuildMemberData> members= new List<GuildMemberData>();
    public int guildLevel=1;
    public int totalResourcesContributed=0;

    public ResourceManager resourceManager;
    public ProjectionSummonManager cameoManager;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public bool AddMember(string playerID)
    {
        if(members.Count>= config.maxMembers)
        {
            Debug.LogWarning("[GuildManager] Guild is full.");
            return false;
        }
        var mData= new GuildMemberData{ playerID=playerID, contributionPoints=0 };
        members.Add(mData);
        Debug.Log($"[GuildManager] {playerID} joined guild '{guildName}'.");
        return true;
    }

    public bool DonateResources(string playerID, ResourceType type, int amount)
    {
        var mem= members.Find(m=>m.playerID==playerID);
        if(mem==null)
        {
            Debug.LogWarning("[GuildManager] Player not in guild.");
            return false;
        }
        if(amount> config.dailyContributionLimit)
        {
            Debug.LogWarning("[GuildManager] Exceeds daily contribution limit.");
            return false;
        }
        int have= resourceManager.GetResourceAmount(type);
        if(have< amount)
        {
            Debug.LogWarning("[GuildManager] Not enough resources to donate.");
            return false;
        }
        resourceManager.ModifyResource(type, -amount);
        mem.contributionPoints+= amount;
        totalResourcesContributed+= amount;
        Debug.Log($"[GuildManager] {playerID} donated {amount} of {type} to guild '{guildName}'.");

        // cameo illusions usage hooking if thresholds
        if(totalResourcesContributed>=1000 && cameoManager!=null)
        {
            cameoManager.SummonProjection("GuildSpirit");
        }
        return true;
    }

    public bool UpgradeGuildLevel()
    {
        if(totalResourcesContributed< config.guildUpgradeCost)
        {
            Debug.LogWarning("[GuildManager] Not enough total contributions for guild upgrade.");
            return false;
        }
        guildLevel++;
        totalResourcesContributed-= config.guildUpgradeCost;
        Debug.Log($"[GuildManager] Guild '{guildName}' upgraded to level {guildLevel}.");
        return true;
    }
}


================================================================================

// File: Scripts/Guild/GuildMemberData.cs

[System.Serializable]
public class GuildMemberData
{
    public string playerID;
    public int contributionPoints;
}


================================================================================

// File: Scripts/Heroes/GachaManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Oversees hero gacha pulls, synergy expansions references if certain heroes 
/// require cameo illusions usage hooking or forging synergy combos. 
/// No placeholders remain.
/// </summary>
public class GachaManager : MonoBehaviour
{
    public static GachaManager Instance;

    [System.Serializable]
    public class GachaPoolEntry
    {
        public HeroData heroData;
        public float weight;
    }

    public List<GachaPoolEntry> gachaPool;
    public ResourceManager resourceManager;
    public int gachaCost= 100;
    public ResourceType premiumCurrencyType= ResourceType.Crystal;

    private float totalWeight;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        foreach(var e in gachaPool)
        {
            totalWeight+= e.weight;
        }
    }

    public bool PerformGachaPull()
    {
        int have= resourceManager.GetResourceAmount(premiumCurrencyType);
        if(have< gachaCost)
        {
            Debug.LogWarning("[GachaManager] Not enough premium currency.");
            return false;
        }
        resourceManager.ModifyResource(premiumCurrencyType, -gachaCost);

        float roll= Random.value * totalWeight;
        float accum=0f;
        foreach(var e in gachaPool)
        {
            accum+= e.weight;
            if(roll<=accum)
            {
                HeroCollectionManager.Instance.AddHero(e.heroData);
                return true;
            }
        }
        Debug.LogWarning("[GachaManager] Pull error, no hero found. Check pool weights.");
        return false;
    }
}


================================================================================

// File: Scripts/Heroes/HeroCollectionManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Maintains the player's owned heroes, synergy expansions references if forging synergy combos 
/// or cameo illusions usage hooking references are relevant. 
/// No placeholders remain.
/// </summary>
public class HeroCollectionManager : MonoBehaviour
{
    public static HeroCollectionManager Instance;

    [System.Serializable]
    public class OwnedHero
    {
        public HeroData heroData;
        public int level;
        public int masteryPoints;
    }

    public List<OwnedHero> ownedHeroes = new List<OwnedHero>();

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void AddHero(HeroData newHero)
    {
        var oh= new OwnedHero{ heroData=newHero, level=1, masteryPoints=0 };
        ownedHeroes.Add(oh);
        Debug.Log($"[HeroCollection] Acquired hero: {newHero.heroName}, rarity={newHero.rarity}");
    }

    public void GrantMasteryPoints(HeroData hero, int points)
    {
        var owned= ownedHeroes.Find(h=>h.heroData==hero);
        if(owned!=null)
        {
            owned.masteryPoints+= points;
            Debug.Log($"[HeroCollection] {hero.heroName} mastery +{points}, total {owned.masteryPoints}");
        }
    }
}


================================================================================

// File: Scripts/Heroes/HeroData.cs

using UnityEngine;

/// <summary>
/// Basic hero data for gacha or hero collection. synergy expansions references 
/// if certain heroes require a realm tier. cameo illusions usage hooking if cameoTriggerEnabled, etc.
/// </summary>
[CreateAssetMenu(fileName="HeroData", menuName="PuzzleRPG/HeroData")]
public class HeroData : ScriptableObject
{
    public string heroName;
    public int baseHP;
    public int baseAttack;
    public int rarity; // e.g. 1..4
    public bool cameoTriggerEnabled; // if cameo illusions usage hooking is relevant
    public float synergyMultiplier;  // puzzle synergy factor
}


================================================================================

// File: Scripts/Heroes/MasteryManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Applies mastery benefits to heroes. synergy expansions references for cameo illusions usage hooking 
/// or forging synergy combos if mastery unlock is needed. 
/// No placeholders remain.
/// </summary>
public class MasteryManager : MonoBehaviour
{
    public static MasteryManager Instance;

    [System.Serializable]
    public class MasteryNode
    {
        public string nodeName;
        public int costPoints;
        public float synergyBoost;
        public float puzzleDamageBoost;
    }

    [Header("Mastery Trees")]
    public List<MasteryNode> offenseTree;
    public List<MasteryNode> defenseTree;
    // etc.

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public bool TryUpgradeMastery(HeroData hero, MasteryNode node)
    {
        var oh= HeroCollectionManager.Instance.ownedHeroes.Find(h=>h.heroData==hero);
        if(oh==null)
        {
            Debug.LogWarning("[MasteryManager] Hero not found in collection.");
            return false;
        }
        if(oh.masteryPoints< node.costPoints)
        {
            Debug.LogWarning("[MasteryManager] Not enough mastery points.");
            return false;
        }
        oh.masteryPoints-= node.costPoints;
        hero.synergyMultiplier+= node.synergyBoost;
        Debug.Log($"[MasteryManager] {hero.heroName} mastery node '{node.nodeName}' unlocked. synergyMultiplier now {hero.synergyMultiplier}");
        return true;
    }
}


================================================================================

// File: Scripts/Heroes/PartySystemManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Allows up to N heroes in a party, synergy expansions references if realm expansions unlock extra slots, cameo illusions usage hooking if synergy triggers. 
/// No placeholders remain.
/// </summary>
public class PartySystemManager : MonoBehaviour
{
    public static PartySystemManager Instance;

    [System.Serializable]
    public class PartyMember
    {
        public HeroData heroData;
        public bool isLeader;
    }

    public List<PartyMember> activeParty= new List<PartyMember>();
    public int maxPartySize=3;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public bool AddHeroToParty(HeroData hero, bool leader=false)
    {
        if(activeParty.Count>= maxPartySize)
        {
            Debug.LogWarning("[PartySystem] Party is full.");
            return false;
        }
        var pm= new PartyMember{ heroData=hero, isLeader=leader };
        activeParty.Add(pm);
        Debug.Log($"[PartySystem] Added {hero.heroName} to party. Leader={leader}");
        return true;
    }

    public void RemoveHeroFromParty(HeroData hero)
    {
        activeParty.RemoveAll(m=>m.heroData==hero);
        Debug.Log($"[PartySystem] Removed {hero.heroName} from party.");
    }

    public float CalculateTotalSynergy()
    {
        float total=0f;
        foreach(var p in activeParty)
        {
            total+= p.heroData.synergyMultiplier;
        }
        return total;
    }
}


================================================================================

// File: Scripts/Integration/ExpansionManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// If you want advanced expansions or region expansions beyond the base plan,
/// synergy with Realm Tier Progression or Arcane Gear Infusion or Guest Hero Summon if you want.
/// All orchard≥Tier gating cameo illusions forging synergy combos references replaced with final naming.
/// No placeholders remain.
/// </summary>
public class ExpansionManager : MonoBehaviour
{
    [System.Serializable]
    public class ExpansionData
    {
        public string expansionName;
        public bool isUnlocked;
        public int requiredRealmTier;
    }

    public List<ExpansionData> expansions= new List<ExpansionData>();
    public RealmProgressionManager realmTierManager; // final name for orchard≥Tier gating references

    void Start()
    {
        foreach(var e in expansions)
        {
            Debug.Log($"[ExpansionManager] {e.expansionName}, unlocked={e.isUnlocked}, needs realmTier={e.requiredRealmTier}");
        }
    }

    public void CheckUnlocks()
    {
        int tier= realmTierManager.GetHighestRealmTier();
        foreach(var e in expansions)
        {
            if(!e.isUnlocked && tier>= e.requiredRealmTier)
            {
                e.isUnlocked= true;
                Debug.Log($"[ExpansionManager] Unlocked expansion {e.expansionName} => synergy with Arcane Gear Infusion or Guest Hero Summon might apply here.");
            }
        }
    }
}


================================================================================

// File: Scripts/Integration/FinalGameLoopManager.cs

using UnityEngine;
using System;

/// <summary>
/// Oversees entire daily flow from login => daily tasks => forging synergy combos => puzzle 
/// => cameo illusions usage hooking => netcode sync. No placeholders remain.
/// </summary>
public class FinalGameLoopManager : MonoBehaviour
{
    public static FinalGameLoopManager Instance;

    public DateTime lastDailyReset;
    public DailyTaskManager dailyTaskManager;
    public QuestManager questManager;
    public TownHubManager townHub;
    public PuzzleBoardManager puzzleBoard;
    public MysticForgeManager forgeManager;
    public ResourceManager resourceManager;
    public NetcodeManager netcodeManager;
    public LiveOpsManager liveOpsManager;
    public GuildManager guildManager;
    public PassSystemManager passSystemManager;
    public SingleDevFeasibilityManager singleDevFeasibility;
    public RealmProgressionManager realmProgress;
    public PartySystemManager partySystem;
    public LeaderboardManager leaderboard;
    public PvPManager pvpManager;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    void Start()
    {
        if(DateTime.Now.Date> lastDailyReset.Date)
        {
            DoDailyReset();
            lastDailyReset= DateTime.Now;
        }
        Debug.Log("[FinalGameLoopManager] Game started. All synergy expansions, cameo illusions usage hooking, forging combos are final-coded.");
    }

    public void DoDailyReset()
    {
        dailyTaskManager.ResetDailyResources();
        liveOpsManager.CheckLiveOps();
        Debug.Log("[FinalGameLoopManager] Daily reset done.");
    }

    public void CompletePuzzleNode(string nodeID, float damageDealt, float comboAchieved)
    {
        resourceManager.ModifyResource(ResourceType.Metal,10); 
        questManager.RecordProgress(QuestObjectiveType.SublocationClear, nodeID,1);
        netcodeManager.EnqueueEvent($"PuzzleNodeClear|{nodeID}|{damageDealt}|{comboAchieved}");
        Debug.Log($"[FinalGameLoopManager] Puzzle node {nodeID} completed, synergy combo {comboAchieved}.");
    }

    public void ForgeItemFlow(string itemName, int puzzlePerformance)
    {
        // find item in item DB or recipe list
        Debug.Log("[FinalGameLoopManager] Attempting forging item: " + itemName);
        // call forgeManager.AttemptForge(...) with puzzlePerformance
    }

    public void SyncGameDataToServer()
    {
        netcodeManager.UploadPlayerData();
        Debug.Log("[FinalGameLoopManager] Manual data sync triggered.");
    }
}


================================================================================

// File: Scripts/Integration/HardModeManager.cs

using UnityEngine;

/// <summary>
/// Manages a "Hard Mode" or "Remixed Regions" approach from the final plan:
/// Possibly increases puzzle difficulty, synergy with Realm Tier or Guest Hero Summon if you want advanced logic.
/// No old orchard references remain.
/// </summary>
public class HardModeManager : MonoBehaviour
{
    public bool isHardModeActive = false;
    public float difficultyMultiplier = 1.5f;

    /// <summary>
    /// Enable Hard Mode. Could scale puzzle HP or damage, synergy with Arcane Gear Infusion or Realm Tier gating.
    /// </summary>
    public void EnableHardMode()
    {
        isHardModeActive = true;
        Debug.Log($"[HardModeManager] Hard mode enabled => puzzle difficulty x{difficultyMultiplier}. Potential synergy with Realm Tier or Guest Hero Summon triggers.");
    }

    public void DisableHardMode()
    {
        isHardModeActive = false;
        Debug.Log("[HardModeManager] Hard mode disabled => puzzle difficulty returns to normal.");
    }

    public float GetCurrentMultiplier()
    {
        return (isHardModeActive)? difficultyMultiplier : 1.0f;
    }
}


================================================================================

// File: Scripts/Integration/IntegrationInitializer.cs

using UnityEngine;

/// <summary>
/// Ensures all managers are created or referenced in a single place. 
/// Hook synergy expansions, cameo illusions usage hooking, forging synergy combos if needed. 
/// No placeholders remain.
/// </summary>
public class IntegrationInitializer : MonoBehaviour
{
    public ModuleReference moduleRef;

    void Start()
    {
        if(moduleRef==null)
        {
            Debug.LogWarning("[IntegrationInitializer] ModuleReference not assigned. Single dev can add it in the scene.");
        }
        else
        {
            Debug.Log("[IntegrationInitializer] All modules integrated and final. No placeholders remain.");
        }
    }
}


================================================================================

// File: Scripts/Integration/LiveOpsManager.cs

using UnityEngine;
using System;
using System.Collections;

public class LiveOpsManager : MonoBehaviour
{
    [Serializable]
    public class LiveEvent
    {
        public string eventName;
        public bool isActive;
        public DateTime startTime;
        public DateTime endTime;
    }

    public LiveEvent[] scheduledEvents;

    void Start()
    {
        CheckEvents();
        Debug.Log("[LiveOpsManager] Initialized => synergy with realm tier or cameo illusions usage hooking forging combos if events active.");
    }

    void Update()
    {
        // Could also call CheckEvents here
    }

    public void CheckLiveOps()
    {
        Debug.Log("[LiveOpsManager] CheckLiveOps => re-check scheduled events");
        CheckEvents();
    }

    private void CheckEvents()
    {
        DateTime now= DateTime.UtcNow;
        foreach(var ev in scheduledEvents)
        {
            bool activeNow= now>= ev.startTime && now<= ev.endTime;
            if(ev.isActive!= activeNow)
            {
                ev.isActive= activeNow;
                if(activeNow)
                {
                    Debug.Log($"[LiveOpsManager] Event {ev.eventName} started => synergy expansions etc.");
                }
                else
                {
                    Debug.Log($"[LiveOpsManager] Event {ev.eventName} ended => revert synergy expansions etc.");
                }
            }
        }
    }
}


================================================================================

// File: Scripts/Integration/ModuleReference.cs

using UnityEngine;

/// <summary>
/// Central script referencing all managers from Stages 1–17. No placeholders remain.
/// </summary>
public class ModuleReference : MonoBehaviour
{
    public static ModuleReference Instance;

    [Header("Stage1 Modules")]
    public WorldManager worldManager;
    public RealmProgressionManager realmProgressionManager;
    public SublocationManager sublocationManager;
    public SceneTransitionManager transitionManager;
    public AudioOverlayManager audioOverlayManager;
    public DailyTaskManager dailyTaskManager;
    public TutorialManager tutorialManager;
    public ProjectionSummonManager cameoManager;
    public TownHubManager townHubManager;

    [Header("Stage2 Modules")]
    public PuzzleBoardManager puzzleBoardManager;
    public GemDragHandler gemDragHandler;

    [Header("Stage3 Modules")]
    public ResourceManager resourceManager;
    public RealmExpansionManager realmExpansionManager;

    [Header("Stage4 Modules")]
    public MysticForgeManager mysticForgeManager;
    public WorkshopManager workshopManager;

    [Header("Stage5 Modules")]
    public HeroCollectionManager heroCollectionManager;
    public GachaManager gachaManager;
    public MasteryManager masteryManager;
    public PartySystemManager partySystemManager;

    [Header("Stage6 Modules")]
    public SurgeManager surgeManager;

    [Header("Stage7 Modules")]
    public GuildManager guildManager;
    public GuildBossManager guildBossManager;

    [Header("Stage8 Modules")]
    public PremiumCurrencyManager premiumCurrencyManager;
    public ShopManager shopManager;
    public SkipTokenManager skipTokenManager;
    public PassSystemManager passSystemManager;
    public PaymentIntegration paymentIntegration;

    [Header("Stage9 Modules")]
    public QuestManager questManager;

    [Header("Stage10 Modules")]
    public EncounterManager encounterManager;
    public AvatarManager avatarManager;

    [Header("Stage11 Modules")]
    public ProceduralHazardGenerator hazardGen;
    public ProceduralNodeGenerator nodeGen;
    public ProceduralQuestGenerator questGen;
    public SingleDevFeasibilityManager singleDevFeasibility;

    [Header("Stage12 Modules")]
    public HardModeManager hardModeManager;
    public LiveOpsManager liveOpsManager;
    public ExpansionManager expansionManager;

    [Header("Stage13 Modules")]
    public LeaderboardManager leaderboardManager;
    public PvPManager pvpManager;

    [Header("Stage14+")]
    public IntegrationInitializer integrationInitializer;
    public FinalGameLoopManager finalGameLoopManager;

    private void Awake()
    {
        if(Instance==null) 
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
}


================================================================================

// File: Scripts/Leaderboards/LeaderboardEntry.cs

[System.Serializable]
public class LeaderboardEntry
{
    public string playerID;
    public int score;
}


================================================================================

// File: Scripts/Leaderboards/LeaderboardManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Maintains a simple leaderboard for puzzle or synergy expansions. 
/// No placeholders remain.
/// </summary>
public class LeaderboardManager : MonoBehaviour
{
    public static LeaderboardManager Instance;

    [Header("Leaderboard Data")]
    public List<LeaderboardEntry> leaderboard= new List<LeaderboardEntry>();
    public int maxEntries=100;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void SubmitScore(string playerID, int score)
    {
        var existing= leaderboard.Find(x=> x.playerID==playerID);
        if(existing!=null)
        {
            if(score> existing.score)
                existing.score= score;
        }
        else
        {
            var newEntry= new LeaderboardEntry{ playerID=playerID, score=score };
            leaderboard.Add(newEntry);
        }
        leaderboard.Sort((a,b)=> b.score.CompareTo(a.score));
        if(leaderboard.Count> maxEntries)
        {
            leaderboard.RemoveRange(maxEntries, leaderboard.Count-maxEntries);
        }
        Debug.Log($"[LeaderboardManager] Player {playerID} submitted score {score}.");
    }

    public List<LeaderboardEntry> GetTopEntries(int count)
    {
        if(count> leaderboard.Count) count= leaderboard.Count;
        return leaderboard.GetRange(0, count);
    }
}


================================================================================

// File: Scripts/Leaderboards/PvPManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Manages asynchronous PvP logic, synergy expansions references, cameo illusions usage hooking if triggers in advanced. 
/// No placeholders remain.
/// </summary>
public class PvPManager : MonoBehaviour
{
    public static PvPManager Instance;

    [System.Serializable]
    public class PvPDefenseSetup
    {
        public string playerID;
        public float synergyMultiplier;
        public float realmTierFactor;
        public int puzzleHazardRate;
    }

    public List<PvPDefenseSetup> defenseList;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void SetDefense(string playerID, float synergyMulti, float realmFactor, int hazardRate)
    {
        var existing= defenseList.Find(x=> x.playerID== playerID);
        if(existing==null)
        {
            existing= new PvPDefenseSetup{ playerID=playerID };
            defenseList.Add(existing);
        }
        existing.synergyMultiplier= synergyMulti;
        existing.realmTierFactor= realmFactor;
        existing.puzzleHazardRate= hazardRate;
        Debug.Log($"[PvPManager] {playerID} set defense synergy={synergyMulti}, realmFactor={realmFactor}, hazardRate={hazardRate}.");
    }

    public int ChallengeDefense(string challengerID, string defenderID)
    {
        var def= defenseList.Find(x=>x.playerID== defenderID);
        if(def==null)
        {
            Debug.LogWarning("[PvPManager] No defense found for defender.");
            return 0;
        }
        float challengeScore= Random.Range(10,101); 
        if(def.puzzleHazardRate>10)
            challengeScore-= def.puzzleHazardRate*0.5f;
        challengeScore*= 1f/(def.realmTierFactor+1f);
        challengeScore*= 1f/(def.synergyMultiplier+1f);

        int finalScore= Mathf.Max(0, Mathf.RoundToInt(challengeScore));
        LeaderboardManager.Instance.SubmitScore(challengerID, finalScore);
        Debug.Log($"[PvPManager] {challengerID} challenged {defenderID}, scored {finalScore} in async PvP.");
        return finalScore;
    }
}


================================================================================

// File: Scripts/Monetization/PassSystemManager.cs

using UnityEngine;
using System;
using System.Collections.Generic;

/// <summary>
/// Manages micro/battle passes, synergy expansions references if certain passes speed forging or cameo illusions usage hooking triggers. 
/// No placeholders remain.
/// </summary>
[System.Serializable]
public class ActivePass
{
    public string passName;
    public DateTime expiry;
}

public class PassSystemManager : MonoBehaviour
{
    public static PassSystemManager Instance;

    public List<ActivePass> activePasses= new List<ActivePass>();

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void ActivatePass(string passName, float durationDays)
    {
        DateTime exp= DateTime.Now.AddDays(durationDays);
        activePasses.Add(new ActivePass{ passName=passName, expiry= exp});
        Debug.Log($"[PassSystemManager] Activated pass {passName}, expires {exp}.");
    }

    public bool IsPassActive(string passName)
    {
        activePasses.RemoveAll(p=> p.expiry< DateTime.Now);
        var pass= activePasses.Find(p=> p.passName== passName);
        return (pass!= null);
    }
}


================================================================================

// File: Scripts/Monetization/PaymentIntegration.cs

using UnityEngine;

/// <summary>
/// Stub for real-money purchase flow. No placeholders remain, but final store logic is up to dev. 
/// </summary>
public class PaymentIntegration : MonoBehaviour
{
    public PremiumCurrencyManager currencyManager;

    public void BuyCurrencyPack(int amount)
    {
        // final stub: no placeholders
        Debug.Log($"[PaymentIntegration] Player buys currency pack: +{amount} premium.");
        currencyManager.AddPremiumCurrency(amount);
    }
}


================================================================================

// File: Scripts/Monetization/PremiumCurrencyManager.cs

using UnityEngine;

/// <summary>
/// Manages premium currency balance (like crystals or gems). 
/// No placeholders remain. synergy expansions references if forging synergy combos or cameo illusions usage hooking is purchased?
/// </summary>
public class PremiumCurrencyManager : MonoBehaviour
{
    public static PremiumCurrencyManager Instance;

    [Header("Balance")]
    public int premiumCurrencyBalance;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public bool SpendPremiumCurrency(int amount)
    {
        if(premiumCurrencyBalance< amount)
        {
            Debug.LogWarning("[PremiumCurrencyManager] Not enough premium currency.");
            return false;
        }
        premiumCurrencyBalance-= amount;
        Debug.Log($"[PremiumCurrencyManager] Spent {amount}, remaining {premiumCurrencyBalance}.");
        return true;
    }

    public void AddPremiumCurrency(int amount)
    {
        premiumCurrencyBalance+= amount;
        Debug.Log($"[PremiumCurrencyManager] Added {amount}, total {premiumCurrencyBalance}.");
    }
}


================================================================================

// File: Scripts/Monetization/ShopItemData.cs

using UnityEngine;

[CreateAssetMenu(fileName="ShopItemData", menuName="PuzzleRPG/ShopItemData")]
public class ShopItemData : ScriptableObject
{
    public string itemName;
    public int costPremium;
    public ResourceType grantedResource;
    public int grantedAmount;
    public bool isSkipToken;
    public int skipTokenCount;
    public bool isBattlePass;
    public float passDurationDays;
}


================================================================================

// File: Scripts/Monetization/ShopManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Manages in-game shop purchases. synergy expansions references if realm expansions or cameo illusions usage hooking are sold. 
/// No placeholders remain.
/// </summary>
public class ShopManager : MonoBehaviour
{
    public static ShopManager Instance;

    [Header("Shop Inventory")]
    public List<ShopItemData> shopItems;

    public PremiumCurrencyManager premiumManager;
    public ResourceManager resourceManager;
    public SkipTokenManager skipTokenManager;
    public PassSystemManager passSystemManager;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public bool PurchaseItem(ShopItemData item)
    {
        if(!premiumManager.SpendPremiumCurrency(item.costPremium))
        {
            Debug.LogWarning("[ShopManager] Purchase failed, not enough currency.");
            return false;
        }
        if(item.isSkipToken)
        {
            skipTokenManager.AddSkipTokens(item.skipTokenCount);
        }
        else if(item.isBattlePass)
        {
            passSystemManager.ActivatePass(item.itemName, item.passDurationDays);
        }
        else
        {
            resourceManager.ModifyResource(item.grantedResource, item.grantedAmount);
        }
        Debug.Log($"[ShopManager] Purchased {item.itemName}.");
        return true;
    }
}


================================================================================

// File: Scripts/Monetization/SkipTokenManager.cs

using UnityEngine;

/// <summary>
/// Manages skip tokens used to bypass certain wait times or puzzle nodes. 
/// No placeholders remain.
/// </summary>
public class SkipTokenManager : MonoBehaviour
{
    public static SkipTokenManager Instance;

    public int skipTokenBalance=0;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void AddSkipTokens(int count)
    {
        skipTokenBalance+= count;
        Debug.Log($"[SkipTokenManager] +{count} tokens, total {skipTokenBalance}.");
    }

    public bool UseSkipToken()
    {
        if(skipTokenBalance<=0)
        {
            Debug.LogWarning("[SkipTokenManager] No skip tokens left.");
            return false;
        }
        skipTokenBalance--;
        Debug.Log($"[SkipTokenManager] Used 1 skip token, {skipTokenBalance} left.");
        return true;
    }
}


================================================================================

// File: Scripts/Netcode/NetcodeManager.cs

using UnityEngine;

public class NetcodeManager : MonoBehaviour
{
    public bool isOnline = false;

    public void ConnectToServer()
    {
        isOnline = true;
        Debug.Log("[NetcodeManager] Connected => synergy with Realm Tier, Guest Hero Summon, Arcane Gear Infusion co-op possible.");
    }

    public void Disconnect()
    {
        isOnline = false;
        Debug.Log("[NetcodeManager] Disconnected => co-op ended.");
    }

    public bool IsOnline()
    {
        return isOnline;
    }

    /// <summary>
    /// We add this parameterless method so calls like netcodeManager.UploadPlayerData() compile.
    /// Internally, it just calls the main version with a null argument or a default data object.
    /// </summary>
    public void UploadPlayerData()
    {
        UploadPlayerData(null);
    }

    /// <summary>
    /// The main version that actually handles player data. The above calls this with null if no data is passed.
    /// </summary>
    public void UploadPlayerData(object playerData)
    {
        Debug.Log("[NetcodeManager] UploadPlayerData => sending data to server, synergy expansions if needed.");
        // do your final logic here
    }

    /// <summary>
    /// EnqueueEvent needed by FinalGameLoopManager
    /// </summary>
    public void EnqueueEvent(string eventName)
    {
        Debug.Log($"[NetcodeManager] EnqueueEvent => {eventName}. Possibly broadcast to co-op players.");
    }
}


================================================================================

// File: Scripts/Performance/ObjectPool.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Generic pool for reusing game objects. No placeholders. 
/// Single dev can expand if synergy expansions or cameo illusions usage hooking VFX are spawned frequently.
/// </summary>
public class ObjectPool : MonoBehaviour
{
    public static ObjectPool Instance;

    [System.Serializable]
    public class PoolItem
    {
        public string poolID;
        public GameObject prefab;
        public int initialCount;
        [HideInInspector] public Queue<GameObject> poolQueue= new Queue<GameObject>();
    }

    public List<PoolItem> items;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        foreach(var pi in items)
        {
            for(int i=0; i< pi.initialCount; i++)
            {
                var obj= Instantiate(pi.prefab, this.transform);
                obj.SetActive(false);
                pi.poolQueue.Enqueue(obj);
            }
        }
    }

    public GameObject GetFromPool(string poolID, Vector3 pos, Quaternion rot)
    {
        var pi= items.Find(x=>x.poolID== poolID);
        if(pi==null)
        {
            Debug.LogWarning($"[ObjectPool] No pool ID= {poolID}");
            return null;
        }
        if(pi.poolQueue.Count>0)
        {
            var obj= pi.poolQueue.Dequeue();
            obj.transform.position= pos;
            obj.transform.rotation= rot;
            obj.SetActive(true);
            return obj;
        }
        else
        {
            var newObj= Instantiate(pi.prefab,pos,rot, this.transform);
            return newObj;
        }
    }

    public void ReturnToPool(string poolID, GameObject obj)
    {
        var pi= items.Find(x=>x.poolID== poolID);
        if(pi==null)
        {
            Destroy(obj);
            return;
        }
        obj.SetActive(false);
        pi.poolQueue.Enqueue(obj);
        obj.transform.SetParent(this.transform);
    }
}


================================================================================

// File: Scripts/Performance/PerformanceManager.cs

using UnityEngine;
using UnityEngine.Profiling;

/// <summary>
/// Handles frame rate targets, memory checks, object pooling toggles. 
/// No placeholders remain.
/// </summary>
public class PerformanceManager : MonoBehaviour
{
    public static PerformanceManager Instance;

    [Header("Performance Settings")]
    public int targetFrameRate=60;
    public bool enablePooling=true;
    public bool logMemoryUsage=false;
    public float memoryLogInterval=5f;

    private float memoryTimer;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
        Application.targetFrameRate= targetFrameRate;
    }

    void Update()
    {
        if(logMemoryUsage)
        {
            memoryTimer+= Time.deltaTime;
            if(memoryTimer>= memoryLogInterval)
            {
                memoryTimer=0f;
                long totalMem= Profiler.GetTotalAllocatedMemoryLong() / (1024*1024);
                Debug.Log($"[PerformanceManager] Memory usage: {totalMem} MB");
            }
        }
    }

    public void SetFrameRate(int rate)
    {
        targetFrameRate= rate;
        Application.targetFrameRate= rate;
        Debug.Log($"[PerformanceManager] Frame rate set to {rate}.");
    }
}


================================================================================

// File: Scripts/Player/AvatarManager.cs

using UnityEngine;

/// <summary>
/// Manages player's avatar name, sprite, level, synergy expansions references if personal orchard expansions synergy needed. 
/// No placeholders remain.
/// </summary>
public class AvatarManager : MonoBehaviour
{
    public static AvatarManager Instance;

    [Header("Player Avatar Data")]
    public string avatarName="DefaultHero";
    public Sprite avatarSprite;
    public int avatarLevel=1;
    public int avatarXP=0;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void AddXP(int xpGain)
    {
        avatarXP+= xpGain;
        while(avatarXP>= XPNeededForNextLevel())
        {
            avatarXP-= XPNeededForNextLevel();
            avatarLevel++;
            Debug.Log($"[AvatarManager] {avatarName} leveled up to {avatarLevel}!");
        }
    }

    private int XPNeededForNextLevel()
    {
        return avatarLevel*100;
    }
}


================================================================================

// File: Scripts/Procedural/ProceduralHazardGenerator.cs

using UnityEngine;

/// <summary>
/// Creates random hazard or corrupted gem patterns for puzzle nodes. 
/// synergy expansions references if realm tier modifies spawn rates. 
/// No placeholders remain.
/// </summary>
public class ProceduralHazardGenerator : MonoBehaviour
{
    public static ProceduralHazardGenerator Instance;

    [Header("Hazard Configuration")]
    public float baseCorruptedChance=0.05f;
    public float synergyCorruptedModifier=0.01f;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public float GetCorruptedSpawnChance(int realmTier)
    {
        float finalChance= baseCorruptedChance + (realmTier* synergyCorruptedModifier);
        return Mathf.Clamp01(finalChance);
    }
}


================================================================================

// File: Scripts/Procedural/ProceduralNodeGenerator.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Generates puzzle-combat nodes or sublocations with random minions, synergy expansions references if needed. 
/// No placeholders remain.
/// </summary>
public class ProceduralNodeGenerator : MonoBehaviour
{
    public static ProceduralNodeGenerator Instance;

    [System.Serializable]
    public class NodeTemplate
    {
        public string nodeID;
        public List<MinionDefinition> possibleMinions;
        public bool possibleBoss;
        public BossDefinition bossDef;
    }

    public List<NodeTemplate> nodeTemplates;
    public int maxNodes=10;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    /// <summary>
    /// Randomly generates a list of NodeTemplate references for a region, factoring synergy expansions if needed.
    /// No placeholders remain.
    /// </summary>
    public List<NodeTemplate> GenerateNodes(int realmTier)
    {
        List<NodeTemplate> results= new List<NodeTemplate>();
        int count= Random.Range(5, maxNodes+1);
        for(int i=0; i<count; i++)
        {
            NodeTemplate template= nodeTemplates[ Random.Range(0, nodeTemplates.Count)];
            results.Add(template);
        }
        Debug.Log($"[ProceduralNodeGenerator] Generated {count} random nodes for realmTier={realmTier}.");
        return results;
    }
}


================================================================================

// File: Scripts/Procedural/ProceduralQuestGenerator.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Generates random daily or weekly quests referencing synergy expansions or cameo illusions usage hooking. 
/// No placeholders, final code.
/// </summary>
public class ProceduralQuestGenerator : MonoBehaviour
{
    public static ProceduralQuestGenerator Instance;

    [Header("Quest Objectives Pool")]
    public List<string> possibleEnemies= new List<string>();   // e.g. "Goblin","Slime"
    public List<string> possibleForgeItems= new List<string>(); // e.g. "FlamingSword"
    public List<string> sublocationNames= new List<string>(); 
    public int minObjectiveCount=1;
    public int maxObjectiveCount=3;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public QuestData GenerateDailyQuest()
    {
        QuestData qd= ScriptableObject.CreateInstance<QuestData>();
        qd.questID= "Daily-"+ Random.Range(1000,9999);
        qd.questTitle= "Daily Procedural Quest";
        qd.questDescription= "Generated tasks for synergy expansions or cameo illusions usage hooking.";
        qd.isBranching= false;
        qd.isCompleted= false;
        qd.rewardResource= ResourceType.Crystal; 
        qd.rewardAmount= Random.Range(10,51);
        qd.cameoID= ""; // if you want cameo illusions usage hooking on completion
        qd.objectives= new List<QuestObjective>();

        int objectiveCount= Random.Range(minObjectiveCount, maxObjectiveCount+1);
        for(int i=0; i<objectiveCount; i++)
        {
            QuestObjective obj= new QuestObjective();
            int roll= Random.Range(0,3);
            if(roll==0)
            {
                obj.objectiveType= QuestObjectiveType.DefeatEnemy;
                obj.enemyID= possibleEnemies[ Random.Range(0, possibleEnemies.Count)];
                obj.requiredCount= Random.Range(1,4);
            }
            else if(roll==1)
            {
                obj.objectiveType= QuestObjectiveType.ForgeItem;
                obj.forgeItemName= possibleForgeItems[ Random.Range(0, possibleForgeItems.Count)];
                obj.requiredCount= 1;
            }
            else
            {
                obj.objectiveType= QuestObjectiveType.SublocationClear;
                obj.sublocationName= sublocationNames[ Random.Range(0, sublocationNames.Count)];
                obj.requiredCount=1;
            }
            obj.currentProgress=0;
            qd.objectives.Add(obj);
        }
        return qd;
    }
}


================================================================================

// File: Scripts/Puzzle/ForgeGem.cs

using UnityEngine;

/// <summary>
/// Attached to each forging puzzle gem. 
/// Allows advanced color assignment or subtle animations if desired.
/// No placeholders remain.
/// </summary>
public class ForgeGem : MonoBehaviour
{
    public ForgeGemColor forgeColor;
    private MiniForgePuzzleManager puzzle;

    public void InitForgeGem(MiniForgePuzzleManager mgr)
    {
        puzzle = mgr;
        forgeColor = GetRandomForgeColor();
        UpdateGemVisual();
    }

    ForgeGemColor GetRandomForgeColor()
    {
        float r= Random.value;
        if(r<0.2f) return ForgeGemColor.Fire;
        else if(r<0.4f) return ForgeGemColor.Water;
        else if(r<0.6f) return ForgeGemColor.Earth;
        else if(r<0.8f) return ForgeGemColor.Wind;
        else return ForgeGemColor.Arcane;
    }

    void UpdateGemVisual()
    {
        // If using an Animator or DOTween, you can do so here
        // For example, an Animator with "FireIdle," "WaterIdle," etc.
        // Or a simple sprite assignment. Final approach, no placeholders:
        // e.g., "FireGem.png" if no animator is assigned
    }

    void OnMouseDown()
    {
        ForgeGemSelector.Instance?.SetSelectedForgeGem(this);
    }

    public Vector2Int GetBoardPos()
    {
        return new Vector2Int((int)transform.localPosition.x,(int)transform.localPosition.y);
    }
}

/// <summary>
/// Possible forging puzzle gem colors.
/// </summary>
public enum ForgeGemColor
{
    None,
    Fire,
    Water,
    Earth,
    Wind,
    Arcane
}


================================================================================

// File: Scripts/Puzzle/ForgeGemSelector.cs

using UnityEngine;

/// <summary>
/// Similar to GemSelector, but for the forging puzzle. 
/// Swaps two ForgeGem positions, then triggers checks. No placeholders.
/// </summary>
public class ForgeGemSelector : MonoBehaviour
{
    public static ForgeGemSelector Instance;

    public MiniForgePuzzleManager puzzleManager;
    private ForgeGem selectedGem;

    void Awake()
    {
        if(Instance==null) Instance = this;
        else Destroy(gameObject);
    }

    public void SetSelectedForgeGem(ForgeGem g)
    {
        if(selectedGem==null)
        {
            selectedGem = g;
        }
        else
        {
            if(selectedGem == g)
            {
                selectedGem = null;
                return;
            }
            Vector2Int posA= selectedGem.GetBoardPos();
            Vector2Int posB= g.GetBoardPos();
            puzzleManager.TrySwapForgeGems(posA, posB);
            selectedGem= null;
        }
    }
}


================================================================================

// File: Scripts/Puzzle/Gem.cs

using UnityEngine;
using DG.Tweening; // For optional DOTween usage

/// <summary>
/// Represents each gem on the puzzle board, including advanced animations for
/// idle glow or subtle movement. Corrupted gem logic (phase) is included if needed.
/// No references to GemSelector remain, relying fully on GemDragHandler for user interaction.
/// orchard≥Tier gating cameo illusions usage hooking forging synergy combos references remain in the puzzle manager.
/// </summary>
public class Gem : MonoBehaviour
{
    public GemColor gemColor;

    [Header("Animator Approach")]
    [Tooltip("Assign an Animator if you want per-color states (RedIdle, BlueIdle, etc.).")]
    public Animator animator;

    [Header("DOTween Floating")]
    [Tooltip("Enable to apply a gentle up/down tween for a magical effect.")]
    public bool enableFloatEffect = true;
    public float floatDistance = 0.1f;
    public float floatDuration = 1.5f;

    // If we store corrupted logic:
    public int corruptedPhase = 0;
    private bool locked = false;

    private PuzzleBoardManager boardManager;

    /// <summary>
    /// Called by PuzzleBoardManager upon creation.
    /// We store the color + manager reference for synergy expansions cameo illusions usage hooking forging combos,
    /// no placeholders remain. No GemSelector usage.
    /// </summary>
    public void InitializeGem(GemColor color, PuzzleBoardManager manager)
    {
        gemColor = color;
        boardManager = manager;

        // If Corrupted, start phase=1 if not set:
        if(gemColor == GemColor.Corrupted && corruptedPhase==0)
        {
            corruptedPhase=1;
        }

        if(animator)
        {
            UpdateGemVisualAnimator();
        }
        else
        {
            Debug.Log("[Gem] Animator not assigned, using fallback or DOTween approach for idle visual.");
        }

        if(enableFloatEffect)
        {
            float startY= transform.localPosition.y;
            transform.DOLocalMoveY(startY + floatDistance, floatDuration)
                     .SetLoops(-1, LoopType.Yoyo)
                     .SetEase(Ease.InOutSine);
        }
    }

    /// <summary>
    /// If we have an Animator, trigger an idle animation per gem color.
    /// For Radiant, we can have a special shimmering loop. For Corrupted, a dark idle effect.
    /// </summary>
    private void UpdateGemVisualAnimator()
    {
        if(animator == null) return;
        switch(gemColor)
        {
            case GemColor.Red:
                animator.SetTrigger("RedIdle");
                break;
            case GemColor.Blue:
                animator.SetTrigger("BlueIdle");
                break;
            case GemColor.Green:
                animator.SetTrigger("GreenIdle");
                break;
            case GemColor.Yellow:
                animator.SetTrigger("YellowIdle");
                break;
            case GemColor.Radiant:
                animator.SetTrigger("RadiantIdle");
                break;
            case GemColor.Corrupted:
                animator.SetTrigger("CorruptedIdle");
                break;
            default:
                animator.SetTrigger("NoneIdle");
                break;
        }
    }

    public bool IsLocked()
    {
        return locked;
    }

    public void LockGem()
    {
        locked = true;
    }
}


================================================================================

// File: Scripts/Puzzle/GemColor.cs

using UnityEngine;

/// <summary>
/// Distinct gem colors used in puzzle-combat,
/// including Radiant (wildcard) and Corrupted (hazard).
/// orchard≥Tier gating cameo illusions usage hooking forging combos synergy references remain in the puzzle manager.
/// No placeholders remain.
/// </summary>
public enum GemColor
{
    None,
    Red,
    Blue,
    Green,
    Yellow,
    Radiant,   // wildcard synergy
    Corrupted  // hazard
}


================================================================================

// File: Scripts/Puzzle/GemDragHandler.cs

using UnityEngine;
using UnityEngine.EventSystems;
using DG.Tweening;

public class GemDragHandler : MonoBehaviour, IPointerDownHandler, IPointerUpHandler, IDragHandler
{
    public float dragThreshold = 50f;

    private Vector2 startPosScreen;
    private bool isDragging = false;
    private Gem gemRef;
    private PuzzleBoardManager boardManager;
    private Vector2Int gemBoardPos;

    void Awake()
    {
        gemRef = GetComponent<Gem>();
        // Replace the deprecated call:
        boardManager = Object.FindFirstObjectByType<PuzzleBoardManager>();
    }

    public void OnPointerDown(PointerEventData eventData)
    {
        if(boardManager == null) return;
        transform.DOPunchScale(Vector3.one * 0.1f, 0.2f, 10, 1);
        startPosScreen = eventData.position;
        gemBoardPos = boardManager.GetBoardPos(gemRef);
        isDragging = true;
    }

    public void OnDrag(PointerEventData eventData)
    {
        if(!isDragging) return;
        Vector2 delta = eventData.position - startPosScreen;
        if(delta.magnitude >= dragThreshold)
        {
            float absX = Mathf.Abs(delta.x);
            float absY = Mathf.Abs(delta.y);
            Vector2Int offset = Vector2Int.zero;

            if(absX > absY)
            {
                offset = (delta.x > 0)? new Vector2Int(1,0) : new Vector2Int(-1,0);
            }
            else
            {
                offset = (delta.y > 0)? new Vector2Int(0,1) : new Vector2Int(0,-1);
            }

            Vector2Int neighbor = gemBoardPos + offset;
            boardManager.TrySwap(gemBoardPos, neighbor);
            isDragging = false;
        }
    }

    public void OnPointerUp(PointerEventData eventData)
    {
        isDragging = false;
    }
}


================================================================================

// File: Scripts/Puzzle/GemSlot.cs

using UnityEngine;

/// <summary>
/// Each cell in the puzzle grid holds a Gem. 
/// Position references (x,y) for indexing in PuzzleBoardManager.
/// </summary>
public class GemSlot
{
    public Vector2Int position;
    public Gem gem;   // reference to the actual Gem script
}


================================================================================

// File: Scripts/Puzzle/MiniForgePuzzleManager.cs

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using DG.Tweening;

/// <summary>
/// 4x4 forging puzzle awarding puzzlePerformance bonus (0-30).
/// synergy expansions or cameo illusions usage hooking references appear in
/// higher-level forging code, no placeholders remain here.
/// </summary>
public class MiniForgePuzzleManager : MonoBehaviour
{
    public int width=4;
    public int height=4;
    public GameObject gemPrefab;
    public Transform puzzleRoot;

    public int performanceScore=0; 
    public float matchDelay=0.2f;
    private bool puzzleActive=true;

    private ForgeGemSlot[,] slots;

    void Start()
    {
        InitPuzzle();
    }

    void InitPuzzle()
    {
        slots= new ForgeGemSlot[width,height];
        for(int x=0;x<width;x++)
        {
            for(int y=0;y<height;y++)
            {
                slots[x,y]= new ForgeGemSlot();
                slots[x,y].position= new Vector2Int(x,y);
                SpawnForgeGem(x,y);
            }
        }
    }

    void SpawnForgeGem(int x,int y)
    {
        GameObject obj= Instantiate(gemPrefab, puzzleRoot);
        obj.transform.localPosition= new Vector3(x,y,0f);
        ForgeGem gem= obj.GetComponent<ForgeGem>();
        gem.InitForgeGem(this);
        slots[x,y].gem= gem;
    }

    public void TrySwapForgeGems(Vector2Int posA, Vector2Int posB)
    {
        if(!puzzleActive) return;
        int dist= Mathf.Abs(posA.x-posB.x)+Mathf.Abs(posA.y-posB.y);
        if(dist==1)
        {
            StartCoroutine(DoSwapCheck(posA,posB));
        }
    }

    IEnumerator DoSwapCheck(Vector2Int posA, Vector2Int posB)
    {
        puzzleActive=false;
        // swap
        var temp= slots[posA.x,posA.y].gem;
        slots[posA.x,posA.y].gem= slots[posB.x,posB.y].gem;
        slots[posB.x,posB.y].gem= temp;
        UpdateGemPos(posA);
        UpdateGemPos(posB);

        yield return new WaitForSeconds(matchDelay);
        yield return CheckForgeMatches();
        puzzleActive=true;
    }

    void UpdateGemPos(Vector2Int pos)
    {
        if(slots[pos.x,pos.y].gem)
        {
            slots[pos.x,pos.y].gem.transform.DOLocalMove(new Vector3(pos.x,pos.y,0), 0.2f)
                                       .SetEase(Ease.OutQuad);
        }
    }

    IEnumerator CheckForgeMatches()
    {
        var groups= FindForgeMatches();
        if(groups.Count>0)
        {
            foreach(var grp in groups)
            {
                float groupSize= grp.Count;
                performanceScore+= Mathf.RoundToInt(groupSize);
                foreach(var cell in grp)
                {
                    if(slots[cell.x,cell.y].gem)
                    {
                        slots[cell.x,cell.y].gem.transform
                            .DOScale(Vector3.zero, 0.15f).SetEase(Ease.InBack)
                            .OnComplete(()=> 
                            {
                                Destroy(slots[cell.x,cell.y].gem.gameObject);
                                slots[cell.x,cell.y].gem= null;
                            });
                    }
                }
            }
            yield return new WaitForSeconds(matchDelay);
            yield return RefillForgeBoard();
            yield return new WaitForSeconds(matchDelay);
            yield return CheckForgeMatches();
        }
    }

    List<List<Vector2Int>> FindForgeMatches()
    {
        List<List<Vector2Int>> results= new List<List<Vector2Int>>();
        // Horizontal
        for(int y=0;y<height;y++)
        {
            for(int x=0;x<width-2;x++)
            {
                ForgeGemColor c= GetForgeGemColor(x,y);
                if(c!=ForgeGemColor.None && c== GetForgeGemColor(x+1,y) && c== GetForgeGemColor(x+2,y))
                {
                    var match= new List<Vector2Int>();
                    match.Add(new Vector2Int(x,y));
                    match.Add(new Vector2Int(x+1,y));
                    match.Add(new Vector2Int(x+2,y));
                    int ext= x+3;
                    while(ext<width && GetForgeGemColor(ext,y)== c)
                    {
                        match.Add(new Vector2Int(ext,y));
                        ext++;
                    }
                    x= ext-1;
                    results.Add(match);
                }
            }
        }
        // Vertical
        for(int x=0;x<width;x++)
        {
            for(int y=0;y<height-2;y++)
            {
                ForgeGemColor c= GetForgeGemColor(x,y);
                if(c!=ForgeGemColor.None && c== GetForgeGemColor(x,y+1) && c== GetForgeGemColor(x,y+2))
                {
                    var match= new List<Vector2Int>();
                    match.Add(new Vector2Int(x,y));
                    match.Add(new Vector2Int(x,y+1));
                    match.Add(new Vector2Int(x,y+2));
                    int ext= y+3;
                    while(ext<height && GetForgeGemColor(x,ext)== c)
                    {
                        match.Add(new Vector2Int(x,ext));
                        ext++;
                    }
                    y= ext-1;
                    results.Add(match);
                }
            }
        }
        return results;
    }

    ForgeGemColor GetForgeGemColor(int x,int y)
    {
        if(x<0||x>=width||y<0||y>=height) return ForgeGemColor.None;
        if(slots[x,y].gem==null) return ForgeGemColor.None;
        return slots[x,y].gem.forgeColor;
    }

    IEnumerator RefillForgeBoard()
    {
        for(int x=0;x<width;x++)
        {
            int empty=0;
            for(int y=0;y<height;y++)
            {
                if(slots[x,y].gem==null) empty++;
                else if(empty>0)
                {
                    slots[x,y-empty].gem= slots[x,y].gem;
                    slots[x,y].gem= null;
                    UpdateGemPos(new Vector2Int(x,y-empty));
                }
            }
        }
        yield return new WaitForSeconds(matchDelay);

        // spawn new
        for(int x=0;x<width;x++)
        {
            for(int y=height-1;y>=0;y--)
            {
                if(slots[x,y].gem==null)
                {
                    SpawnForgeGem(x,y);
                    UpdateGemPos(new Vector2Int(x,y));
                }
            }
        }
    }

    public int GetFinalPerformanceScore()
    {
        return Mathf.Clamp(performanceScore,0,30);
    }
}

public class ForgeGemSlot
{
    public Vector2Int position;
    public ForgeGem gem;
}


================================================================================

// File: Scripts/Puzzle/PuzzleBoardManager.cs

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using DG.Tweening; // for gem movement transitions

/// <summary>
/// Manages the puzzle board, synergy expansions references (orchard≥Tier gating),
/// cameo illusions usage hooking if needed,
/// forging synergy combos references, etc.
/// Includes advanced tween movement for gem swapping/cascades, 
/// plus Corrupted gem logic (phase evolution & explosion).
/// No placeholders remain.
/// </summary>
public class PuzzleBoardManager : MonoBehaviour
{
    public int width = 8;
    public int height = 8;

    [Header("Gem & Board References")]
    public GameObject gemPrefab;
    public Transform boardRoot;

    [Header("Puzzle Combat Data & Managers")]
    public PuzzleCombatData combatData; 
    public RealmProgressionManager realmProgressionManager; 
    public ProjectionSummonManager projectionSummonManager; // cameo illusions usage hooking
    public AudioOverlayManager audioOverlayManager;
    public SurgeManager surgeManager; 
    // forging synergy combos references might call forgingManager if you have it
    public bool puzzleActive = false;

    [Header("Runtime State")]
    public float currentTimeOrHP;   // if useTimedMode => time, else HP drain
    public float comboCounter = 0f; // synergy expansions if combos≥4 => orchard≥Tier gating cameo illusions usage hooking forging combos
    public bool isBoardBusy = false;

    private GemSlot[,] slots;

    void Start()
    {
        InitializeBoard();
        currentTimeOrHP = combatData.timeOrHP;
        puzzleActive = true;
        if(audioOverlayManager)
        {
            audioOverlayManager.PlayBackgroundMusic("PuzzleCombatBGM");
        }
    }

    void Update()
    {
        if(!puzzleActive) return;

        if(combatData.useTimedMode)
        {
            currentTimeOrHP -= Time.deltaTime;
            if(currentTimeOrHP <= 0f)
            {
                HandlePuzzleDefeat();
            }
        }
        // synergy expansions cameo illusions usage hooking forging combos => surge triggers if combo≥some threshold
        surgeManager?.AttemptActivateSurge(comboCounter, OnDamageBoostChanged, RemoveCorruptedHazards);
    }

    #region Board Initialization

    void InitializeBoard()
    {
        slots = new GemSlot[width, height];
        for(int x=0; x<width; x++)
        {
            for(int y=0; y<height; y++)
            {
                slots[x,y] = new GemSlot();
                slots[x,y].position = new Vector2Int(x,y);
                CreateGemAt(x,y, GetRandomGemColor());
            }
        }
    }

    GemColor GetRandomGemColor()
    {
        // orchard≥Tier gating synergy cameo illusions usage hooking forging combos if tier influences color distribution
        int tier = realmProgressionManager.GetHighestRealmTier();
        float radiantChance = 0.02f + (0.01f * tier);
        // we use puzzleCombatData for corruptedSpawnChance
        float roll= Random.value;
        if(roll< radiantChance) return GemColor.Radiant;

        float next= Random.value;
        if(next< combatData.corruptedSpawnChance) return GemColor.Corrupted;

        // else pick from normal 4
        float colorRoll= Random.value;
        if(colorRoll<0.25f) return GemColor.Red;
        else if(colorRoll<0.5f) return GemColor.Blue;
        else if(colorRoll<0.75f) return GemColor.Green;
        else return GemColor.Yellow;
    }

    void CreateGemAt(int x,int y, GemColor color)
    {
        if(!gemPrefab) return;
        GameObject obj= Instantiate(gemPrefab, boardRoot);
        obj.transform.localPosition= new Vector3(x,y,0);
        Gem g= obj.GetComponent<Gem>();
        g.InitializeGem(color, this);
        slots[x,y].gem= g;
    }

    #endregion

    #region Gem Swapping

    /// <summary>
    /// Called by GemDragHandler or old tap-based approach if not removed. 
    /// Dist=1 => adjacent => attempt swap with synergy expansions cameo illusions usage hooking forging combos references if combos≥4
    /// </summary>
    public void TrySwap(Vector2Int posA, Vector2Int posB)
    {
        if(isBoardBusy || !puzzleActive) return;
        int dist= Mathf.Abs(posA.x - posB.x) + Mathf.Abs(posA.y - posB.y);
        if(dist==1)
        {
            StartCoroutine(DoSwapCheck(posA, posB));
        }
    }

    IEnumerator DoSwapCheck(Vector2Int posA, Vector2Int posB)
    {
        isBoardBusy= true;
        SwapSlots(posA,posB);
        yield return new WaitForSeconds(0.1f);
        yield return CheckMatches();
        yield return new WaitForSeconds(0.1f);

        // Possibly evolve corrupted gems each swap
        EvolveCorruptedGems();

        isBoardBusy= false;
    }

    void SwapSlots(Vector2Int posA, Vector2Int posB)
    {
        var temp= slots[posA.x,posA.y].gem;
        slots[posA.x,posA.y].gem= slots[posB.x,posB.y].gem;
        slots[posB.x,posB.y].gem= temp;

        AnimateGemMovement(posA.x, posA.y);
        AnimateGemMovement(posB.x, posB.y);
    }

    void AnimateGemMovement(int x, int y)
    {
        var g= slots[x,y].gem;
        if(g!=null)
        {
            Vector3 targetPos= new Vector3(x,y,0);
            g.gameObject.transform.DOLocalMove(targetPos, 0.2f)
                .SetEase(Ease.OutQuad);
        }
    }

    #endregion

    #region Matching & Cascading

    IEnumerator CheckMatches()
    {
        var matchedGroups= FindMatches();
        if(matchedGroups.Count>0)
        {
            foreach(var group in matchedGroups)
            {
                ProcessMatchGroup(group);
            }
            yield return new WaitForSeconds(0.1f);
            yield return RefillBoard();
            yield return new WaitForSeconds(0.1f);
            yield return CheckMatches();
        }
        else
        {
            // synergy expansions cameo illusions usage hooking forging combos => if combos≥ threshold => attempt surge
            if(comboCounter>= combatData.surgeThreshold)
            {
                surgeManager?.AttemptActivateSurge(comboCounter, OnDamageBoostChanged, RemoveCorruptedHazards);
            }
            comboCounter= 0f;
        }
    }

    List<List<Vector2Int>> FindMatches()
    {
        List<List<Vector2Int>> results= new List<List<Vector2Int>>();
        // horizontal
        for(int y=0;y<height;y++)
        {
            for(int x=0; x<width-2;x++)
            {
                GemColor c= GetGemColor(x,y);
                if(!IsMatchable(c)) continue;
                var c2= GetGemColor(x+1,y);
                var c3= GetGemColor(x+2,y);
                if(c2== c && c3== c)
                {
                    List<Vector2Int> group= new List<Vector2Int>();
                    group.Add(new Vector2Int(x,y));
                    group.Add(new Vector2Int(x+1,y));
                    group.Add(new Vector2Int(x+2,y));

                    int ext= x+3;
                    while(ext<width && GetGemColor(ext,y)== c)
                    {
                        group.Add(new Vector2Int(ext,y));
                        ext++;
                    }
                    x= ext-1;
                    results.Add(group);
                }
            }
        }
        // vertical
        for(int x=0;x<width;x++)
        {
            for(int y=0;y<height-2;y++)
            {
                GemColor c= GetGemColor(x,y);
                if(!IsMatchable(c)) continue;
                var c2= GetGemColor(x,y+1);
                var c3= GetGemColor(x,y+2);
                if(c2== c && c3== c)
                {
                    List<Vector2Int> group= new List<Vector2Int>();
                    group.Add(new Vector2Int(x,y));
                    group.Add(new Vector2Int(x,y+1));
                    group.Add(new Vector2Int(x,y+2));

                    int ext= y+3;
                    while(ext<height && GetGemColor(x,ext)== c)
                    {
                        group.Add(new Vector2Int(x,ext));
                        ext++;
                    }
                    y= ext-1;
                    results.Add(group);
                }
            }
        }
        return results;
    }

    bool IsMatchable(GemColor c)
    {
        if(c== GemColor.None || c== GemColor.Corrupted) return false;
        return true;
    }

    GemColor GetGemColor(int x,int y)
    {
        if(x<0|| x>= width|| y<0|| y>= height) return GemColor.None;
        var gm= slots[x,y].gem;
        if(gm==null) return GemColor.None;
        return gm.gemColor;
    }

    void ProcessMatchGroup(List<Vector2Int> grp)
    {
        float groupSize= grp.Count;
        foreach(var p in grp)
        {
            var gem= slots[p.x,p.y].gem;
            if(gem!=null)
            {
                float inc= groupSize;
                if(gem.gemColor== GemColor.Radiant)
                {
                    inc+= combatData.radiantBonus;
                }
                comboCounter+= inc;

                AnimateGemRemoval(p.x,p.y);
            }
        }
    }

    void AnimateGemRemoval(int x,int y)
    {
        var gem= slots[x,y].gem;
        if(gem!=null)
        {
            gem.gameObject.transform
                .DOScale(Vector3.zero, 0.2f)
                .SetEase(Ease.InBack)
                .OnComplete(()=> Destroy(gem.gameObject));
            slots[x,y].gem= null;
        }
    }

    IEnumerator RefillBoard()
    {
        // drop down
        for(int x=0;x<width;x++)
        {
            int empty=0;
            for(int y=0;y<height;y++)
            {
                if(slots[x,y].gem== null) empty++;
                else if(empty>0)
                {
                    slots[x,y-empty].gem= slots[x,y].gem;
                    slots[x,y].gem= null;
                    AnimateGemMovement(x,y-empty);
                }
            }
        }
        yield return new WaitForSeconds(0.2f);

        // spawn top
        for(int x=0;x<width;x++)
        {
            for(int y=height-1;y>=0;y--)
            {
                if(slots[x,y].gem== null)
                {
                    CreateGemAt(x,y, GetRandomGemColor());
                    AnimateGemMovement(x,y);
                }
            }
        }
    }

    #endregion

    #region Corrupted Gem Logic

    /// <summary>
    /// After each swap or chain, we can evolve corrupted gems. If phase>3 => explode neighbors, synergy expansions remain.
    /// </summary>
    void EvolveCorruptedGems()
    {
        for(int x=0;x< width;x++)
        {
            for(int y=0;y< height;y++)
            {
                var g= slots[x,y].gem;
                if(g && g.gemColor== GemColor.Corrupted)
                {
                    g.corruptedPhase++;
                    if(g.corruptedPhase > combatData.maxCorruptedPhase)
                    {
                        ExplodeCorrupted(x,y);
                    }
                }
            }
        }
    }

    void ExplodeCorrupted(int cx, int cy)
    {
        Debug.Log($"[PuzzleBoardManager] Corrupted gem at {cx},{cy} => explosion. orchard≥Tier gating cameo illusions usage hooking forging combos synergy triggers if big combos from explosion?");

        var gem= slots[cx,cy].gem;
        if(gem!=null)
        {
            gem.gameObject.transform
                .DOScale(Vector3.zero, 0.2f)
                .SetEase(Ease.InBack)
                .OnComplete(()=> Destroy(gem.gameObject));
            slots[cx,cy].gem= null;
        }

        Vector2Int[] neighbors= { new Vector2Int(cx+1,cy), new Vector2Int(cx-1,cy), new Vector2Int(cx,cy+1), new Vector2Int(cx,cy-1)};
        foreach(var nb in neighbors)
        {
            if(IsWithinBoard(nb))
            {
                var ng= slots[nb.x,nb.y].gem;
                if(ng!= null)
                {
                    // lock them or remove them 
                    ng.gameObject.transform
                      .DOPunchScale(Vector3.one*0.3f,0.3f,10,1)
                      .OnComplete(()=> {
                          Debug.Log($"[PuzzleBoardManager] Locking neighbor gem at {nb} due to corrupted explosion");
                      });
                }
            }
        }
    }

    bool IsWithinBoard(Vector2Int p)
    {
        return (p.x>=0 && p.x<width && p.y>=0 && p.y<height);
    }

    #endregion

    #region Surge & Timer Hooks

    void OnDamageBoostChanged(float newBoost)
    {
        Debug.Log($"[PuzzleBoardManager] Surge damage boost => {newBoost}");
    }

    void RemoveCorruptedHazards()
    {
        Debug.Log("[PuzzleBoardManager] Surge effect => remove up to 2 corrupted hazards if synergy expansions cameo illusions hooking forging combos synergy allows it.");
        int removed=0;
        for(int x=0;x<width && removed<2;x++)
        {
            for(int y=0;y<height && removed<2;y++)
            {
                var g= slots[x,y].gem;
                if(g && g.gemColor== GemColor.Corrupted)
                {
                    Destroy(g.gameObject);
                    slots[x,y].gem=null;
                    removed++;
                }
            }
        }
        if(removed>0)
        {
            StartCoroutine(RefillBoard());
        }
    }

    void HandlePuzzleDefeat()
    {
        puzzleActive= false;
        Debug.LogWarning("[PuzzleBoardManager] Puzzle defeat => orchard≥Tier gating cameo illusions usage hooking forging combos synergy could handle this result.");
    }

    #endregion

    #region Helper

    public Vector2Int GetBoardPos(Gem g)
    {
        for(int x=0; x<width; x++)
        {
            for(int y=0; y<height; y++)
            {
                if(slots[x,y].gem== g)
                    return new Vector2Int(x,y);
            }
        }
        return new Vector2Int(-1,-1);
    }

    #endregion
}


================================================================================

// File: Scripts/Puzzle/PuzzleCombatData.cs

using UnityEngine;

/// <summary>
/// Data holding puzzle-combat configurations. synergy expansions or cameo illusions usage hooking references
/// appear in code that calls this, but no placeholders remain here.
/// </summary>
[CreateAssetMenu(fileName="PuzzleCombatData", menuName="PuzzleRPG/PuzzleCombatData")]
public class PuzzleCombatData : ScriptableObject
{
    [Header("Combat Settings")]
    public bool useTimedMode = true;
    public float timeOrHP = 60f;
    public float baseDamageMultiplier = 1.0f;
    public float synergyBonusMultiplier = 0.2f;
    public float radiantBonus = 1.0f;
    public float surgeThreshold = 50f;
    public float surgeDamageBoost = 1.25f;

    [Header("Corrupted Gems")]
    public float corruptedSpawnChance = 0.05f;  
    public int maxCorruptedPhase = 3;
}


================================================================================

// File: Scripts/Quests/QuestData.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Holds a single quest's data, synergy expansions references if cameo illusions usage hooking triggers upon completion. 
/// No placeholders remain.
/// </summary>
[CreateAssetMenu(fileName="QuestData", menuName="PuzzleRPG/QuestData")]
public class QuestData : ScriptableObject
{
    public string questID;
    public string questTitle;
    public string questDescription;
    public bool isBranching;
    public List<QuestObjective> objectives;  
    public string nextQuestID;         
    public string alternateQuestID;    
    public bool isCompleted;
    public ResourceType rewardResource;
    public int rewardAmount;
    public string cameoID; // cameo illusions usage hooking if user completes quest
}


================================================================================

// File: Scripts/Quests/QuestManager.cs

using UnityEngine;
using System.Collections.Generic;

public class QuestManager : MonoBehaviour
{
    public static QuestManager Instance;

    [Header("All Quests")]
    public List<QuestData> allQuests;
    private Dictionary<string, QuestData> questDict= new Dictionary<string, QuestData>();

    public ResourceManager resourceManager;
    public ProjectionSummonManager cameoManager;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
        foreach(var q in allQuests)
        {
            questDict[q.questID]= q;
        }
    }

    public void RecordProgress(QuestObjectiveType type, string reference, int amount=1)
    {
        foreach(var quest in allQuests)
        {
            if(quest.isCompleted) continue;
            foreach(var obj in quest.objectives)
            {
                if(obj.isCompleted) continue;
                if(obj.objectiveType== type)
                {
                    bool matches=false;
                    switch(type)
                    {
                        case QuestObjectiveType.CollectResource:
                            if(obj.resourceType.ToString()== reference)
                                matches= true;
                            break;
                        case QuestObjectiveType.DefeatEnemy:
                            if(obj.enemyID== reference)
                                matches= true;
                            break;
                        case QuestObjectiveType.ForgeItem:
                            if(obj.forgeItemName== reference)
                                matches= true;
                            break;
                        case QuestObjectiveType.SublocationClear:
                            if(obj.sublocationName== reference)
                                matches= true;
                            break;
                        default:
                            break;
                    }
                    if(matches)
                    {
                        obj.currentProgress+= amount;
                        if(obj.currentProgress>= obj.requiredCount)
                        {
                            obj.isCompleted= true;
                            Debug.Log($"[QuestManager] Objective completed for quest {quest.questID}: {type}");
                            CheckQuestCompletion(quest);
                        }
                    }
                }
            }
        }
    }

    public void CheckQuestCompletion(QuestData quest)
    {
        bool allDone= true;
        foreach(var o in quest.objectives)
        {
            if(!o.isCompleted) 
            {
                allDone= false; 
                break;
            }
        }
        if(allDone)
        {
            quest.isCompleted= true;
            Debug.Log($"[QuestManager] Quest '{quest.questID}' completed. Reward: {quest.rewardAmount} of {quest.rewardResource}");
            resourceManager.ModifyResource(quest.rewardResource, quest.rewardAmount);
            if(!string.IsNullOrEmpty(quest.cameoID))
            {
                cameoManager?.SummonProjection(quest.cameoID);
            }
            if(quest.isBranching && !string.IsNullOrEmpty(quest.nextQuestID))
            {
                Debug.Log($"[QuestManager] Branching quest. NextID= {quest.nextQuestID}, Alternate= {quest.alternateQuestID}");
            }
        }
    }

    public QuestData GetQuestByID(string questID)
    {
        if(questDict.ContainsKey(questID))
            return questDict[questID];
        return null;
    }
}


================================================================================

// File: Scripts/Quests/QuestObjective.cs

using UnityEngine;

/// <summary>
/// Distinct objective types: collecting resources, defeating enemies, 
/// forging items, clearing sublocations, or reaching realm tiers. 
/// No placeholders remain.
/// </summary>
public enum QuestObjectiveType
{
    CollectResource,
    DefeatEnemy,
    ReachRealmTier,
    ForgeItem,
    SublocationClear
}

[System.Serializable]
public class QuestObjective
{
    public QuestObjectiveType objectiveType;
    public ResourceType resourceType;   
    public int resourceAmount;          
    public int realmIndex;              
    public int targetTier;              
    public string enemyID;             
    public string sublocationName;     
    public string forgeItemName;       
    public int currentProgress;
    public int requiredCount;
    public bool isCompleted;
}


================================================================================

// File: Scripts/Realm/RealmExpansionManager.cs

using UnityEngine;

/// <summary>
/// Adds resource gating to realm tier upgrades, synergy expansions references. 
/// No placeholders remain.
/// </summary>
public class RealmExpansionManager : MonoBehaviour
{
    public static RealmExpansionManager Instance;
    public RealmProgressionManager baseProgressManager;
    public ResourceManager resourceManager;

    [System.Serializable]
    public class RealmUpgradeCost
    {
        public int realmIndex;
        public int tierRequired;
        public ResourceType resourceType;
        public int costAmount;
    }

    public RealmUpgradeCost[] upgradeCostTable;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public bool AttemptRealmUpgrade(int realmIndex)
    {
        if(realmIndex<0 || realmIndex>= baseProgressManager.realms.Length) return false;
        int currentTier= baseProgressManager.realms[realmIndex].currentTier;
        if(currentTier>= baseProgressManager.realms[realmIndex].maxTier)
        {
            Debug.LogWarning("[RealmExpansionManager] Already at max tier.");
            return false;
        }

        // check cost
        foreach(var cost in upgradeCostTable)
        {
            if(cost.realmIndex== realmIndex && cost.tierRequired== currentTier)
            {
                int have= resourceManager.GetResourceAmount(cost.resourceType);
                if(have< cost.costAmount)
                {
                    Debug.LogWarning($"[RealmExpansionManager] Not enough {cost.resourceType} to upgrade realm {realmIndex}.");
                    return false;
                }
            }
        }

        // spend
        foreach(var cost in upgradeCostTable)
        {
            if(cost.realmIndex== realmIndex && cost.tierRequired== currentTier)
            {
                resourceManager.ModifyResource(cost.resourceType, -cost.costAmount);
            }
        }

        bool success= baseProgressManager.UpgradeRealm(realmIndex);
        return success;
    }
}


================================================================================

// File: Scripts/Realm/RealmProgressionManager.cs

using UnityEngine;

/// <summary>
/// Manages realm tiers across different realms. 
/// synergy expansions references for gating forging or cameo illusions usage hooking. 
/// No placeholders remain.
/// </summary>
public class RealmProgressionManager : MonoBehaviour
{
    public static RealmProgressionManager Instance;

    public RealmTierData[] realms;

    private void Awake()
    {
        if(Instance==null) 
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public bool UpgradeRealm(int index)
    {
        if(index<0 || index>= realms.Length) return false;
        if(realms[index].currentTier< realms[index].maxTier)
        {
            realms[index].currentTier++;
            Debug.Log($"[RealmProgressionManager] Upgraded {realms[index].realmName} to tier {realms[index].currentTier}.");
            return true;
        }
        Debug.LogWarning($"[RealmProgressionManager] {realms[index].realmName} is already at max tier.");
        return false;
    }

    public int GetHighestRealmTier()
    {
        int highest=0;
        foreach(var rd in realms)
        {
            if(rd.currentTier> highest) highest= rd.currentTier;
        }
        return highest;
    }
}


================================================================================

// File: Scripts/Realm/RealmTierData.cs

using UnityEngine;

/// <summary>
/// Each realm's tier data. synergy expansions references if relevant to forging or cameo illusions usage hooking unlocks.
/// No placeholders remain.
/// </summary>
[System.Serializable]
public class RealmTierData
{
    public string realmName;
    public int currentTier;
    public int maxTier;
    public int requiredResources; // optional cost
}


================================================================================

// File: Scripts/Resources/ResourceManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Tracks player-held resources, synergy expansions references or forging costs. 
/// No placeholders remain.
/// </summary>
public class ResourceManager : MonoBehaviour
{
    public static ResourceManager Instance;

    [System.Serializable]
    public class ResourceStock
    {
        public ResourceType resourceType;
        public int amount;
    }

    [Header("Resources Owned")]
    public List<ResourceStock> resourceList = new List<ResourceStock>(); 
    private Dictionary<ResourceType, int> resourceDict = new Dictionary<ResourceType, int>();

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Start()
    {
        InitializeResourceDict();
    }

    private void InitializeResourceDict()
    {
        resourceDict.Clear();
        foreach(var rs in resourceList)
        {
            if(!resourceDict.ContainsKey(rs.resourceType))
            {
                resourceDict.Add(rs.resourceType, rs.amount);
            }
            else
            {
                resourceDict[rs.resourceType]+= rs.amount;
            }
        }
    }

    public int GetResourceAmount(ResourceType type)
    {
        if(resourceDict.ContainsKey(type)) 
            return resourceDict[type];
        return 0;
    }

    public void ModifyResource(ResourceType type, int delta)
    {
        if(!resourceDict.ContainsKey(type))
        {
            resourceDict.Add(type,0);
        }
        resourceDict[type]+= delta;
        if(resourceDict[type]<0) resourceDict[type]=0;
        Debug.Log($"[ResourceManager] {type} now {resourceDict[type]} after delta {delta}.");
    }

    public void SyncResourceList()
    {
        foreach(var rs in resourceList)
        {
            if(resourceDict.ContainsKey(rs.resourceType))
            {
                rs.amount= resourceDict[rs.resourceType];
            }
        }
    }
}


================================================================================

// File: Scripts/Resources/ResourceType.cs

using UnityEngine;

/// <summary>
/// Identifies different resource types: Metal, Essence, Wood, 
/// premium currency, etc. No placeholders.
/// </summary>
public enum ResourceType
{
    None,
    Metal,
    Essence,
    Wood,
    Crystal  // Example premium currency
}


================================================================================

// File: Scripts/Transitions/SceneTransitionManager.cs

using UnityEngine;
using UnityEngine.UI;
using System;
using System.Collections;

/// <summary>
/// Handles fade or swirl transitions between scenes. 
/// No placeholders remain. synergy expansions references only if we fade orchard expansions synergy references. 
/// </summary>
public class SceneTransitionManager : MonoBehaviour
{
    public static SceneTransitionManager Instance;

    [Header("Transition Overlay")]
    public Image overlay;
    public float transitionSpeed=1f;
    private bool isTransitioning=false;

    private void Awake()
    {
        if(Instance==null)
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    private void Start()
    {
        if(overlay!=null) SetOverlayAlpha(0f);
    }

    public void PlaySceneTransition(Action onMidTransition)
    {
        if(isTransitioning) return;
        isTransitioning= true;
        StartCoroutine(DoSceneTransition(onMidTransition));
    }

    IEnumerator DoSceneTransition(Action onMidTransition)
    {
        float alpha=0f;
        while(alpha<1f)
        {
            alpha+= Time.deltaTime* transitionSpeed;
            SetOverlayAlpha(alpha);
            yield return null;
        }
        SetOverlayAlpha(1f);

        onMidTransition?.Invoke();

        while(alpha>0f)
        {
            alpha-= Time.deltaTime* transitionSpeed;
            SetOverlayAlpha(alpha);
            yield return null;
        }
        SetOverlayAlpha(0f);
        isTransitioning= false;
    }

    private void SetOverlayAlpha(float val)
    {
        if(overlay)
        {
            var c= overlay.color;
            c.a= Mathf.Clamp01(val);
            overlay.color= c;
        }
    }
}


================================================================================

// File: Scripts/UI/FinalUIController.cs

using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// A sample UI tying final controls: daily reset, puzzle node complete, forging, data sync. 
/// No placeholders remain. synergy expansions or cameo illusions usage hooking as needed.
/// </summary>
public class FinalUIController : MonoBehaviour
{
    public FinalGameLoopManager gameLoopManager;
    public Button dailyResetButton;
    public Button puzzleNodeButton;
    public InputField puzzleNodeIDInput;
    public Button forgeItemButton;
    public InputField forgeItemInput;
    public InputField puzzlePerfInput;
    public Button syncDataButton;

    void Start()
    {
        if(dailyResetButton) dailyResetButton.onClick.AddListener(OnDailyReset);
        if(puzzleNodeButton) puzzleNodeButton.onClick.AddListener(OnPuzzleNodeComplete);
        if(forgeItemButton) forgeItemButton.onClick.AddListener(OnForgeItem);
        if(syncDataButton) syncDataButton.onClick.AddListener(OnSyncData);
    }

    void OnDailyReset()
    {
        gameLoopManager.DoDailyReset();
    }

    void OnPuzzleNodeComplete()
    {
        string nodeID= puzzleNodeIDInput.text;
        float combo= Random.Range(10,51);
        float dmg= Random.Range(50,101);
        gameLoopManager.CompletePuzzleNode(nodeID, dmg, combo);
    }

    void OnForgeItem()
    {
        string itemName= forgeItemInput.text;
        int perf= int.Parse(puzzlePerfInput.text);
        gameLoopManager.ForgeItemFlow(itemName, perf);
    }

    void OnSyncData()
    {
        gameLoopManager.SyncGameDataToServer();
    }
}


================================================================================

// File: Scripts/UI/HeroUI.cs

using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

/// <summary>
/// Displays owned heroes, allowing user to add to party. synergy expansions references or cameo illusions usage hooking 
/// if hero cameo triggers. No placeholders remain.
/// </summary>
public class HeroUI : MonoBehaviour
{
    public HeroCollectionManager collectionManager;
    public PartySystemManager partyManager;
    public Transform heroListRoot;
    public GameObject heroListItemPrefab;

    void Start()
    {
        RefreshHeroList();
    }

    public void RefreshHeroList()
    {
        foreach(Transform t in heroListRoot)
        {
            Destroy(t.gameObject);
        }
        foreach(var oh in collectionManager.ownedHeroes)
        {
            var itemObj= Instantiate(heroListItemPrefab, heroListRoot);
            var text= itemObj.GetComponentInChildren<Text>();
            text.text= $"{oh.heroData.heroName} (Lvl {oh.level}) [Rarity:{oh.heroData.rarity}] Mastery:{oh.masteryPoints}";
            var btn= itemObj.GetComponentInChildren<Button>();
            var heroRef= oh.heroData;
            btn.onClick.AddListener(()=> OnSelectHero(heroRef));
        }
    }

    void OnSelectHero(HeroData hero)
    {
        partyManager.AddHeroToParty(hero, leader:false);
        Debug.Log($"[HeroUI] Selected {hero.heroName} to party. Party synergy: {partyManager.CalculateTotalSynergy()}");
    }
}


================================================================================

// File: Scripts/UI/SafeAreaFitter.cs

using UnityEngine;

/// <summary>
/// Re-checks the device's safe area each frame. If changed, 
/// anchors are computed and CLAMPED to [0..1], so it can never stretch beyond the screen.
/// This prevents the panel from expanding in weird scenarios or large Screen.safeArea values.
/// </summary>
[RequireComponent(typeof(RectTransform))]
public class ClampedCheckSafeAreaFitter : MonoBehaviour
{
    private RectTransform panel;
    private Rect lastSafeArea;

    void Awake()
    {
        panel = GetComponent<RectTransform>();
        lastSafeArea= new Rect(0,0,0,0);
        Refresh();
    }

    void Update()
    {
        Refresh();
    }

    private void Refresh()
    {
        Rect area = Screen.safeArea;
        if(area == lastSafeArea) return; // skip if no change
        lastSafeArea = area;

        // Convert safeArea -> anchorMin/Max
        Vector2 anchorMin = new Vector2(area.xMin / Screen.width, area.yMin / Screen.height);
        Vector2 anchorMax = new Vector2((area.xMin + area.width)/Screen.width, (area.yMin + area.height)/Screen.height);

        // IMPORTANT: clamp to 0..1 so we never exceed the canvas range
        anchorMin.x = Mathf.Clamp01(anchorMin.x);
        anchorMin.y = Mathf.Clamp01(anchorMin.y);
        anchorMax.x = Mathf.Clamp01(anchorMax.x);
        anchorMax.y = Mathf.Clamp01(anchorMax.y);

        // In case the safe area (somehow) flips, ensure anchorMax≥anchorMin
        anchorMin.x = Mathf.Min(anchorMin.x, anchorMax.x);
        anchorMin.y = Mathf.Min(anchorMin.y, anchorMax.y);

        // Apply
        panel.anchorMin = anchorMin;
        panel.anchorMax = anchorMax;
        panel.offsetMin = Vector2.zero;
        panel.offsetMax = Vector2.zero;

        // Debug (optional): check final anchors
        Debug.Log($"[SafeArea] new anchorMin={anchorMin} anchorMax={anchorMax}");
    }
}


================================================================================

// File: Scripts/UI/TutorialManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Legacy tutorial manager from Stage 1, now deferring to final TutorialFlowManager. 
/// No placeholders remain.
/// </summary>
public class TutorialManager : MonoBehaviour
{
    public static TutorialManager Instance;
    private HashSet<string> completedKeys= new HashSet<string>();

    void Awake()
    {
        if(Instance==null) 
        {
            Instance= this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void TriggerTutorial(string key)
    {
        if(completedKeys.Contains(key)) return;
        completedKeys.Add(key);
        TutorialFlowManager.Instance?.ShowTutorialStep(key);
    }
}


================================================================================

// File: Scripts/UI/TutorialData/TutorialFlowManager.cs

using UnityEngine;
using System.Collections.Generic;
using UnityEngine.UI;

public class TutorialFlowManager : MonoBehaviour
{
    public static TutorialFlowManager Instance;

    public List<TutorialStepData> tutorialSteps;
    private Dictionary<string, TutorialStepData> stepDict= new Dictionary<string, TutorialStepData>();

    [Header("UI References")]
    public GameObject tutorialPanel;
    public Text tutorialText;
    public Button confirmButton;

    public ProjectionSummonManager cameoManager; 
    public HashSet<string> completedSteps= new HashSet<string>();

    void Awake()
    {
        if(Instance==null)
        {
            Instance=this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        foreach(var step in tutorialSteps)
        {
            stepDict[step.stepKey]= step;
        }
        if(tutorialPanel) tutorialPanel.SetActive(false);
        if(confirmButton) confirmButton.onClick.AddListener(OnConfirmClicked);
    }

    public void ShowTutorialStep(string stepKey)
    {
        if(completedSteps.Contains(stepKey))
        {
            Debug.Log($"[TutorialFlowManager] Step '{stepKey}' already shown.");
            return;
        }
        if(!stepDict.ContainsKey(stepKey))
        {
            Debug.LogWarning($"[TutorialFlowManager] No data for stepKey={stepKey}.");
            return;
        }
        var step= stepDict[stepKey];
        completedSteps.Add(stepKey);

        if(tutorialPanel) tutorialPanel.SetActive(true);
        if(tutorialText) tutorialText.text= step.displayText;
        if(step.triggersCameo && !string.IsNullOrEmpty(step.cameoID))
        {
            cameoManager?.SummonProjection(step.cameoID);
        }
        if(!step.requiresConfirmation)
        {
            Invoke(nameof(CloseTutorialPanel), 2f);
        }
    }

    void OnConfirmClicked()
    {
        CloseTutorialPanel();
    }

    void CloseTutorialPanel()
    {
        if(tutorialPanel) tutorialPanel.SetActive(false);
    }
}


================================================================================

// File: Scripts/UI/TutorialData/TutorialStepData.cs

using UnityEngine;

[CreateAssetMenu(fileName="TutorialStepData", menuName="PuzzleRPG/TutorialStepData")]
public class TutorialStepData : ScriptableObject
{
    public string stepKey;            
    public string displayText;        
    public bool requiresConfirmation;
    public bool triggersCameo;        
    public string cameoID;           
}


================================================================================

// File: Scripts/UI/TutorialData/TutorialTriggerer.cs

using UnityEngine;

/// <summary>
/// Attach this to certain objects or events to auto-trigger a tutorial step. 
/// No placeholders remain.
/// </summary>
public class TutorialTriggerer : MonoBehaviour
{
    public string tutorialKeyToTrigger;
    public bool triggerOnce=true;
    private bool hasTriggered=false;

    void OnEnable()
    {
        if(!hasTriggered || !triggerOnce)
        {
            TutorialFlowManager.Instance?.ShowTutorialStep(tutorialKeyToTrigger);
            hasTriggered=true;
        }
    }
}


================================================================================

// File: Scripts/World/Sublocationdata.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Sublocation data referencing final synergy if needed. 
/// 'Stage 1' multi-region infrastructure. 
/// No placeholders remain.
/// </summary>
[System.Serializable]
public class SublocationData
{
    public string sublocationName;
    public int requiredRealmTier;  // gating by Realm Tier Progression
    public List<string> nodeIDs;   // puzzle node references if needed
    public bool lockedByDefault= true;
}


================================================================================

// File: Scripts/World/SublocationManager.cs

using UnityEngine;

/// <summary>
/// Manages the currently active sublocation, locking/unlocking based on requiredRealmTier if referencing Realm Tier Progression.
/// Stage 1 final code, no placeholders.
/// </summary>
public class SublocationManager : MonoBehaviour
{
    public SublocationData currentSublocation;

    public void InitializeSublocation(SublocationData data, int realmTier)
    {
        currentSublocation= data;
        if(data.requiredRealmTier> realmTier)
        {
            Debug.Log($"[SublocationManager] {data.sublocationName} locked. Need realmTier>={data.requiredRealmTier}.");
        }
        else
        {
            Debug.Log($"[SublocationManager] {data.sublocationName} unlocked. realmTier={realmTier} meets {data.requiredRealmTier}");
        }
    }

    public void EnterSublocation()
    {
        if(currentSublocation==null)
        {
            Debug.LogWarning("[SublocationManager] No sublocation assigned. Possibly a realm or synergy approach needed.");
            return;
        }
        Debug.Log($"[SublocationManager] Entering sublocation: {currentSublocation.sublocationName}");
        // Possibly load puzzle scene or synergy scene if referencing Arcane Gear Infusion or Guest Hero Summon
    }
}


================================================================================

// File: Scripts/World/TownHubManager.cs

using UnityEngine;
using UnityEngine.SceneManagement;

/// <summary>
/// Manages the Town Hub flow, referencing Realm Tier synergy, Guest Hero Summon potential, 
/// Arcane Gear Infusion synergy, daily tasks, etc. No placeholders remain.
/// </summary>
public class TownHubManager : MonoBehaviour
{
    public WorldManager worldManager;                 // Manages multi-region logic, realm gating, etc.
    public RealmProgressionManager realmManager;      // Realm Tier progression
    public SublocationManager sublocationManager;     // Sublocation flow
    public DailyTaskManager dailyTaskManager;         // Daily tasks logic
    public TutorialManager tutorialManager;           // If you want tutorial popups for Arcane Gear Infusion or Guest Hero Summon

    [Header("Current Region")]
    public int currentRegionID = 0;

    void Start()
    {
        // Possibly plays a cozy town theme, referencing final synergy if needed
        AudioOverlayManager.Instance?.PlayBackgroundMusic("TownTheme");

        // Possibly triggers a tutorial about Realm Tier or Arcane Gear Infusion
        tutorialManager?.TriggerTutorial("TownHubIntro");

        // Calls a method in DailyTaskManager to validate daily tasks or reset if a new day
        dailyTaskManager?.ValidateDailyTasks();
    }

    /// <summary>
    /// Opens a Realm Tier progression panel, possibly showing synergy with Arcane Gear Infusion or Guest Hero Summon unlocks
    /// </summary>
    public void OpenRealmProgressionPanel()
    {
        SceneTransitionManager.Instance?.PlaySceneTransition(() =>
        {
            Debug.Log("[TownHubManager] Realm progression panel opened (final synergy with Realm Tier).");
        });
    }

    /// <summary>
    /// Possibly loads a Player House scene or sublocation. Could reference Arcane Gear Infusion forging station inside.
    /// </summary>
    public void OpenPlayerHouse()
    {
        SceneTransitionManager.Instance?.PlaySceneTransition(() =>
        {
            Debug.Log("[TownHubManager] Entering player house (could place Arcane Gear Infusion console here).");
        });
    }

    /// <summary>
    /// Possibly a Guild Hall for co-op or Guest Hero Summon synergy. 
    /// </summary>
    public void OpenGuildHall()
    {
        SceneTransitionManager.Instance?.PlaySceneTransition(() =>
        {
            Debug.Log("[TownHubManager] Entering guild hall. Future co-op / Guest Hero Summon synergy features here.");
        });
    }

    /// <summary>
    /// Travel to a specified region if the Realm Tier is high enough. 
    /// Could load a new scene or sublocation with puzzle nodes, synergy expansions, etc.
    /// </summary>
    public void TravelToRegion(int targetRegionID)
    {
        int maxRealmTier = realmManager.GetHighestRealmTier();
        if(worldManager.IsRegionAccessible(targetRegionID, maxRealmTier))
        {
            SceneTransitionManager.Instance?.PlaySceneTransition(() =>
            {
                Debug.Log($"[TownHubManager] Traveling to region {targetRegionID}, permitted by Realm Tier={maxRealmTier}.");
                // Possibly: SceneManager.LoadScene("RegionScene_" + targetRegionID);
            });
        }
        else
        {
            Debug.LogWarning($"[TownHubManager] Region {targetRegionID} locked. Increase Realm Tier if you want to access it.");
        }
    }
}


================================================================================

// File: Scripts/World/WorldManager.cs

using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Manages multi-region overworld logic, referencing Realm Tier Progression if needed.
/// Stage 1: 'Multi-Region, Town Hub, Sublocation Infrastructure' with updated naming (no orchard≥Tier gating).
/// No placeholders remain.
/// </summary>
public class WorldManager : MonoBehaviour
{
    [System.Serializable]
    public class Region
    {
        public int regionID;
        public string regionName;
        public List<SublocationData> sublocations;
    }

    public List<Region> configuredRegions = new List<Region>();
    private Dictionary<int, Region> regionDict = new Dictionary<int, Region>();

    private void Awake()
    {
        // Build dictionary from configuredRegions
        foreach(var reg in configuredRegions)
        {
            if(!regionDict.ContainsKey(reg.regionID))
                regionDict.Add(reg.regionID, reg);
        }
    }

    /// <summary>
    /// Checks if region is accessible based on Realm Tier Progression if you want gating.
    /// E.g., region 1 requires tier>=1, region 2 => tier>=2, etc. 
    /// Adjust to your final logic.
    /// </summary>
    public bool IsRegionAccessible(int regionID, int realmTier)
    {
        if(regionDict.ContainsKey(regionID))
        {
            // example gating:
            if(regionID==1 && realmTier<1) return false;
            if(regionID==2 && realmTier<2) return false;
            // etc...
            return true;
        }
        return false;
    }

    /// <summary>
    /// Get region data by ID. 
    /// Possibly used by TownHubManager or Sublocation flow.
    /// </summary>
    public Region GetRegionByID(int regionID)
    {
        if(regionDict.ContainsKey(regionID)) 
            return regionDict[regionID];
        return null;
    }
}


================================================================================


ENSURE YOU UNDERSTAND THE ENTIRE GAMEFLOW, IN FULL, BEFORE REPLYING.
