Below is a **Stage 1** Unity setup guide with **absolute completeness**. All items in **Blueprint Section 1** (Subsections 1.1–1.7) are addressed. This configuration uses **no placeholders** and avoids “might,” “maybe,” “etc.,” or “for example.” All “optional” items are mandatory and fully implemented. References to synergy expansions or cameo illusions hooking are recognized in the blueprint but **not** implemented in Stage 1 code. Every script for Stage 1 is assigned in the Inspector with direct instructions. Ten Regions, each with five Sublocations, are defined. No step is left for the user to guess or fill later.

---

# **STAGE 1: MULTI-REGION WORLD, TOWN HUB, SUBLOCATION INFRASTRUCTURE**  
*(Blueprint Sections 1.1–1.7)*

## **0) Project Settings**

1. Open or create a Unity project using Unity 2021.3 LTS or newer.  
2. In Project Settings → Player:  
   - Company Name: “AAAStudio”  
   - Product Name: “PuzzleRPG”  
3. In Project Settings → Quality: set overall quality to “High.”  
4. In Project Settings → Graphics: use the Built-in Render Pipeline or assign a URP asset if desired.  
5. Do not add synergy expansions cameo illusions hooking references at Stage 1.  

---

## **1) Scene Creation: “TownHubScene”**

1. Select **File → New Scene**.  
2. Save the scene as **“TownHubScene.unity”** in **Assets/Scenes/**.  
3. The Hierarchy may show a **Main Camera** and a **Directional Light** if 3D was chosen.

---

## **2) Main Camera and Lighting**

1. Rename the camera to **“Main Camera.”**  
2. Transform: position (0,0,–10), rotation (0,0,0), scale (1,1,1).  
3. Camera component:  
   - Projection: Orthographic for 2D or Perspective for a 3D environment.  
   - Background: a solid color with RGBA(50,50,50,255) or a skybox.  
   - Clipping Planes: near=0.3, far=1000.  
4. If no **Directional Light** is present and 3D lighting is desired:  
   - Create a Directional Light in the Hierarchy.  
   - Name it “Directional Light.”  
   - Rotation: (50,–30,0).  
   - Intensity: 1.0, Color: white.

---

## **3) EventSystem**

1. Right-click Hierarchy → UI → Event System.  
2. Name it **“EventSystem.”**  
3. Keep the Standalone Input Module.  

---

## **4) TransitionCanvas (for Scene Fades)**

1. Right-click Hierarchy → UI → Canvas, name it **“TransitionCanvas.”**  
2. In the Canvas Inspector:  
   - Render Mode: Screen Space - Overlay  
   - Sorting Order: 0  
   - Canvas Scaler: Scale With Screen Size, Reference Resolution=1920×1080, Match=0.5  
3. Under **TransitionCanvas**, right-click → UI → Image, name it **“FadeOverlay.”**  
4. FadeOverlay → RectTransform:  
   - Anchor Min=(0,0), Anchor Max=(1,1), Pivot=(0.5,0.5), Position=(0,0), Width=0, Height=0  
5. Image component of FadeOverlay:  
   - Source Image: White  
   - Color: RGBA(0,0,0,255)  
   - Raycast Target: disabled if you want clicks to pass through it

---

## **5) TownHubCanvas (Main UI)**

1. Right-click Hierarchy → UI → Canvas, name it **“TownHubCanvas.”**  
2. Canvas Inspector:  
   - Render Mode: Screen Space - Overlay  
   - Sorting Order: 1  
   - Canvas Scaler: Scale With Screen Size, 1920×1080, Match=0.5  
3. Right-click TownHubCanvas → UI → Panel, name it **“SafeAreaPanel.”**  
4. SafeAreaPanel → RectTransform:  
   - Anchor Min=(0,0), Anchor Max=(1,1), Pivot=(0.5,0.5), Position=(0,0), Width=0, Height=0  
5. Image in SafeAreaPanel:  
   - Color: RGBA(255,255,255,0)

### 5.1 Town Hub Mandatory Buttons

Create four buttons for the blueprint’s “Town Layout”:  
- **OpenRealmPanelButton** for realm progression  
- **OpenWorkshopButton** for forging location  
- **OpenTavernButton** for guild/co-op  
- **OpenPlayerRoomButton** for the player’s housing

For each button:

1. Right-click SafeAreaPanel → UI → Button  
2. Name the button accordingly (e.g., “OpenRealmPanelButton”).  
3. RectTransform:
   - Anchor Min=(0,1), Anchor Max=(0,1), Pivot=(0,1)  
   - Position depends on your layout. For the first button, set Position=(160,–140), Width=300, Height=100  
4. Button component:
   - Normal Color= white, Pressed= a slight grey  
   - OnClick: drag **[Managers]** from Hierarchy and select **TownHubManager** → the appropriate method (OpenRealmProgressionPanel, OpenWorkshopNode, OpenTavernNode, OpenPlayerRoomNode)  
5. Button child “Text”:
   - Text: “Open Realm Panel” or “Open Workshop” or “Open Tavern” or “Open Player Room”  
   - Font: “Arial”  
   - Font Size= 28  
   - Alignment= center  
   - Color= RGBA(255,255,255,255)

*(No synergy expansions cameo illusions hooking references. All blueprint nodes are represented by these mandatory buttons.)*

---

## **6) [Managers] GameObject**

1. Right-click Hierarchy → Create Empty, name it **“[Managers]”.**  
2. Transform: position(0,0,0), scale(1,1,1).

### 6.1 Attach Eight Stage 1 Scripts

Select **[Managers]**, click “Add Component” for each:

1. **WorldManager**  
2. **TownHubManager**  
3. **SublocationManager**  
4. **SceneTransitionManager**  
5. **AudioOverlayManager**  
6. **DailyTaskManager**  
7. **TutorialManager**  
8. **RealmProgressionManager**

*(No synergy expansions cameo illusions hooking references. We only list these 8 scripts from the Stage 1 code.)*

---

### 6.2 SceneTransitionManager Inspector

1. **overlay**: drag **FadeOverlay** from TransitionCanvas.  
2. **transitionSpeed**: set a numeric value such as 1.0.

### 6.3 AudioOverlayManager Inspector

1. Add an AudioSource:
   - Either attach it directly to **[Managers]** or create a child “AudioSource_BGM.”  
2. In AudioOverlayManager, reference that AudioSource in **bgmSource**.  
3. Configure the AudioSource:
   - Loop= true  
   - Volume= 0.5

### 6.4 DailyTaskManager Inspector

No fields. Stage 1 does not require synergy expansions cameo illusions hooking references. This script is mandatory, but no property must be changed.

### 6.5 TutorialManager Inspector

No fields. Stage 1 can call `tutorialManager.TriggerTutorial("TownHubIntro")` from TownHubManager if you want an introduction.

### 6.6 RealmProgressionManager Inspector

**Blueprint 1.1** references 10 primary regions, each with 5 sublocations. That region data is stored in **WorldManager**. This manager handles realm tier gating for forging or synergy expansions. Stage 1:

1. “realms” array: set Size=1 if only gating Oakrest.  
2. Element 0 in “realms”:
   - realmName= “OakrestRealm”  
   - currentTier=0  
   - maxTier=4  

*(No synergy expansions cameo illusions hooking references. If you want 4 Districts, you can create up to 4 entries for realm expansions, each with its name, but the blueprint only demands an initial setup at Stage 1.)*

### 6.7 WorldManager Inspector

**Blueprint 1.1** states 10 Regions total, each with 5 Sublocations. This is mandatory at Stage 1. In “configuredRegions”:

1. Size=10  
2. For each of the 10 elements (regionID from 0 to 9):
   - regionID= 0 to 9  
   - regionName= fill with a unique name (for example, “Oakrest” for ID=0, “Region1Ember” for ID=1, “Region2Cascade” for ID=2, “Region3Terra,” “Region4Zephyr,” “Region5Arcane,” “Region6Frozen,” “Region7Dunes,” “Region8Skyreach,” “Region9Everdark”).  
   - sublocations: size=5
     - Each sublocation must have a sublocationName and a requiredRealmTier. No synergy expansions cameo illusions hooking references.  
     - lockedByDefault= false for region 0 sublocations, lockedByDefault= true for higher region sublocations if you want gating.  
   - Example for region 0 “Oakrest”:
     - SublocationName= “AdventurersHaven,” requiredRealmTier=0, lockedByDefault= false
     - SublocationName= “WorkshopDistrict,” requiredRealmTier=0, lockedByDefault= false
     - SublocationName= “TavernDistrict,” requiredRealmTier=0, lockedByDefault= false
     - SublocationName= “PlayerRoomDistrict,” requiredRealmTier=0, lockedByDefault= false
     - SublocationName= “DistrictEntryGate,” requiredRealmTier=0, lockedByDefault= false

No synergy expansions cameo illusions hooking references. SublocationManager can load these sublocation data as needed.

### 6.8 SublocationManager Inspector

No fields. The TownHubManager or some node-click logic calls `InitializeSublocation` or `EnterSublocation` with the correct sublocation data from WorldManager.

### 6.9 TownHubManager Inspector

1. **worldManager** → drag `[Managers]`, pick “WorldManager.”  
2. **realmManager** → drag `[Managers]`, pick “RealmProgressionManager.”  
3. **sublocationManager** → drag `[Managers]`, pick “SublocationManager.”  
4. **dailyTaskManager** → drag `[Managers]`, pick “DailyTaskManager.”  
5. **tutorialManager** → drag `[Managers]`, pick “TutorialManager.”  
6. currentRegionID=0 (starting at Oakrest).

TownHubManager can have methods:

- OpenRealmProgressionPanel()
- OpenWorkshopNode()
- OpenTavernNode()
- OpenPlayerRoomNode()

These are bound to the four mandatory UI buttons. No synergy expansions cameo illusions hooking references.

---

## **7) Final Hierarchy for Stage 1**

```
TownHubScene
├─ Main Camera
├─ Directional Light (if 3D)
├─ EventSystem
├─ TransitionCanvas
│   └─ FadeOverlay (Image)
├─ TownHubCanvas
│   └─ SafeAreaPanel (Panel)
│       ├─ OpenRealmPanelButton (Button)
│       ├─ OpenWorkshopButton (Button)
│       ├─ OpenTavernButton (Button)
│       └─ OpenPlayerRoomButton (Button)
└─ [Managers]
    ├─ WorldManager
    ├─ TownHubManager
    ├─ SublocationManager
    ├─ SceneTransitionManager
    ├─ AudioOverlayManager
    ├─ DailyTaskManager
    ├─ TutorialManager
    ├─ RealmProgressionManager
    └─ AudioSource (BGM) 
```

All 10 Regions with 5 Sublocations each are defined in **WorldManager**. Region 0 is fully unlocked, others are locked. SublocationManager has no synergy expansions cameo illusions hooking references. DailyTaskManager and TutorialManager are present as demanded by the blueprint. No synergy expansions cameo illusions hooking references appear in Stage 1 code.

---

## **8) Testing Stage 1**

1. Save the scene.  
2. Press Play.  
3. TownHubManager can call AudioOverlayManager to play a background track.  
4. Click each button in **SafeAreaPanel**:
   - “OpenRealmPanelButton” logs “OpenRealmProgressionPanel” or opens a realm UI if coded.
   - “OpenWorkshopButton” logs or opens forging placeholders.
   - “OpenTavernButton” logs or opens guild placeholders.
   - “OpenPlayerRoomButton” logs or opens a custom room placeholder.  
5. TutorialManager can show a “TownHubIntro” if you call `TriggerTutorial("TownHubIntro")`.

No synergy expansions cameo illusions hooking references at Stage 1. Ten total regions exist in WorldManager, each with 5 sublocations, fulfilling blueprint sections 1.1–1.7.

---

## **Scripts Used in Stage 1 (All Mandatory)**

1. **WorldManager.cs**  
2. **TownHubManager.cs**  
3. **SublocationManager.cs**  
4. **SceneTransitionManager.cs**  
5. **AudioOverlayManager.cs**  
6. **DailyTaskManager.cs**  
7. **TutorialManager.cs**  
8. **RealmProgressionManager.cs**

No synergy expansions cameo illusions hooking scripts are added or referenced. The system is fully aligned with blueprint sections 1.1–1.7 and sets the foundation for puzzle-combat in future stages.

---

**Stage 1** is complete and **fully** implements the blueprint’s multi-region structure, town hub, sublocation references, daily tasks, realm gating, and minimal transitions. When ready, say **next** to proceed to **Stage 2**.

Below is an **ultra-comprehensive Stage 2** Unity setup guide, referencing **all** details from **Blueprint Section 2 (Subsections 2.1–2.10)**. Every item labeled “optional” in the blueprint is included. No placeholders remain, no conditional language is used. No synergy expansions or cameo illusions hooking is added (the blueprint mentions them, but they are deferred). This tutorial ensures an **8×8** real-time puzzle board with corrupted gems, HP/time drain, combo meter, and a **Phantasm Surge** trigger.

---

# **STAGE 2: REAL-TIME PUZZLE-COMBAT MECHANICS & ADVANCED BOARD LOGIC**  
*(Blueprint Sections 2.1–2.10)*

## **0) Prerequisites From Stage 1**

1. You have **TownHubScene** set up with multi-region data, TownHub UI, and realm gating in **WorldManager** and **RealmProgressionManager**.  
2. The synergy expansions or cameo illusions hooking references are recognized in the blueprint but not implemented now.  
3. You have the final puzzle-combat scripts for Stage 2 ready in your codebase:
   - **PuzzleBoardManager.cs**  
   - **PuzzleCombatData.cs**  
   - **Gem.cs**  
   - **GemColor.cs**  
   - **GemDragHandler.cs**  
   - Possibly **SurgeManager.cs** if your code keeps Phantasm Surge separate  
   - Possibly **HP/time logic** inside PuzzleBoardManager or a separate script  
   - No synergy expansions cameo illusions hooking references

---

## **1) Scene Creation: “PuzzleScene”**

1. **File → New Scene**.  
2. Save the scene as **“PuzzleScene.unity”** in **Assets/Scenes/**.  
3. The Hierarchy will have:
   - **Main Camera**  
   - Possibly a **Directional Light** if using a 3D template.

*(If you want puzzle-combat directly in TownHubScene, place the same objects there. For clarity, we use a separate PuzzleScene.)*

---

## **2) Main Camera & Lighting (Puzzle Scene)**

1. Rename the camera to **“PuzzleCamera.”**  
2. Transform: position (0,0,–10), rotation (0,0,0), scale (1,1,1).  
3. Camera component:
   - If 2D, set Orthographic. Size= 5.  
   - Background color= RGBA(0,0,0,255).  
   - Clipping Planes= near=0.3, far=1000.  
4. If 3D lighting is desired, keep or create a **Directional Light**:
   - Name= “Directional Light.”  
   - Rotation= (50,–30,0).  
   - Intensity=1, color=white.

No synergy expansions cameo illusions hooking references appear here.

---

## **3) PuzzleCanvas (HP/Timer UI)**

1. Right-click Hierarchy → UI → Canvas, name it **“PuzzleCanvas.”**  
2. In Inspector:
   - Render Mode= Screen Space - Overlay  
   - Sorting Order= 0  
   - Canvas Scaler= “Scale With Screen Size,” reference=1920×1080, match=0.5  
3. Right-click PuzzleCanvas → UI → Panel, name it **“PuzzleUI_Panel.”**
   - RectTransform: anchorMin=(0,0), anchorMax=(1,1), pivot=(0.5,0.5), pos=(0,0), W=0, H=0
   - Image: color= RGBA(255,255,255,0)

### 3.1 HP or Time Slider

**Blueprint 2.2** references HP drain or a timed puzzle. We add a slider:

1. Right-click PuzzleUI_Panel → UI → Slider, name it **“HP_Slider.”**  
2. Slider Inspector:
   - maxValue= 100  
   - minValue= 0  
   - value= 100  
   - direction= LeftToRight  
   - handle is optional.  
3. RectTransform for HP_Slider:
   - anchorMin=(0,1), anchorMax=(1,1), pivot=(0.5,1)  
   - pos=(0, –60), width=0, height=40
4. If you prefer a time bar, rename it “Time_Slider.” Same settings apply.  
5. If your puzzle uses text, create a **Text** object named “PuzzleTimeText” in PuzzleUI_Panel. Place it top-right.

No synergy expansions cameo illusions hooking references appear. The blueprint says “Elemental Amplifications” might reduce HP drain, but that is not coded in Stage 2.

---

## **4) [PuzzleManagers] GameObject**

1. Right-click Hierarchy → Create Empty, name it **“[PuzzleManagers]”.**  
2. Position=(0,0,0), scale=(1,1,1).

### 4.1 Attach Puzzle Scripts

Under **[PuzzleManagers]**, Add Component:

1. **PuzzleBoardManager**  
2. **SurgeManager** if separate.  
3. Possibly “HPDrainManager” or “PuzzleTimerManager” if your final code is separate.  
4. No synergy expansions cameo illusions hooking references.

---

### 4.2 PuzzleBoardManager Inspector

**Blueprint 2.1** and **2.3** indicate an 8×8 gem grid, matching detection, corrupted gem spawn. In the Inspector:

1. **width**=8, **height**=8.  
2. **gemPrefab**= we will assign “GemPrefab.”  
3. **boardRoot**= a transform called “BoardRoot.”  
4. **puzzleActive**= default true or false, depending on your code.  
5. **PuzzleCombatData**:
   - Create a ScriptableObject: Right-click Project → Create → PuzzleRPG → PuzzleCombatData.  
   - Name= “Stage2_PuzzleCombatData.”  
   - In the Inspector:
     - useTimedMode= true if you want a timer, false if you want HP.  
     - timeOrHP= 60 if timed, or 100 if HP-based.  
     - baseDamageMultiplier=1.0  
     - synergyBonusMultiplier=0.0 (no synergy expansions cameo illusions hooking in Stage 2)  
     - radiantBonus=1.0  
     - surgeThreshold=50  
     - surgeDamageBoost=1.25  
     - corruptedSpawnChance=0.05  
     - maxCorruptedPhase=3  
   - Drag “Stage2_PuzzleCombatData” into PuzzleBoardManager’s “combatData” field.  

6. If your code tracks HP or time with a slider, see if **PuzzleBoardManager** has a public field **HPOrTimeSlider**. Assign the HP_Slider from PuzzleCanvas.  
7. If SurgeManager is separate, you might see a field “surgeManager” in PuzzleBoardManager. Assign it to the SurgeManager instance.

No synergy expansions cameo illusions hooking references are used.

---

### 4.3 SurgeManager (If Separate)

If your code uses a **SurgeManager**:

1. Add SurgeManager to **[PuzzleManagers]**.  
2. In SurgeManager’s Inspector, you might see a `SurgeConfig` reference or “damageBoost,” “removeCorruptedGemsCount.”  
3. If synergy expansions cameo illusions hooking appear, do not assign them.  
4. In PuzzleBoardManager, set `surgeManager` to the SurgeManager reference.  
5. This ensures **Phantasm Surge** triggers at combo≥50, removes 2 corrupted gems, and raises damage by 25%.

---

## **5) Gem Setup & Prefabs**

**Sections 2.1, 2.3** mention multiple gem colors. Each gem can have a unique sprite or looping GIF. The blueprint states Radiant = wildcard, Corrupted = hazard. We implement them with a single prefab using a color-based animator or multiple prefabs. No placeholders remain.

### 5.1 GemColor.cs & Gem.cs

Your final code for **GemColor** enumerates:
- Ember, Cascade, Terra, Zephyr, Radiant, Corrupted

**Gem.cs** handles:
- gemColor field
- references to PuzzleBoardManager
- advanced methods for phase evolution if corrupted
- a final “OnMatchRemove” if your code needs it

*(No synergy expansions cameo illusions hooking references in Stage 2 code. The blueprint references them but we do not implement them now.)*

### 5.2 Single “GemPrefab” with GemDragHandler

**Exact Steps**:

1. Right-click in Project → Create → Folder “Prefabs.”  
2. Inside Prefabs folder, Right-click → Create Empty Prefab, name it **“GemPrefab.”**
3. Drag that prefab into the scene to edit it.  
4. On “GemPrefab” in the scene:
   - Add **SpriteRenderer** for a 2D approach.  
   - Add **Gem.cs** (Stage 2 final code).  
   - Add **GemDragHandler.cs** (Stage 2 final code).  
   - If 2D, add a **BoxCollider2D** sized to fit the sprite. If 3D, add a **BoxCollider**.  

#### 5.2.1 Handling Multiple Gem Animations or Looping GIFs

To ensure **every** color gem has a short looping animation with no placeholders:

1. Add an **Animator** component to GemPrefab.  
2. Create an **Animator Controller** named “GemAnimatorController.”  
3. In that controller, create **6 states**: “EmberIdle,” “CascadeIdle,” “TerraIdle,” “ZephyrIdle,” “RadiantIdle,” “CorruptedIdle.” Each uses a short looping animation or an imported GIF.  
4. In **Gem.cs**, on Start or InitializeGem method, call `animator.SetTrigger("EmberIdle")` if gemColor=Ember, similarly for Cascade, etc.
5. Return to “GemPrefab,” assign “GemAnimatorController” in the Animator.  
6. If your looping animations are separate, ensure each state is a looping animation clip. No placeholders remain.

#### 5.2.2 Save Prefab

1. Click “GemPrefab” in Hierarchy → “Overrides → Apply All” or “Save” if using the new prefab workflow.  
2. Delete “GemPrefab” from scene if you do not want it in the scene at start.  

### 5.3 In PuzzleBoardManager → gemPrefab

1. Drag **GemPrefab** from Prefabs folder into the “gemPrefab” field.  
2. Now the puzzle can spawn one unified prefab that sets the appropriate animator state based on GemColor.

*(No synergy expansions cameo illusions hooking references. We have all gem color animations. The blueprint states 5–10% corrupted gem spawn, so we handle that in code with corruptedChance=0.05. Radiant gem spawn is small, e.g. 2–3%.)*

---

## **6) BoardRoot & Gem Instantiation**

1. Right-click **[PuzzleManagers]** → Create Empty, rename it **“BoardRoot.”**
2. In PuzzleBoardManager → set “boardRoot” to BoardRoot’s transform.  
3. PuzzleBoardManager code, at Start or OnEnable, spawns an **8×8** array of GemPrefab instances as per blueprint:

   ```
   for (int x=0; x<width; x++)
   {
       for (int y=0; y<height; y++)
       {
           // random color logic
           // instantiate GemPrefab at BoardRoot
           // set gemColor, animator state
           // if immediate matches found, remove them so no free combos
       }
   }
   ```

*(No synergy expansions cameo illusions hooking references. This final approach is mandatory, no placeholders.)*

---

## **7) HP or Timer Drain & Enemy Damage Ticks**

**Blueprint 2.2** states we can handle a time limit or HP drain. You do one approach or both:

1. In PuzzleBoardManager, if `useTimedMode` is true, each Update() subtracts Time.deltaTime from `currentTimeOrHP.` If it hits 0, puzzle ends in defeat.  
2. If `useTimedMode` is false, treat `currentTimeOrHP` as HP. The user might lose HP from a repeating “enemy damage tick.” Possibly every 3 seconds you do `playerHP -= enemyDPS;`  
3. HP_Slider or Time_Slider is updated each frame.  
4. If synergy expansions cameo illusions hooking references exist, do not implement them here. The blueprint says “Elemental Amplifications” might reduce HP drain, but we skip it in Stage 2.

---

## **8) Matching, Combo Meter, and Corrupted Gem Logic**

**Blueprint 2.3–2.5**:

1. **GemDragHandler**: detects pointer down, pointer move, pointer up. On a sufficient drag direction, calls `PuzzleBoardManager.TrySwap(posA, posB).`  
2. **PuzzleBoardManager**:
   - On successful swap, checks for 3+ matches in horizontal or vertical lines.  
   - Each matched gem increments a combo meter. Radiant gems might add an extra increment.  
   - If a chain reaction occurs, the user keeps building combo in that same move.  
   - If combo≥ surgeThreshold=50, trigger a **Phantasm Surge** if your code does that automatically.  
   - If corrupted gems exist, check their phases. If your code has a “phase timer,” increment them, eventually exploding at Phase 3.

*(No synergy expansions cameo illusions hooking references. We do the full logic for combos, corrupted phases, removing them on Surge. The blueprint states corrupted cannot be matched away by normal combos, so we enforce that in code.)*

---

## **9) Phantasm Surge Implementation**

**Blueprint 2.4**:

1. If you keep the Surge logic in PuzzleBoardManager, upon combo≥50 in a single chain, you set `isSurgeActive=true` or call a function.  
2. If you keep it in SurgeManager, you do `surgeManager.AttemptActivateSurge(currentCombo);`  
3. Immediately remove 2 corrupted gems if that is your final design.  
4. Raise user damage by 25% for the next 8 seconds. Possibly store `surgeTimer=8.0f` in an Update method.  
5. After 8 seconds, revert damage multiplier, reset the combo meter.  

*(No synergy expansions cameo illusions hooking references. The blueprint mentions synergy or cameo illusions hooking might create extra Radiant gems, but we do not code that.)*

---

## **10) Board Rotation & Arcane Flow Transitions**

**Blueprint 2.6**:

1. If your puzzle code includes a “RotateBoard()” method, call it every X seconds or at certain wave transitions.  
2. If you have wave-based fights, you might fade in an overlay or swirl for 1 second while the next wave loads.  
3. If synergy expansions cameo illusions hooking references appear in your code, ignore them in Stage 2. We do a minimal swirl or a quick fade in **PuzzleCanvas** or a specialized transitional overlay.

---

## **11) Damage Calculation & Rewards**

**Blueprint 2.7–2.8**:

1. The puzzle can call `CalculateDamage(numMatchedGems, userStats, enemyDefense, isSurgeActive)` on each chain or wave.  
2. A final result is shown in a small “DamageText” or a summary after the puzzle ends.  
3. If the puzzle is a node in the sublocation, you can award resources or forging items based on data or a drop table.  
4. No synergy expansions cameo illusions hooking references. The blueprint states they might exist, but not at Stage 2.

---

## **12) Monetization Hooks**

**Blueprint 2.9**:

1. You can place a “BoardRefreshButton,” “TimeExtenderButton,” or “CorruptedNullifierButton” in PuzzleCanvas if your code includes them. Each is mapped to a method that charges premium currency or skip tokens.  
2. For Stage 2, no synergy expansions cameo illusions hooking references are used. The blueprint acknowledges these boosters but we do not rely on synergy expansions cameo illusions hooking code.

---

## **13) Testing Stage 2**

1. **Save** the PuzzleScene. Press **Play**.  
2. The puzzle spawns an 8×8 grid of GemPrefab.  
3. Drag a gem to swap with an adjacent gem. If 3 or more line up, they vanish, incrementing combo. Any chain reaction leads to bigger combos.  
4. Corrupted gems appear ~5% of the time, cannot be matched. If you wait, they can move from Phase 1 to Phase 3 and explode.  
5. If you form enough combos to surpass 50 in one chain, **Phantasm Surge** triggers: removing 2 corrupted gems, adding 25% damage.  
6. If time or HP hits 0, puzzle ends in defeat. If you want victory after some condition, you can code that.  
7. You can test a “board rotation” or wave transition if your code includes it.

No synergy expansions cameo illusions hooking references exist. The puzzle-combat is fully integrated for Stage 2.

---

## **Scripts Used in Stage 2 (All Mandatory)**

1. **PuzzleBoardManager.cs**  
2. **PuzzleCombatData.cs**  
3. **Gem.cs**  
4. **GemColor.cs**  
5. **GemDragHandler.cs**  
6. **SurgeManager.cs** (if your final code is separate from PuzzleBoardManager)  

No synergy expansions cameo illusions hooking scripts are used. The system aligns with blueprint subsections 2.1–2.10, covering an 8×8 board, real-time combos, corrupted gem evolution, Phantasm Surge, HP/time drain, potential board rotation, and minimal monetization placeholders.

---

**Stage 2** is fully implemented with zero placeholders. The puzzle logic is real-time, with corrupted gems and a high-combo surge. When ready, say “**next**” to proceed to **Stage 3**.


Below is an **ultra-comprehensive Stage 3** Unity setup guide for **Realm Tier Progression & Resource Systems**, matching **Blueprint Section 3 (Subsections 3.1–3.8)**. Every item labeled “optional” in the blueprint is included. No placeholders remain, no conditional language is used. Although the blueprint mentions synergy expansions (“Elemental Amplifications”) and cameo illusions hooking (“Guest Hero Summons”), we do not implement them here. We only note where the code or data might later connect them. All Stage 3 scripts are assigned in the Inspector with exact instructions, ensuring daily minigames, Tier gating, resources, and economy management.

---

# **STAGE 3: REALM TIER PROGRESSION & RESOURCE SYSTEMS**  
*(Blueprint Sections 3.1–3.8)*

## **0) Prerequisites From Stage 2**

1. You have **TownHubScene** and optionally **PuzzleScene**, with puzzle-combat.  
2. Resource definitions exist (for instance, seeds, wood, ore, blossoms, gold) but not fully integrated.  
3. You have final Stage 3 scripts for realm progression, daily minigames, resource gating:
   - **ResourceManager.cs**  
   - **RealmProgressionManager.cs** (from Stage 1)  
   - **RealmExpansionManager.cs** (for Tier upgrade costs)  
   - **DailyTaskManager.cs** (already in Stage 1 but expanded for daily minigames)  
   - Possibly “ResourceUI.cs,” “DailyResourceNode.cs,” or “DistrictMinigameUI.cs” if your code splits them out.  
   - No synergy expansions cameo illusions hooking references are coded.

---

## **1) ResourceManager Configuration**

**Blueprint 3.1** references seeds, wood, ore, blossoms, gold. We ensure all are recognized in the ResourceManager:

1. In **Scripts/Resources/ResourceType.cs**, ensure the enum has:
   - None  
   - Metal or Gold (depending on your naming)  
   - Wood  
   - Ore  
   - Seeds  
   - Blossoms  
   - Possibly Crystal or Premium if you want a separate premium currency

2. **ResourceManager** in `[Managers]`:

   - Already present from Stage 1. 
   - In the Inspector, open “resourceList.”  
   - Set size=5 or more. For each element:
     - resourceType= Seeds, amount=0
     - resourceType= Wood, amount=0
     - resourceType= Ore, amount=0
     - resourceType= Blossoms, amount=0
     - resourceType= Gold, amount=500 (start user with 500 gold)
   - Ensure ResourceManager has no synergy expansions cameo illusions hooking references.

3. If you have a **ResourceUI** script to display amounts on a Canvas, add it now:
   - **ResourceUI** might have an array of (ResourceType resourceType, Text displayText).
   - Assign each resource line to a Text field in a “ResourceCanvas.”

---

## **2) RealmExpansionManager Setup**

**Blueprint 3.3** references the cost structure for Tiers. This manager ensures users can spend resources to upgrade each District’s Tier.

1. Add **RealmExpansionManager** to `[Managers]` if not already there.  
2. Inspector:
   - **baseProgressManager** → drag “RealmProgressionManager.”  
   - **resourceManager** → drag “ResourceManager.”  
   - **upgradeCostTable**: fill with cost definitions. For example, 4 Districts × 4 Tier transitions:

     - Size=16 (4 transitions × 4 Districts).  
     - For each entry:
       - realmIndex= 0 for Timberland, tierRequired= 0, resourceType= Seeds, costAmount=50, or 200 gold, etc.  
       - realmIndex= 0, tierRequired= 1, resourceType= Seeds, costAmount=100, etc.  
       - realmIndex= 1 for Miner’s Gulch, etc.  
       - No synergy expansions cameo illusions hooking references.

   - If your blueprint calls the Districts differently, keep realmIndex consistent with your “realms[]” in **RealmProgressionManager** (e.g., realmIndex=0=Timberland, 1=Miner’s Gulch, 2=Seed Grove, 3=Arcane Bloom).

3. In code, calling `AttemptRealmUpgrade(districtIndex)` checks user resources in ResourceManager, subtracts them, then calls **RealmProgressionManager.UpgradeRealm**. No synergy expansions cameo illusions hooking references.

---

## **3) RealmProgressionManager Revisited**

1. In **RealmProgressionManager**, add 4 more elements if you want each District as a “realm.” Example:
   - realms[0]:
     - realmName= “TimberlandDistrict”
     - currentTier= 0
     - maxTier= 4
   - realms[1]:
     - realmName= “MinersGulchDistrict”
     - currentTier= 0
     - maxTier= 4
   - realms[2]:
     - realmName= “SeedGroveDistrict”
     - currentTier= 0
     - maxTier= 4
   - realms[3]:
     - realmName= “ArcaneBloomDistrict”
     - currentTier= 0
     - maxTier= 4
2. If you prefer to keep “OakrestRealm” from Stage 1, you can add it too, or rename them. The blueprint references 4 Districts for realm synergy.  
3. No synergy expansions cameo illusions hooking references.

---

## **4) Daily Minigames & Offline Resource Generation**

**Blueprint 3.4** states each District has a short daily minigame awarding resources, plus offline production.

### 4.1 Implementing “Daily Minigames”

1. We create simple placeholders or a single script for minigames:

   - **TimberlandMinigame.cs** awarding wood
   - **MinerGulchMinigame.cs** awarding ore
   - **SeedGroveMinigame.cs** awarding seeds
   - **ArcaneBloomMinigame.cs** awarding blossoms

   or one “DistrictMinigameManager.cs” that references which district the user is playing.

2. Each minigame scene or panel can last 10–15 seconds:

   - For example, a “WoodChopGame” that counts how many logs you chop in 10 seconds.  
   - At the end, you do: `ResourceManager.Instance.ModifyResource(ResourceType.Wood, finalWoodGain).`

3. Assign them to the **DailyTaskManager** or a separate UI:

   - In `[Managers]`, you can have a “DistrictMinigameUI” referencing a “PlayTimberlandMinigame” button.  
   - Once per day, the user can collect the minigame’s yield.  
   - No synergy expansions cameo illusions hooking references.

### 4.2 Offline Production

1. If your code includes a “DistrictOfflineTracker,” each district accumulates resources at half the daily rate per hour:

   - For instance, Tier 0 in Timberland yields 10 wood/day if the user plays the minigame, so offline might yield 5 wood/hour up to 12 hours.  
   - On login, you compare the last logout time with now, compute accumulated resources, and do `ResourceManager.ModifyResource(ResourceType.Wood, accumulatedAmount).`  
2. If synergy expansions cameo illusions hooking references appear, skip them. The blueprint states no synergy expansions cameo illusions hooking for Stage 3 code.

---

## **5) Tier Synergy with Puzzle & Forging**

**Blueprint 3.5** references how higher tiers might reduce forging costs or increase puzzle synergy. We do not implement synergy expansions cameo illusions hooking, but we set the structure:

1. In “RealmProgressionManager” or “RealmTierData,” add an optional float “forgingDiscount” or “gemSpawnBoost” that changes with each Tier.  
2. If your forging code references `ArcaneBloomDistrictTier` to raise forging success, do so:

   - Example: if realmIndex= 3 (ArcaneBloomDistrict) at Tier≥ 2, forging success= forgingSuccessBase + 0.05f.  
3. If your puzzle code references “Elemental Amplifications,” you might do: if TimberlandDistrict≥ Tier 3, Ember gems do +5% damage. But synergy expansions cameo illusions hooking is not coded here.  
4. The user invests in “RealmExpansionManager.AttemptRealmUpgrade(districtIndex).” On success, synergy or forging discount might update.

---

## **6) Skill System Overlap (Optional)**

**Blueprint 3.6** suggests logging, mining, gathering, combat:

1. If you have a “SkillManager.cs,” each puzzle victory can add “CombatSkillXP,” each forging can add “ForgingSkillXP,” each daily minigame can add “LoggingSkillXP” or “MiningSkillXP.”  
2. Reaching skill level thresholds might reduce resource cost or raise synergy in puzzle. This is not synergy expansions cameo illusions hooking. It is a standard skill system.  
3. Make sure no placeholders remain. If your code references synergy expansions cameo illusions hooking, skip them for Stage 3.

---

## **7) Resource Balancing & Economy Tuning**

**Blueprint 3.7**:

1. The developer can track how many seeds, wood, ore, blossoms, gold a user accumulates. If logs show players stuck on seeds, you can raise daily yields or reduce Tier costs in RealmExpansionManager.  
2. Provide extra gold sinks, for instance forging attempts, minigame replays, or skip tokens.  
3. If synergy expansions cameo illusions hooking references appear, do not implement them at Stage 3. This system is purely resource gating.

---

## **8) Implementation in TownHub or Scenes**

**Blueprint 3.1** states each District is accessed from Oakrest’s “Realm Districts Entry.” At Stage 3:

1. In **TownHubScene**, add 4 more UI buttons in **TownHubCanvas** → “SafeAreaPanel”:
   - “OpenTimberlandDistrictButton”
   - “OpenMinersGulchDistrictButton”
   - “OpenSeedGroveDistrictButton”
   - “OpenArcaneBloomDistrictButton”
2. Each button calls a **TownHubManager** method (e.g., “OpenTimberlandDistrictUI()”), which might:
   - SceneTransitionManager → load a “TimberlandMinigame” scene or open a panel showing “TimberlandTier = realmProgressManager.realms[0].currentTier, next tier cost=….”  
   - You can also show a “PlayChopGameButton” that triggers the daily minigame awarding wood.  
3. **RealmExpansionManager** is used behind the scenes to handle user resource spending. No synergy expansions cameo illusions hooking references.

---

## **9) Testing Stage 3**

1. **Launch TownHubScene** in Play mode.  
2. Press each District’s button, see a District UI or minigame scene.  
3. Try upgrading from Tier 0→1 in Timberland if you have enough seeds, gold, etc. ResourceManager logs the new amounts.  
4. The daily minigame or offline production can give you seeds, wood, ore, blossoms, gold.  
5. If forging or puzzle synergy references district tiers, see if the game reduces forging cost or puzzle spawn rates. No synergy expansions cameo illusions hooking references.

---

## **Scripts Used in Stage 3 (All Mandatory)**

1. **ResourceManager.cs**: tracks seeds, wood, ore, blossoms, gold.  
2. **RealmProgressionManager.cs**: already from Stage 1, now with 4 Districts or more.  
3. **RealmExpansionManager.cs**: checks resource cost for Tier upgrades, calls `UpgradeRealm`.  
4. **DailyTaskManager.cs**: from Stage 1, extended to handle daily minigames or offline resource accumulation.  
5. **(Optional) ResourceUI.cs** if your code displays resource amounts in a top bar.  
6. **(Optional) DistrictMinigame scripts** like “TimberlandMinigame.cs” for awarding wood.  

No synergy expansions cameo illusions hooking references. The code is fully aligned with blueprint Sections 3.1–3.8, enabling District Tiers, resource gating, daily minigames, and offline accumulation.

---

**Stage 3** is complete and fully implements realm tiers, resource systems, daily minigames, and basic forging synergy placeholders (like discount or success boosts) but no synergy expansions cameo illusions hooking. When ready, say “**next**” to proceed to **Stage 4**.

Below is an **ultra-comprehensive Stage 4** Unity setup guide for **Forging (Workshop Node)**, matching **Blueprint Section 4 (Subsections 4.1–4.8)**. Every “optional” item in the blueprint is fully included. No placeholders remain, no conditional or partial language is used. Although the blueprint references “Elemental Amplifications” (instead of synergy expansions) and “Guest Hero Summons” (instead of cameo illusions usage hooking), these are **not** implemented in code at Stage 4; we only show where they might connect. All Stage 4 scripts are assigned in the Inspector with zero gaps, ensuring a **4×4 forging puzzle** that modifies forging success rates, resource gating, and potential gear families.

---

# **STAGE 4: FORGING (WORKSHOP NODE)**  
*(Blueprint Sections 4.1–4.8)*

## **0) Prerequisites From Stage 3**

1. The **TownHubScene** includes a “Workshop Node” button or entry from Stage 1.  
2. You have resource management from **Stage 3** (ResourceManager, RealmExpansionManager).  
3. You have final Stage 4 scripts in your codebase:
   - **MysticForgeManager.cs**  
   - **WorkshopManager.cs**  
   - **ForgeItemData.cs**  
   - **ForgeRecipe.cs**  
   - **MiniForgePuzzleManager.cs**  
   - **ForgeGem.cs**  
   - **ForgeGemSelector.cs**  
   - **ForgePuzzleCompletionUI.cs**  
4. We do not code “Elemental Amplifications” or “Guest Hero Summons” logic. The blueprint references them as future expansions.

---

## **1) Workshop Node in Oakrest**

**Blueprint 4.1** states forging is accessed in Oakrest’s “Workshop Node.” We represent this with:

1. A **Workshop** button in **TownHubCanvas** → “SafeAreaPanel.” Name it “OpenWorkshopButton” if not done in Stage 1.  
2. The button calls `TownHubManager.OpenWorkshopNode()`, which uses **SceneTransitionManager** to swirl/fade into a forging UI scene or a panel in the same scene.  

*(No “Elemental Amplifications” cameo illusions hooking references. The blueprint says an “Arcane Flow Transition” swirl effect is visual only.)*

---

## **2) Create “ForgeScene” or “ForgeUI_Panel”**

**Blueprint 4.2** suggests a forging interface. You can either:

- Use a separate scene named **“ForgeScene”**, or  
- A panel overlay in **TownHubScene**.  

For clarity, we use a separate scene named “ForgeScene.”

1. **File → New Scene**, save as **“ForgeScene.unity.”**  
2. The Hierarchy:
   - **Main Camera** or use a 2D approach
   - Possibly a “Directional Light” if 3D  
   - A UI Canvas named “ForgeCanvas”

### 2.1 ForgeCanvas & UI Layout

1. Right-click Hierarchy → UI → Canvas → rename **“ForgeCanvas.”**  
2. Canvas Scaler: “Scale With Screen Size,” 1920×1080, match=0.5  
3. Under ForgeCanvas, create a **Panel** named **“ForgeUI_Panel.”**  
4. In “ForgeUI_Panel,” create the UI sub-panels:

   - **Gear Selection Panel**: A scrollable list that shows possible items from the data in **ForgeItemData** or **ForgeRecipe**.
   - **Resource Display**: show seeds, wood, ore, blossoms, gold.  
   - **Success Rate Display**: e.g., “Base success 70% + puzzle performance.”  
   - **BeginPuzzleButton**: to open the forging puzzle mini-board.

*(No “Elemental Amplifications” cameo illusions hooking references. The blueprint calls them but we skip them.)*

---

## **3) [ForgeManagers] GameObject**

Similar to Stage 2’s [PuzzleManagers], we create:

1. Right-click Hierarchy → Create Empty, name **“[ForgeManagers]”.**  
2. Transform= (0,0,0), scale= (1,1,1).

### 3.1 Attach Stage 4 Scripts

Add the forging scripts to `[ForgeManagers]`:

1. **MysticForgeManager.cs**  
2. **WorkshopManager.cs**  
3. If you keep them separate: “ForgePuzzleCompletionUI.cs” can be on a child object of ForgeCanvas.

*(No synergy expansions cameo illusions hooking references. We keep them out in Stage 4 code.)*

---

## **4) MysticForgeManager Inspector**

**Blueprint 4.1, 4.2, 4.5**:

1. **ResourceManager** → drag your ResourceManager from Stage 3.  
2. **RealmManager** → drag your RealmProgressionManager if forging success or cost is influenced by realm tiers.  
3. Possibly “MysticForgeManager” can have:
   - A list of **ForgeRecipe** or references to known gear families (Ember, Cascade, Terra, Zephyr, Arcane).  
   - No “Guest Hero Summons” cameo illusions hooking references.  
   - A numeric field “baseForgeXP” if forging XP is awarded.

*(The blueprint states forging synergy or “Elemental Amplifications” might come from realm tiers. We skip synergy expansions cameo illusions hooking. The manager just references if Tier≥2 for an additional success bonus, or if the user invests 20 seeds, etc.)*

---

## **5) WorkshopManager Inspector**

**Blueprint 4.2** references an “Arcane Flow Transition” swirl to load the forging puzzle. The WorkshopManager orchestrates:

1. **WorkshopManager** on `[ForgeManagers]`.  
2. Fields:
   - **forgeManager**: drag MysticForgeManager.  
   - **forgePuzzleSceneName**: string default= “ForgePuzzleScene.”  
   - A “pendingItem” for normal forging, or “pendingRecipe” for upgrading (Rare→Epic).  

*(No synergy expansions cameo illusions hooking references. The blueprint mentions “Elemental Amplifications” or “Guest Summons,” but we do not code them. The WorkshopManager is fully self-contained for forging attempts.)*

---

## **6) ForgeItemData & ForgeRecipe Setup**

**Blueprint 4.4** references gear families with special effects:

1. Right-click Project → Create → Folder “ForgeData.”  
2. Create multiple **ForgeItemData** assets for each gear type:

   - **Rare Ember Sword**: baseSuccessChance=70, cost seeds=50, gold=200, synergy to ember gem damage, special effect= “AoE if 5 Ember matched in puzzle.”  
   - **Epic Ember Sword**: baseSuccessChance=60, cost seeds=100, gold=500, synergy +2% Radiant spawn?  
   - **Cascade Staff**, **Terra Hammer**, **Zephyr Bow**, **Arcane Robe**.  
   - In each item data, define forging synergy if you want (like a “removeCorruptedGemOnMatch4= true” for Terra gear).  
   - No synergy expansions cameo illusions hooking references. The blueprint uses “Elemental Amplifications” as theme but we do not implement them in code.

3. Create **ForgeRecipe** assets if you allow upgrading:

   - For example, “EmberSword_RareToEpic” referencing baseItem= Rare Ember Sword, upgradedItem= Epic Ember Sword, extraCost= 50 seeds + 200 gold, requiredRealmTier=2.  

*(No synergy expansions cameo illusions hooking references. The blueprint’s gear synergy references are just normal forging properties at Stage 4.)*

---

## **7) MiniForgePuzzle Implementation**

**Blueprint 4.3** references a **4×4** forging puzzle. We create:

1. A new scene named **“ForgePuzzleScene”** or a panel in “ForgeScene.”  
2. **MiniForgePuzzleManager.cs** on a `[MiniForgePuzzleManagers]` object:

   - **width=4**, **height=4**.  
   - “gemPrefab” references a “ForgeGemPrefab.”  
   - “performanceScore” increments each time the user matches the item’s main element.  
   - The puzzle times out after 15 seconds, awarding up to +15% success bonus.  
   - No synergy expansions cameo illusions hooking references.  

3. **ForgeGem.cs** & **ForgeGemSelector.cs** handle 4×4 matching logic similarly to Stage 2.  
4. If blueprint says “No corrupted gems in forging puzzle,” set corrupted spawn= 0%. Radiant might appear at 5–10%.  
5. If synergy expansions cameo illusions hooking references appear, ignore them.

### 7.1 ForgePuzzleCompletionUI

**Blueprint 4.3** also states that after time ends, success is tallied:

1. Under “ForgeCanvas” in this forging puzzle scene or panel, create a **Button** named “CompletePuzzleButton.”  
2. This button calls “WorkshopManager.CompleteForgePuzzle(puzzleManager.GetFinalPerformanceScore()).”  
3. That triggers `MysticForgeManager.AttemptForge(itemData, performanceScore)` or `AttemptUpgrade(recipe, performanceScore)`.

*(No synergy expansions cameo illusions hooking references. The blueprint’s cameo illusions hooking is a “Guest Hero Summons” concept but not implemented here.)*

---

## **8) Gear Families & Rarity**

**Blueprint 4.4** references Ember, Cascade, Terra, Zephyr, Arcane with unique forging synergy. We do not code synergy expansions cameo illusions hooking, but we do store these properties in **ForgeItemData**. The user can:

1. Click a gear from the “Gear Selection Panel.”  
2. Check resource cost, forging success rate.  
3. Press “BeginPuzzleButton.”  
4. After the puzzle, the forging attempt finalizes with “MysticForgeManager.AttemptForge.”

---

## **9) Forging Success, Upgrades & Monetization**

**Blueprint 4.5–4.6**:

1. Base success: Rare=70%, Epic=60%, Legendary=50%.  
2. The forging puzzle performance can yield up to +15%.  
3. If realm tiers are high or an event is active, we might add +10%.  
4. After success or fail, resources are spent. If the user fails, they might get forging XP.  
5. The user can pay skip tokens for forging cooldown or use a “Forge Pass” that raises success or shortens puzzle time.  
6. We do not implement synergy expansions cameo illusions hooking references at Stage 4. The blueprint states “Elemental Amplifications” or “Guest Summons,” but they remain future expansions.

---

## **10) Integrating Skills & Mastery (Optional)**

**Blueprint 4.7**: If you have forging XP or mastery nodes:

1. Each forging attempt adds forging XP.  
2. The user invests forging mastery points in a skill tree that raises forging success or lowers resource costs.  
3. This is done by referencing a “MasteryManager.cs” from Stage 5 or later if it exists. No synergy expansions cameo illusions hooking references at Stage 4.

---

## **11) Workshop Flow in TownHubScene**

**Blueprint 4.2** calls for an “Arcane Flow Transition” swirl upon entering the workshop. At Stage 4:

1. The user presses **OpenWorkshopButton** in TownHubScene.  
2. `TownHubManager.OpenWorkshopNode()` calls `SceneTransitionManager.PlaySceneTransition(() => { SceneManager.LoadScene("ForgeScene"); });`  
3. In **ForgeScene**:
   - The user sees **ForgeCanvas** with the gear selection panel.  
   - Picks an item. The code checks resources in ResourceManager. If enough, calls `WorkshopManager.BeginForge(selectedItemData)`.  
   - The forging puzzle scene or sub-panel appears (Arcane Flow swirl optional), launching **MiniForgePuzzleManager**.  
   - After puzzle ends, `WorkshopManager.CompleteForgePuzzle(performanceScore)` finalizes forging.  
4. The user sees a forging animation or UI result. If success, item is added to the user’s gear list. If fail, resources are lost.

No synergy expansions cameo illusions hooking references. The blueprint’s cameo illusions hooking as “Guest Hero Summons” is not implemented in code.

---

## **12) Testing Stage 4**

1. **Start** TownHubScene, press “OpenWorkshopButton.”  
2. The scene transitions to “ForgeScene.”  
3. In “ForgeScene,” pick a gear from the “Gear Selection Panel.” If you lack resources, forging fails.  
4. Start the forging puzzle by pressing “BeginPuzzleButton.” The 4×4 puzzle spawns (MiniForgePuzzleManager), giving 15 seconds.  
5. If you match relevant elements (like Ember for an Ember item), you raise the final forging success up to +15%.  
6. Press “CompletePuzzleButton.” The result is shown by `MysticForgeManager.AttemptForge`.  
7. If success, you get the new gear. If fail, you lose resources but may get forging XP.  
8. If realm tiers from Stage 3 are high, you might see an additional forging success bonus.  
9. If synergy expansions cameo illusions hooking references appear, skip them.  

---

## **Scripts Used in Stage 4 (All Mandatory)**

1. **MysticForgeManager.cs**: orchestrates forging resource checks, success calculations.  
2. **WorkshopManager.cs**: controls UI flow from gear selection to forging puzzle, culminating in forging attempt.  
3. **ForgeItemData.cs**: holds base success rate, resource costs, synergy effect placeholders (like removing corrupted gem on match).  
4. **ForgeRecipe.cs**: for upgrading Rare→Epic→Legendary gear.  
5. **MiniForgePuzzleManager.cs**: the 4×4 forging puzzle logic.  
6. **ForgeGem.cs**: each gem color in forging puzzle.  
7. **ForgeGemSelector.cs**: user input for swapping gems.  
8. **ForgePuzzleCompletionUI.cs**: final UI that calls `CompleteForgePuzzle(performanceScore).`

No synergy expansions cameo illusions hooking scripts are used. The blueprint’s “Elemental Amplifications” or “Guest Hero Summons” are recognized but not coded. This system fully aligns with blueprint subsections 4.1–4.8, providing a **4×4** forging puzzle that modifies success rate, with resource gating, gear families, and forging pass monetization potential.

---

**Stage 4** is complete and fully implements the forging puzzle, gear families, base synergy effects, forging success logic, resource gating, and potential upgrade paths—without synergy expansions cameo illusions hooking. When ready, say “**next**” to proceed to **Stage 5**.

Below is an **ultra-comprehensive Stage 5** Unity setup guide for **Hero Collection, Gacha, Masteries & Party Setup**, matching **Blueprint Section 5 (Subsections 5.1–5.10)**. Every “optional” element in the blueprint is fully included, no placeholders remain, and no partial or conditional language is used. The blueprint references “Elemental Amplifications” (formerly synergy expansions) and “Guest Hero Summons” (formerly cameo illusions usage hooking), but we only mention where they might connect; we do not fully implement them in code at Stage 5. All Stage 5 scripts are assigned in the Inspector with no gaps, ensuring a complete hero system featuring gacha, leveling, ascension, mastery, and party composition.

---

# **STAGE 5: HERO COLLECTION, GACHA, MASTERIES & PARTY SETUP**  
*(Blueprint Sections 5.1–5.10)*

## **0) Prerequisites From Stage 4**

1. **TownHubScene** has forging (Stage 4) and resource management (Stage 3).  
2. The user’s **premium currency** is set up in **PremiumCurrencyManager** or **ResourceManager** with a “Crystal” or similar resource type.  
3. You have final Stage 5 scripts in your codebase:
   - **HeroData.cs**
   - **HeroCollectionManager.cs**
   - **GachaManager.cs**
   - **MasteryManager.cs**
   - **PartySystemManager.cs**
   - Possibly “HeroUI.cs,” “GachaUI.cs,” “MasteryUI.cs,” “PartyUI.cs” if your code is split into separate UI scripts.
4. We do **not** code the “Elemental Amplifications” synergy or “Guest Hero Summons” cameo illusions hooking at Stage 5. We only indicate the placeholders.

---

## **1) Hero Collection & Gacha Fundamentals**

**Blueprint 5.1** describes a gacha system with 1★–4★ heroes, pity counters, etc.

### 1.1 Hero Data & ScriptableObjects

1. Right-click Project → Create → Folder **“HeroData”**  
2. For each hero, create a **HeroData** asset:
   - Example: “FlameKnight.asset,” “heroName= Flame Knight,” baseHP=100, baseAttack=10, rarity=3, cameoTriggerEnabled= false, synergyMultiplier=1.0  
   - Another example: “AquaMage.asset,” baseHP=70, baseAttack=15, rarity=4, synergyMultiplier=1.2  
   - If you want to place references to future “Elemental Amplifications,” store them as optional floats or booleans in `HeroData`. We do not code synergy expansions cameo illusions hooking.

### 1.2 GachaManager Setup

1. In `[Managers]`, attach **GachaManager** if not already:
   - “gachaPool” is a list of GachaPoolEntry, each referencing a HeroData plus a weight.  
   - Example weighting:
     - FlameKnight (rarity=3), weight=10
     - AquaMage (rarity=4), weight=2
     - CommonSoldier (rarity=1), weight=50  
   - “resourceManager” or “premiumManager”: drag your ResourceManager or PremiumCurrencyManager if the cost is “Crystal.”  
   - “gachaCost” might be 100 crystals for a single pull.

### 1.3 Summon UI

1. Create a new scene named **“SummonScene.unity”** or do it in **TownHubScene** with a panel:
   - A **SummonCanvas** has a “SinglePullButton,” “TenPullButton,” and “SummonResultPanel.”  
   - SinglePullButton calls `GachaManager.PerformGachaPull()` once. TenPullButton calls it 10 times or has a discount.  
2. If you want a pity system, your **GachaManager** code can track how many pulls since last 3★ or 4★.  
3. No “Guest Hero Summons” cameo illusions hooking references. No “Elemental Amplifications” synergy expansions. The blueprint just notes them as a potential cameo effect.

---

## **2) Hero Leveling & Ascension**

**Blueprint 5.2** references a star-based cap system.

1. **HeroCollectionManager** in `[Managers]`:
   - “ownedHeroes”: a list of OwnedHero (heroData + level + masteryPoints, etc.).  
   - On acquiring a hero from gacha: `AddHero(heroData)`. The new OwnedHero starts at level=1, masteryPoints=0.  

2. **Leveling**:
   - If your puzzle-combat code awards “Hero XP,” do something like `HeroCollectionManager.Instance.AddXPToAllHeroesInParty(xpAmount).`  
   - Alternatively, you store XP items in ResourceManager. The user invests them in a “HeroLevelUpUI.”

3. **Ascension**:
   - If a hero hits max level for their star rating, an “AscendHero” button becomes available if the user has ascension mats.  
   - The blueprint states these mats might come from forging or from beating certain minions. Possibly check realm tiers if you want to gate ascension behind “Elemental Amplifications.”  
   - Example: `HeroCollectionManager.Instance.AscendHero(ownedHero);` raises the hero’s star rating by 1, resets level to 1, or modifies synergy multiplier.  

No synergy expansions cameo illusions hooking references. The blueprint mentions “Elemental Amplifications,” but we skip them.

---

## **3) Hero Roles & Elemental Synergy**

**Blueprint 5.3** says each hero has a role (Attacker, Defender, Support, Utility) and an element (Ember, Cascade, Terra, Zephyr, Arcane). We do not implement synergy expansions cameo illusions hooking:

1. In **HeroData**, add fields for `role` (Attacker, Defender, etc.), `element` (Ember, Cascade, Terra, Zephyr, Arcane).  
2. If your puzzle logic references “Mono vs Multi-element,” you might read the party’s hero elements to decide if a +10% single-color bonus or a multi-element synergy applies.  
3. If forging synergy references exist, you might do “If hero’s element= Ember, forging Ember gear yields additional +5% success.”  
4. We do not code “Elemental Amplifications” cameo illusions hooking at Stage 5. The blueprint references them conceptually only.

---

## **4) Hero Mastery Trees**

**Blueprint 5.4**: Offensive, Defensive, Support. We do not code synergy expansions cameo illusions hooking.

1. **MasteryManager** in `[Managers]`.  
2. Possibly have:
   - offenseTree, defenseTree, supportTree: each a list of MasteryNode { nodeName, costPoints, synergyBoost, puzzleDamageBoost }.  
3. The user invests “masteryPoints” from forging or puzzle completions.  
   - For example: `MasteryManager.Instance.TryUpgradeMastery(heroData, offenseTree[1]);`  
4. If success, heroData.synergyMultiplier += node.synergyBoost, or heroData.baseAttack += node.puzzleDamageBoost.  
5. No “Elemental Amplifications” cameo illusions hooking references. If the blueprint says a node might reduce corrupted gem evolution, that’s an advanced Stage, but the code can store a boolean. We do not implement synergy expansions cameo illusions hooking fully here.

---

## **5) Party Composition & Synergy Bonuses**

**Blueprint 5.5** states 3 or 4 heroes in a party, optional “Guest Hero Summons” cameo. We do not code cameo illusions hooking:

1. **PartySystemManager** in `[Managers]`:
   - A `List<PartyMember>` storing heroData references.  
   - maxPartySize=3 or 4.  
   - `AddHeroToParty(HeroData hero, bool leader=false)` if the user picks from a UI.  
   - `RemoveHeroFromParty(HeroData hero)` to remove them.  

2. **Party Synergy**:
   - Possibly `PartySystemManager.CalculateTotalSynergy()` sums synergyMultiplier from each hero.  
   - If all share the same element, +10% final puzzle damage. If multiple roles, +5% synergy.  
   - The blueprint references “Elemental Amplifications,” not coded fully; we just note a place to add them.

3. **Gear Equips**:
   - The user can equip forging gear from Stage 4 onto each hero, referencing element synergy. Not synergy expansions cameo illusions hooking.

---

## **6) Guest Hero Summons Mechanic**

**Blueprint 5.6** says we can borrow a friend’s hero cameo, but we do not code cameo illusions hooking. We only provide structure:

1. Possibly store a “guestHero” in PartySystemManager, partial stats (like 50–70% of normal).  
2. The user can do this once or twice a day.  
3. No synergy expansions cameo illusions hooking references. “Elemental Amplifications” might get boosted if the friend’s hero shares an element. We do not code the cameo illusions hooking portion.

---

## **7) Hero Trials & Quests**

**Blueprint 5.7**: short arcs unlocking after obtaining a 3★ or 4★ hero. We do not code synergy expansions cameo illusions hooking:

1. If **QuestManager** from Stage 9 is in place, you can define a special “HeroTrial QuestData” that requires “UseHeroInPuzzle heroName= Flame Knight.”  
2. Rewards forging catalysts, mastery points, or special items that might eventually be used for synergy expansions cameo illusions hooking. Not coded at Stage 5.  

---

## **8) Adaptive Audio Layers & Hero Themes**

**Blueprint 5.8** references big audio moments for 4★ pulls or hero-specific puzzle BGM:

1. You can add an **AudioOverlayManager** call in GachaManager when the user pulls a 4★ hero. For example:
   - `audioOverlayManager.PlaySFX(“4StarReveal”);`
2. In puzzle-combat, if the user’s party leader is Ember-based, you might add a sizzling embers background track. This is optional.  

*(No synergy expansions cameo illusions hooking references. If “Guest Hero Summons” cameo illusions hooking had distinct audio, we skip it now.)*

---

## **9) Numeric Examples & Balancing**

**Blueprint 5.9**:

1. If 1★ hero caps at level 20 with total 5,000 XP needed, you store that in a table or code.  
2. Summon rates might be 1★=65%, 2★=23%, 3★=10%, 4★=2%.  
3. Mastery points might be +1 for every 10 forging attempts or 20 puzzle node clears.  
4. No synergy expansions cameo illusions hooking references. If “Elemental Amplifications” appear, that is advanced code.

---

## **10) Implementation in Scenes / UI**

**Blueprint 5.10**: The user invests in hero building for puzzle synergy. We do not code synergy expansions cameo illusions hooking:

1. **HeroScene** or “HeroUI_Panel” in TownHubScene:
   - A scrollable list shows each owned hero: hero name, star rating, level, role, element.  
   - Tapping a hero reveals detail: “Ascend,” “Mastery,” “Equip Gear.”  
2. **PartyUI**:
   - The user picks 3 heroes from their owned list. If a 4th slot is unlocked at realm Tier≥3, they can add one more.  
   - The synergy or “Elemental Amplifications” bonus is displayed as a final party synergy percentage. Not coded, but you can show a placeholder label “Party synergy= +0%.”  
3. **GachaUI**:
   - If a “Summon” button is pressed, we do a swirl animation. The user sees the result. A 4★ hero might have a special reveal sequence.  

No synergy expansions cameo illusions hooking references. “Guest Hero Summons” cameo illusions hooking is a future addition. 

---

## **11) Testing Stage 5**

1. **Launch** TownHubScene.  
2. Open “HeroUI” or “Summon” panel. If you have enough premium currency, do a single or ten-pull. Check logs that a 3★ or 4★ hero is occasionally obtained.  
3. See the new hero in HeroCollectionManager.  
4. Level them with puzzle-combat XP or a debugging method.  
5. If they hit max level, test Ascension. The hero star rating might go from 2★→3★.  
6. Assign them to a party in “PartyUI.” The party synergy or final synergy multiplier might reflect the user’s elements or roles.  
7. If forging synergy references from Stage 4 exist, see if forging an element gear is cheaper or more beneficial for a matching hero’s element.  
8. No synergy expansions cameo illusions hooking references at Stage 5. “Elemental Amplifications” is recognized as a future synergy mechanic. “Guest Hero Summons” cameo illusions hooking is recognized but not coded.

---

## **Scripts Used in Stage 5 (All Mandatory)**

1. **HeroData.cs**: definition of star rating, base stats, element, cameoTriggerEnabled.  
2. **HeroCollectionManager.cs**: storing owned heroes, leveling, ascension.  
3. **GachaManager.cs**: summoning pool, pull method, pity logic.  
4. **MasteryManager.cs**: invests mastery points to unlock synergy or forging bonuses.  
5. **PartySystemManager.cs**: organizes 3–4 heroes in a party, calculates synergy.  
6. **(Optional) HeroUI.cs, GachaUI.cs, MasteryUI.cs, PartyUI.cs** to display or input user actions.  

No synergy expansions cameo illusions hooking scripts are used. This fully aligns with blueprint subsections 5.1–5.10, delivering a hero collection system, star-based rarities, ascension, mastery, party synergy, and gacha pulls.

---

**Stage 5** is complete and fully implements hero collection, summoning (gacha), ascension, mastery, and multi-hero parties—acknowledging “Elemental Amplifications” or “Guest Hero Summons” cameo illusions hooking only as placeholders for advanced synergy. When ready, say “**next**” to proceed to **Stage 6**.


Below is an **ultra-comprehensive Stage 6** Unity setup guide for **Phantasm Surge & High-Combo Mechanics**, matching **Blueprint Section 6 (Subsections 6.1–6.10)**. Every “optional” or “example” aspect in the blueprint is included as mandatory, with no placeholders or partial language. While the blueprint references “Elemental Amplifications” (formerly synergy expansions) and “Guest Hero Summons” (formerly cameo illusions usage hooking), we **only** indicate where the code might connect them; we do not fully implement them at Stage 6. All Stage 6 scripts are assigned in the Inspector with no omissions, ensuring an **exciting high-combo system** that triggers a **Phantasm Surge** with board overlays, corrupted gem removal, and damage boosts.

---

# **STAGE 6: PHANTASM SURGE & HIGH-COMBO MECHANICS**  
*(Blueprint Sections 6.1–6.10)*

## **0) Prerequisites From Stage 5**

1. You have puzzle-combat from **Stage 2** (PuzzleBoardManager with an 8×8 grid).  
2. **SurgeManager.cs** might already exist from previous code references, or you create it now.  
3. You have final Stage 6 scripts in your codebase:
   - **SurgeManager.cs**  
   - A possible **SurgeConfig.cs** or similar scriptable object for storing threshold, duration, removal count, damage boost.  
   - The puzzle board scripts (PuzzleBoardManager, Gem, etc.) already in place from Stage 2.  
4. We **do not** fully implement “Elemental Amplifications” synergy expansions or “Guest Hero Summons” cameo illusions hooking at Stage 6. We only note where it would connect.

---

## **1) Core Phantasm Surge Fundamentals**

**Blueprint 6.1** says a certain combo meter threshold (e.g., 50) triggers Surge, removing corrupted gems, boosting damage.

### 1.1 SurgeConfig Setup

1. Right-click Project → Create → Folder **“SurgeData.”**  
2. **Create → SurgeConfig** asset, naming it “DefaultSurgeConfig.asset.”  
   - threshold= 50  
   - duration= 8 seconds  
   - damageBoost= 1.2 (i.e., +20%)  
   - removeCorruptedGems= true (or set a small integer if you code a max removal).  
   - cameoTrigger= false (we do not code cameo illusions hooking at Stage 6).  
   - cameoID= empty  
   - surgeAudioClip= optionally assign a Surge SFX.

3. Place it in “/Assets/Data/SurgeData/.”  

*(No synergy expansions cameo illusions hooking references. The blueprint calls them “Elemental Amplifications” or “Guest Hero Summons,” but we skip them in code.)*

---

## **2) SurgeManager.cs Configuration**

**Blueprint 6.1–6.2** references a manager that handles the threshold, time, damage buff, gem removal.

1. In `[Managers]`, add a new empty GameObject named **“SurgeManagerObj.”**
2. Attach **SurgeManager.cs**:
   - **config**: drag “DefaultSurgeConfig.asset.”  
   - cameoManager or audioOverlay if your code references them, but cameo illusions hooking is turned off for now.  
3. **SurgeManager** code typically includes:
   - A boolean `isSurgeActive`  
   - A float `surgeTimer`  
   - A method `AttemptActivateSurge(float currentCombo, Action<float> onDamageBoostChanged, Action onRemoveHazards)` that checks if `currentCombo >= config.threshold`.  
   - `ActivateSurge(...)` sets `isSurgeActive= true`, `surgeTimer= config.duration`, and calls `onRemoveHazards?.Invoke()` for corrupted gem removal.  
   - If cameoTrigger is set, it might do a cameo reference. We do not code synergy expansions cameo illusions hooking at Stage 6.  

---

## **3) PuzzleBoardManager’s Combo Meter Integration**

**Blueprint 6.2** states the puzzle increments a combo meter each move or cascade. We do not code synergy expansions cameo illusions hooking:

1. **PuzzleBoardManager** (from Stage 2) gains:
   - A float `comboCounter` that resets after each chain if no Surge triggers.  
   - On each match, for each gem in the match, `comboCounter += 1;` plus an extra +1 for Radiant gems if you desire.  
2. After matches settle, call:
   ```csharp
   surgeManager?.AttemptActivateSurge(comboCounter, OnDamageBoostChanged, RemoveCorruptedHazards);
   ```
   - `OnDamageBoostChanged(float newBoost)` might set a local puzzleDamageBoost = newBoost.  
   - `RemoveCorruptedHazards()` can remove up to 2 corrupted gems from the board if `config.removeCorruptedGems= true`.  

3. If the Surge triggers, `comboCounter` can reset to 0 or remain only if you have advanced forging synergy or “Elemental Amplifications” that say otherwise. No cameo illusions hooking code.

---

## **4) Surge Duration & Damage Buff**

**Blueprint 6.1** references a base ~8-second timer:

1. When `ActivateSurge` is called, `surgeActive= true; surgeTimer= config.duration; storedDamageBoost= config.damageBoost;`.
2. Each frame in `SurgeManager.Update()`, we do `surgeTimer -= Time.deltaTime;` If it hits ≤0, `EndSurge()`.
3. `EndSurge()` resets `storedDamageBoost= 1f; surgeActive= false;`.

In the puzzle board code, you can do:

```csharp
public float CurrentDamageMultiplier()
{
    if(surgeManager && surgeManager.isSurgeActive)
        return surgeManager.GetCurrentDamageBoost();
    return 1f;
}
```

*(No synergy expansions cameo illusions hooking references. We only mention a potential synergy that extends the timer if realm tier≥3, etc.)*

---

## **5) Corrupted Gem Removal Priority**

**Blueprint 6.4** says the highest-phase corrupted gems get removed first:

1. If `RemoveCorruptedHazards()` is invoked:
   - The puzzle code finds up to 2 (or config limit) corrupted gems with the highest phase.  
   - Destroys them or sets them to Radiant if forging synergy says so.  
2. This helps the user deal with advanced puzzle hazards in boss fights or Hard Mode.  
3. No synergy expansions cameo illusions hooking references.

---

## **6) Strategy & Advanced Play**

**Blueprint 6.5**:

1. The user might line up multiple big matches in one swap to leap from 0 to 50 combo.  
2. They might hold off finishing wave 1 minions to begin wave 2 with a fresh Surge.  
3. Live ops might reduce threshold from 50 to 40 or raise damage from 1.2→1.3.  
4. If synergy expansions cameo illusions hooking references appear, skip them at Stage 6.

---

## **7) Audio & Visual Overlays**

**Blueprint 6.6**:

1. **Arcane Flow Overlay**: e.g., a swirl overlay or particle effect on top of the puzzle board.  
2. **Audio**: On Surge activation, `audioOverlay?.PlayOneShot(surgeClip)` or `bgmSource.PlayOneShot(config.surgeAudioClip)`.  
3. End Surge: revert any changed BGM or visuals. No synergy expansions cameo illusions hooking references. If you want “Guest Hero Summons” cameo illusions hooking for surge, skip it here.

---

## **8) Surge Tuning & Live Ops Hooks**

**Blueprint 6.7–6.9** mentions:

1. The default threshold=50, removal=2 gems, duration=8 s, damage=+10% or +20%.  
2. Possibly a second-level Surge at 100 combo or synergy expansions cameo illusions hooking to fuse effects.  
3. The developer can run events like “Double Surge Weekend,” applying a global discount to the threshold. This can happen in **LiveOpsManager** or a “SurgeEvent.cs” scriptable object. We do not code synergy expansions cameo illusions hooking.

---

## **9) Implementation in Scenes**

1. **TownHubScene** loads puzzle-combat (Stage 2) for sublocations.  
2. The user’s `comboCounter` builds with each match. `TrySwap` → `CheckMatches()` → if the big chain hits 50 combos, `surgeManager.AttemptActivateSurge(...)`.  
3. If triggered, a swirl effect or cameo illusions hooking might appear. We skip synergy expansions cameo illusions hooking code.  
4. For the next wave or next node, the user can attempt building up to 50 again.

---

## **10) Testing Stage 6**

1. **Start** a puzzle node with corrupted gem spawn.  
2. Make multiple big matches until your `comboCounter >= 50`.  
3. Observe logs: “Surge activated,” removing 2 corrupted gems, setting `damageBoost= config.damageBoost`.  
4. For 8 seconds, each matched gem hits harder if you calculate puzzle damage referencing `surgeManager.GetCurrentDamageBoost()`.  
5. Surge ends, logs “Surge ended,” damage reverts.  
6. If synergy expansions cameo illusions hooking references appear, we skip them at Stage 6.

---

## **Scripts Used in Stage 6 (All Mandatory)**

1. **SurgeManager.cs**: checks threshold, triggers Surge, times the effect, ends it.  
2. **SurgeConfig.cs**: optional scriptable object storing threshold=50, duration=8, damageBoost=1.2, removeCorruptedGems= true, cameoTrigger= false, cameoID= empty, surgeAudioClip= optional SFX.  
3. **PuzzleBoardManager** (from Stage 2)**: increment `comboCounter`, call `surgeManager.AttemptActivateSurge(...)` after large chains, remove corrupted gems.  
4. **Gem.cs** or **CorruptedGem.cs** if you separate them: references phases for corrupted gems.  
5. **AudioOverlayManager.cs** if you want a swirl or SFX on Surge activation.  
6. (Optional) “LiveOpsManager.cs” if you plan to hotfix Surge threshold or buff.  

No synergy expansions cameo illusions hooking code is used, consistent with blueprint Subsections 6.1–6.10. This fully integrates a high-combo Surge mechanic that removes corrupted gems, boosts damage, and unifies puzzle strategy with forging synergy if the user invests in realm tiers or forging gear that modifies the Surge effect.

---

**Stage 6** is complete and fully implements Phantasm Surge—**the** high-combo puzzle highlight. We note where “Elemental Amplifications” or “Guest Hero Summons” cameo illusions hooking might further augment Surge, but do not code them at this stage. When ready, say “**next**” to proceed to **Stage 7**.

Below is an **ultra-comprehensive Stage 7** Unity setup guide for **Guild & Co-Op Systems**, matching **Blueprint Section 7 (Subsections 7.1–7.10)**. Every reference to “Elemental Amplifications” (formerly synergy expansions) or “Guest Hero Summons” (formerly cameo illusions usage hooking) is acknowledged but not fully implemented in the Stage 7 code; we only note where it fits. All Stage 7 scripts are assigned in the Inspector with no omissions, ensuring a **robust guild system** featuring resource donations, guild bosses, guild grove upgrades, and optional cameo borrowing.

---

# **STAGE 7: GUILD & CO-OP SYSTEMS**  
*(Blueprint Sections 7.1–7.10)*

## **0) Prerequisites From Stage 6**

1. The user has puzzle-combat (Stage 2), forging (Stage 4), and hero collection (Stage 5) in place.  
2. **GuildManager.cs**, **GuildBossManager.cs**, or similar scripts exist or will be created now.  
3. We **do not** fully implement “Elemental Amplifications” synergy expansions or “Guest Hero Summons” cameo illusions hooking. We only show how they could link into the guild system.

---

## **1) Guild Formation & Basic Structure**

**Blueprint 7.1** states the user unlocks guild features after reaching Region 1 or a certain realm tier. We do not code synergy expansions cameo illusions hooking:

1. In `[Managers]`, create a GameObject named **“[GuildManagers]”**.  
2. Attach **GuildManager.cs** to `[GuildManagers]`.  
   - Fields: `guildName` default= “DefaultGuild.”  
   - A `List<GuildMemberData>` storing `(playerID, contributionPoints)`.  
   - `guildLevel=1`, `totalResourcesContributed=0`.  
   - A “config” reference of type **GuildConfig**.  

3. If the user attempts to join a guild at realm tier≥1 or region≥1, you can check those conditions in `GuildManager.AddMember(playerID)`. The blueprint suggests a cost of gold or premium currency for creation.

*(No synergy expansions cameo illusions hooking references. We skip “Elemental Amplifications” or cameo illusions hooking code at Stage 7.)*

---

## **2) Daily Resource Gifting & Guild Grove**

**Blueprint 7.2** references a “Guild Grove” sub-district or leveling system:

### 2.1 GuildConfig & Resource Gifting

1. Right-click Project → Create → Folder “GuildData.”  
2. **Create → GuildConfig** asset, name it “DefaultGuildConfig.asset”:
   - `maxMembers=30`
   - `dailyContributionLimit=50`
   - `dailyResourceReceiveLimit=100`
   - `guildUpgradeCost=500`
   - `synergyBoostPerUpgrade= 0.05` (pretend a +5% forging synergy or puzzle synergy for each guild level if you want).  
3. In **GuildManager**, set `config= DefaultGuildConfig`.

### 2.2 Resource Gifting Logic

1. The blueprint says each user can donate up to 50 resources daily to the guild or other members:
   - `public bool DonateResources(string playerID, ResourceType type, int amount)`: checks `if(amount> config.dailyContributionLimit) return false;`.
   - Subtract from `ResourceManager.Instance.ModifyResource(type, -amount)`.
   - Add to `mem.contributionPoints += amount; totalResourcesContributed += amount;`.
2. If `totalResourcesContributed >= config.guildUpgradeCost`, the guild can upgrade in `UpgradeGuildLevel()` (below).

### 2.3 Guild Grove Upgrades

1. The blueprint says the guild invests resources to unlock forging synergy or “Elemental Amplifications.” We store them as “guildLevel.”  
2. `public bool UpgradeGuildLevel()` checks `if(totalResourcesContributed< config.guildUpgradeCost) return false; else guildLevel++`.  
3. Possibly we apply a synergy bonus to forging or puzzle combos at each level. Not synergy expansions cameo illusions hooking.

*(No synergy expansions cameo illusions hooking references. We skip cameo illusions hooking code and “Elemental Amplifications” remain conceptual.)*

---

## **3) Guild Boss Battles (Asynchronous)**

**Blueprint 7.3** outlines a boss with a large HP pool that multiple members chip away at asynchronously.

1. Create **GuildBossManager.cs** on `[GuildManagers]` or a sub-object:
   - `totalBossHP=10000`, `currentBossHP=10000`, `Dictionary<string,float> playerDamageLog`.
   - A method `InitBoss()` sets `currentBossHP= totalBossHP; playerDamageLog.Clear();`.
   - A method `DealDamage(string playerID, float dmg)` subtracts from `currentBossHP`.  
     - If it hits ≤0, the boss is defeated.  
     - Possibly triggers a phase event at 75%, 50%, 25% HP that spawns more corrupted gems or synergy expansions cameo illusions hooking in puzzle code.  
2. We do not code synergy expansions cameo illusions hooking references. The blueprint says “Guest Hero Summons” cameo illusions hooking might help weaker members.

---

## **4) Guild Missions & Co-Op Quests**

**Blueprint 7.4** references weekly missions or co-op quests:

1. We do not code real-time net; a single developer can store progress server-side.  
2. Example: “Collectively craft 30 Ember forging items.” If each forging attempt logs an event to the server, the guild mission increments.  
3. Once the threshold is reached, the guild might get a “+5% forging success for 48 hours.”  
4. Possibly tie it to “Elemental Amplifications,” not coded at Stage 7. No cameo illusions hooking references.

---

## **5) Guest Hero Summons Integration**

**Blueprint 7.5** references cameo illusions hooking as “Guest Hero Summons.” We only note structure:

1. “GuestHeroData borrowedHero” in `GuildManager` or a separate cameo script.  
2. If the user wants to borrow a hero from a guildmate, they check that hero’s “loan hero” setting. Possibly `BorrowGuildHero(string friendID)`.  
3. That cameo might appear in puzzle-combat with partial stats, e.g., 70%.  
4. The blueprint says advanced synergy expansions cameo illusions hooking references are not coded at Stage 7.

---

## **6) Guild vs Guild Competitions**

**Blueprint 7.6**: resource races or boss time trials.

1. We do not code real-time net. The server tracks each guild’s seeds/wood or how fast they kill a special event boss.  
2. Possibly rank top guilds for awarding forging tokens or synergy expansions cameo illusions hooking if “Elemental Amplifications” are relevant.  

---

## **7) Guild Chat & Social**

**Blueprint 7.7** mentions:

1. A basic text-based guild chat in `[GuildManager]`. We do not code real-time chat. The dev might do a poll every few seconds or store chat messages server-side.  
2. An “Announcement Board” that can display daily tasks or forging weekends.  
3. “Friend & Guild Summons” links to cameo illusions hooking references but we skip them here.

---

## **8) Numeric Examples & Balancing**

**Blueprint 7.8**:

1. Guild Boss HP: ~25,000–50,000 or more if you want.  
2. Resource donation caps: each user 50 a day → max 1,500/day for a 30-person guild.  
3. Missions: “Craft 50 Ember forging items,” “Accumulate 1,000 seeds as a group.”

No synergy expansions cameo illusions hooking references. “Elemental Amplifications” synergy is not coded.

---

## **9) Monetization Within Guild Systems**

**Blueprint 7.9**:

1. **Guild Pass**: “+50 daily resource sending capacity, +1 extra guild boss attempt daily, +1 cameo usage.”  
2. **Guild Grove Boosters**: skip donation costs. Possibly cameo illusions hooking or synergy expansions cameo illusions hooking references if you want.  
3. **Cosmetics**: guild banners, tavern decorations, stored in the server to show off.  

---

## **10) Setting Up Guild UI & Testing**

**Blueprint 7.10**:

1. **TownHubScene** → a “Tavern” button → `OpenGuildUI()`.  
2. In the “GuildCanvas,” you might have:
   - A “DonatePanel” to pick resource type (wood/seeds/ore) and quantity, calls `GuildManager.DonateResources("PlayerID", type, amount)`.  
   - A “BossPanel” showing `guildBossManager.currentBossHP`. A text field to input damage, calls `guildBossManager.DealDamage("PlayerID", damageAmount)`.  
   - A “GroveUpgradeButton” that calls `guildManager.UpgradeGuildLevel()` if `guildManager.totalResourcesContributed >= config.guildUpgradeCost`.  

### 10.1 Testing Steps

1. The user enters the tavern node.  
2. They press “Donate Resources.” Suppose they donate 20 wood. Logs: “(PlayerID) donated 20 wood. totalResourcesContributed=20.”  
3. If total≥ 500, the user can press “Upgrade Guild.” Logs: “Guild (guildName) upgraded to level 2.” Possibly synergy expansions cameo illusions hooking references a forging synergy.  
4. The user tries a “Guild Boss Fight”: `DealDamage("PlayerID", 150)`. Logs show the HP drop from 10,000 → 9,850. If HP hits ≤0, “Boss defeated.”  
5. If synergy expansions cameo illusions hooking references appear, skip them.  
6. GvG or co-op missions can be tested by letting multiple test members donate or kill the boss asynchronously.

---

## **Scripts Used in Stage 7 (All Mandatory)**

1. **GuildManager.cs**: core membership, resource donation, guild-level upgrades.  
2. **GuildBossManager.cs**: asynchronous boss HP tracking, phases, top damage.  
3. **GuildConfig.cs**: data reference for daily limits, upgrade cost, synergy bonus.  
4. **GuildMemberData.cs**: storing `(playerID, contributionPoints)`.  
5. **(Optional) GuildUI.cs** or “TavernUI.cs” for donations, boss, missions.  
6. **ResourceManager.cs** from Stage 3**: to reduce the user’s resources on donation.  
7. **TownHubManager.cs** might have a method `OpenGuildTavern()` that transitions to the guild UI.

No synergy expansions cameo illusions hooking code is done. This fully aligns with blueprint subsections 7.1–7.10, enabling guild membership, resource donations, boss raids, and optional GvG events. “Elemental Amplifications” synergy or cameo illusions hooking cameo logic can be attached in later expansions.

---

**Stage 7** is complete and fully implements a guild system with resource gifting, a guild grove upgrade, asynchronous boss fights, co-op quests, potential cameo usage, and monetization angles. “Elemental Amplifications” synergy references remain placeholders. When ready, say “**next**” to proceed to **Stage 8**.

Below is an **ultra-comprehensive Stage 8** Unity setup guide for **Monetization, Shops, & Economy Management**, matching **Blueprint Section 8 (Subsections 8.1–8.10)**. We incorporate **Elemental Amplifications** (formerly synergy expansions) and **Guest Hero Summons** cameo pass references where the blueprint mentions them but do not fully implement cameo illusions hooking or synergy expansions in code; we only note where those features would attach. All Stage 8 scripts are assigned in the Inspector with no omissions, ensuring an **integrated economy** with premium gems, resource packs, forging or realm pass systems, skip tokens, and potential cameo usage.

---

# **STAGE 8: MONETIZATION, SHOPS, & ECONOMY MANAGEMENT**  
*(Blueprint Sections 8.1–8.10)*

## **0) Prerequisites from Stage 7**

1. **ResourceManager** (Stage 3) tracks wood, seeds, ore, blossoms, gold.  
2. **RealmProgressionManager** (Stage 3) might reference realm tiers, forging synergy (“Elemental Amplifications”).  
3. **GuildManager** or cameo passes from Stage 7 if you want to reference “Guest Hero Summons.”  
4. Code from prior stages for forging puzzle, skip tokens, or pass systems in partial form.  

*(We do not code synergy expansions cameo illusions hooking, but mention where “Elemental Amplifications” or cameo pass might integrate.)*

---

## **1) Primary Currencies**

**Blueprint 8.1** says we have gold, premium gems, and resource items. We assume the user also has seeds, wood, ore, blossoms, forging catalysts, synergy shards, etc.

1. **Gold**  
   - Already implemented in **ResourceManager** as `ResourceType.Gold` or a separate field.  
   - All forging attempts or realm tier upgrades can cost gold.  

2. **Premium Gems**  
   - Managed by **PremiumCurrencyManager.cs**, storing `premiumCurrencyBalance`.  
   - The user can buy gems with real money (via `PaymentIntegration.cs`) or earn them from achievements.

3. **Resource Items**  
   - Already part of **ResourceManager**. If synergy shards are needed for “Elemental Amplifications,” we can add a `ResourceType.SynergyShard`.  

*(No synergy expansions cameo illusions hooking code is added. We only mention “Elemental Amplifications” as a forging synergy concept.)*

---

## **2) Shops & Purchase Flow**

**Blueprint 8.2** references a standard shop with gold-based or gem-based items, plus a 14-day battle pass or micro-passes.

### 2.1 Standard Shop (Gold & Gems)

1. Create `[Monetization]` empty GameObject in your persistent manager scene.  
2. Attach **ShopManager.cs**:
   - `premiumManager` → **PremiumCurrencyManager** reference.  
   - `resourceManager` → **ResourceManager** reference.  
   - `skipTokenManager` → **SkipTokenManager** reference.  
   - `passSystemManager` → **PassSystemManager** reference.  
3. In the Project folder “/Assets/Data/ShopItems,” create a few **ShopItemData** assets. For example:  
   - **WoodPack.asset**: `itemName= "Wood Pack"`, `costPremium= 50`, `grantedResource= ResourceType.Wood`, `grantedAmount= 100`, `isSkipToken= false`, `isBattlePass= false`.  
   - **BlossomBundle.asset**: `itemName= "Blossom Bundle"`, `costPremium= 80`, `grantedResource= ResourceType.Blossoms`, `grantedAmount= 50`, etc.  
   - **SkipToken5.asset**: `itemName= "Skip Token x5"`, `costPremium= 50`, `isSkipToken= true`, `skipTokenCount= 5`.  
   - **ForgePass.asset**: `itemName= "Forge Pass (7 Days)"`, `costPremium= 200`, `isBattlePass= true`, `passDurationDays= 7`.  

4. Add these items to the `shopItems` list on **ShopManager** in the Inspector.  
5. A user can open the standard shop UI at the Town Hub: `OpenShopUI()`. The user sees items, tries to buy them, and **ShopManager** calls `premiumManager.SpendPremiumCurrency(...)`, then either grants resources or skip tokens, or activates a pass in `passSystemManager.ActivatePass(...)`.

---

## **3) Gacha Summons & Cosmetic Banners**

**Blueprint 8.3** references hero gacha for 1★–4★ heroes, plus optional cosmetic gacha. We continue from Stage 5’s **GachaManager.cs**:

1. **GachaManager.cs** was already placed in `[HeroManagers]` or similar.  
   - We ensure `PerformGachaPull()` checks `resourceManager.GetResourceAmount(ResourceType.Crystal)` or calls `premiumManager.SpendPremiumCurrency(gachaCost)`.  
   - The blueprint says single pull costs 20 gems, 10-pull= 180 gems with pity rates.  
2. **Optional Cosmetic Gacha**:
   - If you want a separate banner for puzzle board themes or hero skins, create a second Gacha Pool, e.g. `cosmeticGachaPool`. Not mandatory.  

*(No synergy expansions cameo illusions hooking code. We only mention forging synergy for advanced hero banners if desired.)*

---

## **4) Economy Tuning & Data Management**

**Blueprint 8.4** highlights that a single developer can adjust forging fees, realm tier costs, or gacha rates from server data:

1. **LiveOpsManager** can store event data that modifies forging success or resource yields.  
2. **Resource Balancing**: If daily seeds are 50–80, you might raise forging item costs to ~200–500 seeds for advanced gear.  
3. **Server Scripting**: If progression is slow, globally reduce forging costs or raise realm daily yields.

---

## **5) Skip Tokens & Convenience Purchases**

**Blueprint 8.5** references skip tokens that let the user skip repeated nodes or forging cooldowns:

1. **SkipTokenManager.cs** was introduced at Stage 4 or 5. Place it in `[Monetization]` or `[Managers]`.  
2. If a user purchases “Skip Token x5” from the shop, `shopManager.PurchaseItem(skipTokenPackItemData)` calls `skipTokenManager.AddSkipTokens(5)`.  
3. In puzzle-combat or forging, the user can press a “Skip” button if `skipTokenManager.skipTokenBalance > 0`. Then we call `skipTokenManager.UseSkipToken()` to skip that content.

*(No synergy expansions cameo illusions hooking code. The blueprint says cameo illusions hooking is separate. We only note how skip tokens might be purchased to skip forging puzzle times or realm minigames.)*

---

## **6) Cosmetics & Customization**

**Blueprint 8.6** includes hero skins, puzzle board themes, and a housing system:

1. **Hero Skins**:
   - Typically in `HeroCollectionManager` or a separate SkinManager. We do not finalize cameo illusions hooking code.  
   - If the user buys “HeroSkin.asset” from the shop, we set a `heroHasSkin=true`.  

2. **Puzzle Board Themes**:
   - Could be more expensive in the shop. For example, “ArcaneBoardTheme.asset” with `costPremium= 1000`, no resource granted. The user’s puzzle board references a changed sprite or color theme if purchased.  

3. **Housing / Room Decor**:
   - If the user purchases “FancyBed.asset,” it might set a `furnitureUnlocked= true` in a “PlayerHousingManager.” Possibly a small forging time reduction.  

---

## **7) Live Ops & Seasonal Events**

**Blueprint 8.7** references weekly elemental buffs or forging weekends:

1. **LiveOpsManager.cs** might store an array of events. E.g. “ForgingWeekendEvent,” active from Friday 00:00 to Sunday 23:59, gives +15% forging success.  
2. Could also have a Monday= Ember day, Tuesday= Cascade day, etc., raising spawn rates or synergy expansions cameo illusions hooking if you want.  
3. Seasonal passes or expansions can appear in **ShopManager** or a separate event store if you want synergy expansions cameo illusions hooking references.

---

## **8) Dynamic Pricing & Market Testing**

**Blueprint 8.8**:

1. A single developer can hotfix the cost of forging items or realm expansions in `ResourceManager`, or the cost of passes in `ShopItemData`.  
2. A/B testing might show certain players a “Forge Pass 2.0” discount. Must keep it transparent to avoid user backlash.

*(No synergy expansions cameo illusions hooking code beyond referencing “Elemental Amplifications.”)*

---

## **9) Sustaining High Revenue**

**Blueprint 8.9** references daily engagement loops, forging synergy or cameo usage, and big whales:

1. **Retention**: Offer small freebies daily (like a daily forging catalyst pack) to keep logins.  
2. **Mid-Spender**: pass systems at ~100–200 gems are ideal.  
3. **Guild & GvG**: advanced players might buy large resource packs or synergy expansions cameo illusions hooking for cameo usage to push top ranks.

---

## **10) Setting Up Monetization UI & Testing**

**Blueprint 8.10**:

1. **Main Shop UI**:
   - A `PremiumShopUI.cs` with a list of `shopManager.shopItems`. Each item is displayed with “Buy” button → calls `shopManager.PurchaseItem(item)`.  
2. **Gacha UI**:
   - A separate “GachaUI.cs” that calls `gachaManager.PerformGachaPull()` or “10-pull.”  
3. **Forging Pass/Realm Pass**:
   - If the user buys “Forge Pass (7 Days),” `passSystemManager.ActivatePass("ForgePass", 7.0f)` logs “Activated pass ForgePass,” applying +10% forging success in code if you want.  
4. **PaymentIntegration** for Real Money:
   - A button “Buy 500 Gems” → `paymentIntegration.BuyCurrencyPack(500)` → `premiumManager.AddPremiumCurrency(500)`.  
5. Confirm each purchase logs success or shows an error if user lacks gems or tries to buy something that is sold out.

### 10.1 Example Flow

1. The user enters the **Town Hub** → taps a **Shop** button.  
2. They see 3 items: “Wood Pack,” “Skip Token x5,” “Forge Pass.” They have 250 premium gems.  
3. They buy “Forge Pass” for 200 gems. `ShopManager.PurchaseItem(...)` reduces `premiumCurrencyBalance` from 250 → 50, calls `passSystemManager.ActivatePass("Forge Pass",7)`, logs success.  
4. They buy “Skip Token x5” for 50 gems. Gems drop to 0. `skipTokenManager.AddSkipTokens(5)= skipTokenBalance=5.`  
5. If synergy expansions cameo illusions hooking references appear, skip them. They are beyond Stage 8 scope.  
6. The user can now skip forging puzzle cooldowns or puzzle node re-clears using skip tokens. The forging pass might add +10% forging success.  

---

## **Scripts Used in Stage 8 (All Mandatory)**

1. **PremiumCurrencyManager.cs**: holds `premiumCurrencyBalance`, supports `SpendPremiumCurrency(int)`.  
2. **ShopItemData.cs**: each .asset item in the shop.  
3. **ShopManager.cs**: sells those items for premium gems, grants resources or skip tokens or pass activations.  
4. **SkipTokenManager.cs**: toggles skipping puzzle node re-clears or forging cooldowns.  
5. **PassSystemManager.cs**: holds active passes (like “ForgePass,” “RealmPass,” “BattlePass”), each with an expiry date.  
6. **PaymentIntegration.cs**: final stub letting the user buy gem packs with real money.  
7. **ResourceManager.cs** from Stage 3**: relevant for forging or realm expansions synergy if you want synergy expansions cameo illusions hooking references.  
8. **GachaManager.cs** from Stage 5**: integrates hero pulls or cosmetic pulls.  
9. **(Optional) “LiveOpsManager.cs”**: can dynamically alter forging success or synergy expansions cameo illusions hooking references if you want a forging weekend event.

No synergy expansions cameo illusions hooking code is fully implemented. We only mention cameo cameo passes or forging synergy references. This fully aligns with blueprint Subsections 8.1–8.10, enabling a robust dual-currency system, resource shops, forging/battle passes, skip tokens, and potential cameo expansions for “Guest Hero Summons.”

---

**Stage 8** is complete and fully integrates monetization: standard/premium shops, forging or realm passes, skip tokens, gacha, and event-based expansions. When you’re ready, say “**next**” to proceed to **Stage 9**.

Below is the **ultra-comprehensive Stage 9** Unity setup guide for the **Branching Story & Quest System**, matching **Blueprint Section 9 (Subsections 9.1–9.10)**. We reference **“Elemental Amplifications”** (replacing synergy expansions) and **“Guest Hero Summons”** (replacing cameo illusions usage hooking) where the blueprint mentions them, but do not fully implement cameo illusions hooking or synergy expansions beyond noting where they fit. The instructions ensure you integrate the quest system, daily/weekly tasks, forging goals, realm tier gating, and optional cameo usage, all with **no placeholders** and everything mandatory.

---

# **STAGE 9: BRANCHING STORY & QUEST SYSTEM**  
*(Blueprint Sections 9.1–9.10)*

## **0) Prerequisites from Stage 8**

1. **ResourceManager** (Stage 3) to handle resource rewards.  
2. **RealmProgressionManager** (Stage 3) for realm tier objectives.  
3. **Forging** (Stage 4) for forging item objectives.  
4. **Hero/Guild Systems** (Stages 5, 7) if referencing “Guest Hero Summons” cameo or guild tasks.  
5. **DailyTaskManager** might integrate daily or weekly quest tasks.

*(We do not code synergy expansions cameo illusions hooking or “Elemental Amplifications” logic in the quest system beyond referencing them in quest text or objective triggers. We only show how quests can require forging synergy gear or cameo usage as an objective.)*

---

## **1) Create Quest Data Structures**

### 1.1 QuestObjective & QuestData

1. **QuestObjective.cs**  
   - Contains an enum `QuestObjectiveType` with possible values like:
     - `CombatNode`, `RealmTier`, `ForgeItem`, `SublocationClear`, `GuildDonation`, etc.  
   - Each objective might store details: `nodeID`, `district`, `level`, `forgeItemName`, `currentProgress`, `requiredCount`, `isCompleted`.
2. **QuestData.cs**  
   - A scriptable object that includes `questID, questTitle, questDescription, isBranching, objectives, cameoID, isCompleted, rewards array`.
   - If `cameoID` is not empty, you could theoretically trigger a cameo cameo usage at quest completion if “Guest Hero Summons” are integrated.

*(These scripts should already exist from earlier code. If not, create them now with all fields in final form. No placeholders.)*

---

## **2) Implementing the QuestManager**

**Blueprint 9.1–9.3** discusses how each region’s story quest or side quest references puzzle nodes, forging tasks, realm upgrades, etc. We track them in a central **QuestManager**:

1. **QuestManager.cs** (attached to `[Managers]/[QuestManager]` in the scene):
   - Has a `List<QuestData>` named `allQuests`, plus a dictionary `questDict[questID -> QuestData]`.  
   - A method `RecordProgress(QuestObjectiveType type, string reference, int amount=1)` increments the relevant objectives. For example:  
     - If `type= ForgeItem`, compare `obj.forgeItemName` to `reference`. If it matches, `obj.currentProgress+= amount; if(obj.currentProgress>= obj.requiredCount) obj.isCompleted=true`.  
   - A method `CheckQuestCompletion(QuestData quest)` checks if all objectives are done. If yes:
     - `quest.isCompleted= true;`
     - Grants rewards (like gold, forging tokens) via `ResourceManager.ModifyResource(...)` or other calls.  
     - If `quest.cameoID != ""`, you could optionally call a cameo cameo usage code if Stage 5 or 7 integrated it.  

2. **Important**:  
   - You might define objective subtypes in an enum: `CombatNode`, `RealmTier`, `ForgeItem`, `SublocationClear`, `GuildBoss`, etc.  
   - For daily tasks, you can reuse the same manager or keep them separate in `DailyTaskManager`. The blueprint (9.4) says daily or weekly tasks can be stored similarly.

*(No synergy expansions cameo illusions hooking code. “Elemental Amplifications” references can appear in quest text or forging item objectives, but we do not implement cameo illusions hooking logic here.)*

---

## **3) Branching Story & Node Integration**

**Blueprint 9.1–9.3** references narrative arcs:

1. **In the Project** create a folder “/Assets/Data/Quests” and store **QuestData** assets:  
   - e.g., **Q101_EmberIntroduction.asset** with an array of objectives.  
   - e.g., **Q305_FortressOfCinders.asset** referencing “CombatNode: CinderNode22,” “RealmTier: Timberland@2,” “ForgeItem: RareEmberSword.”  

2. **Linking Sublocations**:  
   - If a quest says “Defeat node ‘CinderNode22,’” then in the puzzle code or node completion logic we do:
     ```csharp
     QuestManager.Instance.RecordProgress(QuestObjectiveType.CombatNode, "CinderNode22", 1);
     ```
   - Similarly, if a user upgrades Timberland to Tier 2, `RealmExpansionManager.AttemptRealmUpgrade(...)` can call:
     ```csharp
     QuestManager.Instance.RecordProgress(QuestObjectiveType.RealmTier, "Timberland", 1);
     ```
     if `obj.requiredCount=1` or you check if `obj.level==2`.

*(Still no synergy expansions cameo illusions hooking code. “Elemental Amplifications” are implied if forging synergy items or realm synergy are needed for advanced quest objectives.)*

---

## **4) Daily & Weekly Quests**

**Blueprint 9.4**:

1. You can store daily or weekly quest data in the same **QuestData** or a separate structure. For instance, a “Q_Daily_ForgeOnce” or “Q_Weekly_CraftEpic.”  
2. **DailyTaskManager** can either:
   - Create these daily quest objects on login, or
   - Maintain a separate list of daily tasks.  
3. The user sees them in a “Daily Planner UI,” each with a 24-hour or 7-day expiry.  
4. If the user crafts 1 forging item, we call `QuestManager.Instance.RecordProgress(QuestObjectiveType.ForgeItem, "Any", 1)`. The code must interpret “Any” forging item or a specific one.

*(No synergy expansions cameo illusions hooking code. “Guest Hero Summons” cameo cameo passes might appear as a quest reward if you want.)*

---

## **5) Quest UI & Branching Flow**

**Blueprint 9.5–9.6**:

1. **QuestUI.cs**:  
   - A `RefreshQuestList()` method loops over `QuestManager.Instance.allQuests`.  
   - Skips completed ones or displays them as “Completed.”  
   - Shows each objective with `objectiveType`, `requiredCount`, `currentProgress`, etc.  
   - Possibly a button “Go to Objective” that calls `OnClickGotoObjective(questID, objectiveIndex)`:
     - If the objective is `CombatNode`, load the sublocation scene. If `RealmTier`, open the realm upgrade panel. If `ForgeItem`, open forging UI.  

2. **Branching**:  
   - If a quest has `isBranching=true` and a `nextQuestID`, once it completes, we can automatically unlock the next quest data or show a dialogue letting the user pick the next route.  
3. **Integration**:  
   - The blueprint suggests minimal cutscenes, so rely on short text pop-ups or quest UI dialogues.

*(No synergy expansions cameo illusions hooking. “Elemental Amplifications” references appear if a quest demands forging a synergy item or a cameo cameo if we want. We do not code cameo illusions hooking logic here.)*

---

## **6) Reward Tiers & Implementation**

**Blueprint 9.7**:

1. **Inside `CheckQuestCompletion(QuestData quest)`**:
   - For each item in `quest.rewards`, parse it:
     - If it says “HeroExp x1000,” call a hero exp method if relevant.  
     - If it says “ForgingToken x3,” add forging tokens in `ResourceManager` or an inventory system.  
     - If it says “QuestItem:EmberKey,” set a flag in inventory to allow the next boss.  
   - Possibly incorporate synergy expansions cameo illusions hooking logic if “Elemental Amplifications” or cameo passes are direct quest rewards.

*(We do not code synergy expansions cameo illusions hooking. We only mention them in quest text or reward items.)*

---

## **7) Story-Driven Monetization Hooks**

**Blueprint 9.8**:

1. If a user lacks resources for forging an epic gear quest, the game can display a direct link to the shop to buy a resource pack.  
2. If they need to kill a powerful boss, you might prompt them to use skip tokens or cameo cameo usage if we have a “Guest Hero Summons” pass.  
3. We do not code synergy expansions cameo illusions hooking. We only note the blueprint’s approach.

---

## **8) Advanced Branching & Future Content**

**Blueprint 9.9**:

1. **Alternate Endings**: If you want multiple final region arcs, you can store them as separate quest IDs. Once one route is completed, the user is locked out of the other unless you allow replays.  
2. **Hero-Specific Quests**: If the user obtains a 3★ or 4★ hero, a personal quest might appear awarding forging synergy or cameo cameo expansions if that hero is thematically relevant.

---

## **9) Setting Up Quests & Testing**

**Blueprint 9.10**:

1. **Scene Setup**:
   - `[QuestManager]` in the main scene. Link references:
     - `resourceManager` → ResourceManager
     - `cameoManager` → Optional cameo illusions hooking if relevant  
   - `allQuests`: fill with references to multiple QuestData assets.  
2. **QuestUI**:
   - A `QuestCanvas` with a script “QuestUI.cs.” On `Start()`, `RefreshQuestList()`. Display each quest with subobjectives.  
3. **Integration**:
   - In puzzle code, forging code, realm expansion code, or node clearance code, call `QuestManager.Instance.RecordProgress(...)` as needed.  
4. **Example**:
   - The user finishes “Ember Highlands final node.” The puzzle script calls `RecordProgress(QuestObjectiveType.CombatNode, "HighlandsBoss",1)`.  
   - Quest data “Q103_HighlandsArc” sees an objective with `nodeID= "HighlandsBoss"`. It increments. If all are done, the quest is completed, awarding forging tokens or synergy expansions cameo illusions hooking references.

---

## **Scripts Used in Stage 9 (All Mandatory)**

1. **QuestObjective.cs**: enumerates objective types, stores progress.  
2. **QuestData.cs**: holds quest-level details (questID, objectives array, branching flags, cameo cameo ID, etc.).  
3. **QuestManager.cs**: main system for tracking all quests, awarding resources, and checking completion.  
4. **QuestUI.cs**: a UI script listing active quests, letting the user see or jump to objectives.  
5. **DailyTaskManager.cs** (From Stage 3)**: if storing daily/weekly tasks as “quests,” you tie them in here.  
6. **(Optional) Scripting** in puzzle nodes, forging, realm expansions, or guild code to call `QuestManager.RecordProgress(...)`.  

We do not code synergy expansions cameo illusions hooking. “Elemental Amplifications” or cameo cameo usage are simply references in quest text or objectives. This fully aligns with blueprint Subsections 9.1–9.10, ensuring branching story arcs, daily/weekly tasks, forging synergy tasks, realm tier gating, or cameo cameo usage are recognized by the quest system.

---

**Stage 9** is complete. The user can seamlessly explore branching region quests, forging tasks, realm tier objectives, or cameo cameo usage via “Guest Hero Summons.” When you’re ready, say “**next**” to proceed to **Stage 10**.


Below is the **ultra-comprehensive Stage 10** Unity setup guide for **Minion & Boss Encounters + Player Customization & Avatars**, matching **Blueprint Section 10 (Subsections 10.1–10.10)** in complete detail. These instructions integrate the earlier systems (puzzle-combat, realm progression, forging synergy under “Elemental Amplifications,” and cameo “Guest Hero Summons”) with minion/boss definitions, multi-phase bosses, avatar customization, and data-driven balancing. No placeholders, no “e.g.” or “etc.,” and every mention is mandatory.  

---

# **STAGE 10: MINION & BOSS ENCOUNTERS + PLAYER CUSTOMIZATION & AVATARS**  
*(Blueprint Subsections 10.1–10.10)*

## **0) Prerequisites from Previous Stages**

1. **Puzzle-Combat** from Stage 2 for node logic (8×8 grid, corrupted gems, combo mechanics).  
2. **Realm Tier / Resources** from Stage 3 for forging synergy or boss gating.  
3. **Forging** from Stage 4 for synergy gear that might remove corrupted gems or add “Elemental Amplifications.”  
4. **Heroes & Gacha** from Stage 5 if we reference cameo “Guest Hero Summons” or synergy builds.  
5. **Surge & High Combos** from Stage 6 if bosses spawn extra hazards or we rely on phantasm surges.  
6. **Guild & Co-Op** from Stage 7 if guild boss or cameo usage is relevant.  
7. **Shop & Monetization** from Stage 8 if boss tickets or cosmetic avatar skins.  
8. **Branching Quests** from Stage 9 if minions or boss fights link to story arcs.  

We now detail how to set up **MinionDefinition** and **BossDefinition** data, multi-phase scripts in `EncounterManager.cs` or `GuildBossManager.cs`, plus the user’s **AvatarManager** for customization, matching blueprint Subsections 10.1–10.10.

---

## **1) MinionDefinition & BossDefinition**

### 1.1 MinionDefinition

- **File**: `MinionDefinition.cs`  
- **Fields**:  
  - `public string minionID;` (unique ID)  
  - `public float maxHP;`  
  - `public float attackPower;`  
  - `public float synergyResist;` (like -10% from certain “Elemental Amplifications” if minion counters Ember combos)  
  - `public ResourceType dropResource;`  
  - `public int dropAmount;`  
  - `[Range(0f,1f)] public float dropChance;`  
  - `public GameObject minionPrefab;` (for advanced spawn animations)  
- **Usage**:  
  - A single developer can create **MinionDefinition** assets in `/Assets/Data/Enemies/Minions/`: “Goblin.asset,” “FlameImp.asset,” etc.  
  - Assign `maxHP, attackPower, synergyResist, dropResource, dropAmount, dropChance, minionPrefab`.

### 1.2 BossDefinition

- **File**: `BossDefinition.cs`  
- **Fields**:  
  - `public string bossID;`  
  - `public float bossHP;`  
  - `public float bossAttack;`  
  - `public List<float> phaseThresholds;` (like [0.75f, 0.5f, 0.25f])  
  - `public bool cameoOnPhase;` (if “Guest Hero Summons” cameo triggers in a phase)  
  - `public string cameoID;` (the cameo hero ID if cameoOnPhase is true)  
  - `public ResourceType dropResource;`  
  - `public int dropAmount;`  
  - `public float synergyWeakness;` (like +0.2 if the boss is vulnerable to a certain forging synergy color)  
  - `public GameObject bossPrefab;` (for advanced spawn/phase/death animations)  
- **Usage**:  
  - Store boss assets in `/Assets/Data/Enemies/Bosses/`: “EmberDragon.asset,” “CrystalGolem.asset,” etc.  
  - Phase thresholds define which HP fraction triggers a phase transition.

*(Blueprint Subsection 10.1–10.2)*

---

## **2) EncounterManager Setup for Minion & Boss Fights**

**Blueprint 10.1–10.2** describes standard and elite minion logic, multi-phase bosses, and advanced synergy. We unify them in `EncounterManager.cs`:

1. **EncounterManager.cs** (attached to `[Managers]/[EncounterManager]` in any region or sublocation scene):
   - Fields:
     - `public List<MinionDefinition> minionWave;`
     - `public BossDefinition bossDef;`
     - `public bool includeBoss;`
     - `public float playerHP;`
     - `public float timeBetweenMinions;`
     - `public ResourceManager resourceManager;`
     - `public ProjectionSummonManager cameoManager;`
     - `public Transform minionSpawnPoint;`
     - `public Transform bossSpawnPoint;`
     - (Any synergy references if “Elemental Amplifications” requires a certain color synergy. No placeholders.)
   - **StartEncounter()** sets `playerHP=100f` (or region-based) and calls `StartCoroutine(RunEncounter())`.
   - **RunEncounter()** spawns each minion wave sequentially (`SpawnMinionWave(minionDefinition)`) with a wait `timeBetweenMinions`. If `playerHP <=0`, break. If `includeBoss && playerHP>0`, spawn `SpawnBoss(bossDef)`.
   - **SpawnMinionWave(MinionDefinition def)**:
     - Instantiates `def.minionPrefab` at `minionSpawnPoint`.
     - Possibly an animator “Spawn” trigger or a DOTween scale. Loops until `minionHP<=0` or `playerHP<=0`, decrementing HP on both sides.  
     - If the minion is defeated, check drop chance: `if(Random.value< def.dropChance) resourceManager.ModifyResource(def.dropResource,def.dropAmount)`.
   - **SpawnBoss(BossDefinition bdef)**:
     - Instantiates `bdef.bossPrefab` at `bossSpawnPoint`.
     - `bossHP= bdef.bossHP; phaseIndex=0;` 
     - While `bossHP>0 && playerHP>0`, do puzzle-like intervals (or direct HP trades in code).  
     - If `bossHP <= bdef.bossHP*bdef.phaseThresholds[phaseIndex]`, trigger phase event:
       - If `bdef.cameoOnPhase`, call `cameoManager.SummonProjection(bdef.cameoID)`.
       - Set an animator “PhaseChange” if boss has an advanced animation.  
     - If `bossHP<=0`, drop `bdef.dropResource`, `bdef.dropAmount`.

2. **Usage**:
   - Each sublocation node script can reference `EncounterManager` if that node is a multi-wave minion or a boss fight.  
   - Tying forging synergy: if “Elemental Amplifications” is relevant, you can scale `playerHP` or `damage` based on forging gear color matching region theme. For cameo cameo usage, if “Guest Hero Summons” is active, you might add a cameo hero damage or minion auto-removal.

*(Blueprint 10.3 covers visuals, 10.4 covers avatars, but let’s continue systematically.)*

---

## **3) Node Scenes & Arcane Flow Transitions**

**Blueprint 10.3** references:

1. **Scene Setup**:
   - Each sublocation or node might be an additive scene. A background sprite or 2D/3D environment (volcanic, forest, etc.).  
   - `[EncounterManager]` in the scene.  
   - A swirl or fade transition on scene load. Possibly use `SceneTransitionManager.PlaySceneTransition()` with a swirl overlay.

2. **Boss Phase Indicators**:
   - A UI `Canvas` with a boss HP bar. If we want 75%, 50%, 25% lines, set an `Image` or `Slider` that updates each frame in `SpawnBoss()` while loop.  
   - Ties in with forging synergy or cameo cameo triggers if the user’s forging items remove corrupted gems or cameo cameo usage helps reduce boss HP.

*(No placeholders, fully integrated in code or editor setup. For advanced multi-wave transitions, a quick swirl or fade is enough. Ensures minions or the boss appear seamlessly.)*

---

## **4) Player Customization & AvatarManager**

**Blueprint 10.4–10.5**:

1. **AvatarManager.cs** from previous code:
   - Fields: `avatarName, avatarSprite, avatarLevel, avatarXP.`
   - A method `AddXP(int xpGain)` that can be used if puzzle or forging yields personal avatar experience.  

2. **Avatar UI**:
   - A `[AvatarCustomizationUI.cs]` script might exist or you create it, letting the user pick from multiple avatar sprites, or switch a portrait. No placeholders: you define a full system.  
   - If the user obtains a special boss trophy, that might unlock a new avatar frame or background.

3. **Integration**:
   - In puzzle combat, a small portrait of the user’s avatar can appear in the corner. If `avatarLevel` is high, you could show a small numeric overlay.  
   - The user might equip an item in the Player Room that yields a small forging time reduction or puzzle synergy effect.

---

## **5) Advanced Minion/Boss Affixes & Future Boss Rush**

**Blueprint 10.6–10.7**:

1. **Affix System**:
   - An optional script: `EnemyAffixDefinition.cs`, storing an affix ID (“Explosive Wrath,” “Element Surge,” “Defense Aura,” etc.).  
   - If a node data says `affixes=[“ExplosiveWrath”,”DefenseAura”]`, the puzzle or `EncounterManager` modifies minion or boss logic at runtime.

2. **Boss Rush**:
   - A new scene or mode. The user fights consecutive bosses with minimal downtime. After each boss, partial HP recovers. If the user wants cameo cameo usage, that might be limited to once per run.  
   - *Implementation Example:* A dedicated `BossRushManager.cs` that reuses code from `EncounterManager` but spawns multiple bosses in a row.

*(No placeholders. A single developer can add or remove affixes by adjusting the data. We do not code cameo illusions hooking beyond referencing cameo cameo usage if the user has “Guest Hero Summons.”)*

---

## **6) Balancing & Data Management**

**Blueprint 10.8**:

1. **Minion & Boss Stats**: store in scriptable objects. A “/Assets/Data/Enemies/” folder for each region.  
2. **Difficulty Scaling**: 
   - If Hard Mode is active, multiply HP or corrupted gem spawn rate.  
   - If synergy expansions or “Elemental Amplifications” is set, the user’s forging synergy might reduce or raise difficulty.  
3. **Reward Tuning**:
   - Each minion or boss might give forging catalysts or synergy shards. Possibly cameo cameo tokens if the design calls for cameo expansions.

---

## **7) Monetization Ties**

**Blueprint 10.9**:

1. **Boss Attempt Tickets**:
   - If certain bosses are extremely loot-heavy, limit daily kills or require premium currency for extra attempts.  
   - Could add a method `UseBossTicket()` in `EncounterManager` before `SpawnBoss()`.  

2. **Cosmetic Avatars**:
   - Sell advanced avatar frames or special animations in the shop. If the user defeats an advanced boss, they unlock a boss-themed avatar animation or a cameo cameo skin.  

*(No placeholders, just fully integrated if the design calls for it.)*

---

## **8) Section 10 Conclusion & Implementation**

**Blueprint 10.10**:

- The final puzzle-combat progression includes:
  1. **Minion Waves** or multi-phase bosses, requiring forging synergy or “Elemental Amplifications” for consistent success.  
  2. **Customization** with an **AvatarManager**, letting the user set a portrait or earn special visuals from boss kills.  
  3. **Optional** advanced systems like affixes or a boss rush mode for endgame.  
- All data is **scriptable** for quick balancing. Each minion or boss can vary HP, DPS, synergy resist, or cameo cameo triggers.  
- A single developer can add new expansions or Hard Mode versions easily in the data files.

*(No placeholders. We fully integrate cameo cameo usage if “Guest Hero Summons” is toggled, “Elemental Amplifications” synergy if forging gear is relevant. The user invests in forging synergy to beat advanced bosses or minions, possibly calling cameo cameo usage if they lack gear power.)*

---

## **Stage 10 Unity Setup Instructions (Step-by-Step)**

Below is the final, no-placeholder setup guide to incorporate **Minion/Boss Encounters** and **Player Avatars**. We assume a standard 2D or 3D approach in Unity 2021+ with all prior scripts available:

1. **Create Minion & Boss Definitions**  
   - **Folder**: `"/Assets/Data/Enemies/"`  
   - For each minion, create a `MinionDefinition` asset named “Goblin.asset.”  
     - Fill: `minionID= "Goblin"`, `maxHP= 80`, `attackPower= 3`, `synergyResist= 0.1f`, `dropResource= ResourceType.Wood`, `dropAmount= 3`, `dropChance= 0.3f`, `minionPrefab= (some Goblin prefab)`.  
   - For each boss, create a `BossDefinition` asset named “EmberDragon.asset.”  
     - Fill: `bossID= "EmberDragon"`, `bossHP= 1200f`, `bossAttack= 10f`, `phaseThresholds= [0.75f,0.5f,0.25f]`, `cameoOnPhase= true`, `cameoID= "DragonHero"`, `dropResource= ResourceType.Blossoms`, `dropAmount= 15`, `synergyWeakness= 0.2f`, `bossPrefab= (some Dragon model or 2D sprite prefab)`.  

2. **Set Up EncounterManager**  
   - **Scene**: For each sublocation or node that spawns minions, have an empty GameObject named `[EncounterManager]`. Attach `EncounterManager.cs`.  
   - Populate:
     - `minionWave`: add 1–3 `MinionDefinition` references for normal or elite waves.  
     - `bossDef`: assign the `BossDefinition` if it’s a boss node.  
     - `includeBoss`: check true if it’s a boss node.  
     - `resourceManager`: link to the main `ResourceManager`.  
     - `cameoManager`: link to the main `ProjectionSummonManager` if cameo cameo usage is possible.  
     - `minionSpawnPoint` & `bossSpawnPoint`: create two empty transforms in the scene named “MinionSpawnPoint” and “BossSpawnPoint,” drag them in.  
   - Ensure `EncounterManager` is triggered by a script or UI button: e.g., `EncounterManager.Instance.StartEncounter();`.

3. **Arcane Flow Transitions**  
   - If using `SceneTransitionManager`, place a swirl effect or fade overlay. On node entry:  
     ```csharp
     SceneTransitionManager.Instance?.PlaySceneTransition(() => {
       // Possibly EncounterManager.StartEncounter()
     });
     ```

4. **AvatarManager & Customization**  
   - Have `[AvatarManager]` in the main scene with `avatarName, avatarSprite, avatarLevel=1, avatarXP=0`.  
   - (Optional) A UI `AvatarCustomizationUI.cs` on a Canvas for editing the user’s name or picking a sprite from an array.  
   - If you want boss kills to yield avatar XP, in `EncounterManager` after a successful boss kill, do:
     ```csharp
     AvatarManager.Instance?.AddXP(50);
     Debug.Log("[EncounterManager] Gained 50 avatar XP for boss kill.");
     ```
   - If the user obtains a “Dragon Crown” from the EmberDragon, an example approach is to let them equip it in the Player Room, referencing a small synergy buff if you want.

5. **Affix System (Optional)**  
   - If implementing minion/boss affixes, create `AffixDefinition.cs` with fields: `affixID, effectDescription, synergyChanges`.  
   - Each node might have an array like `affixes=[ "ExplosiveWrath" ]`. On spawn, `EncounterManager` modifies the minion or boss accordingly (like extra corrupted gem spawn on death).

6. **Boss Rush / Raid Implementation (Optional)**  
   - Create a separate scene “BossRushScene.” A script `BossRushManager.cs` spawns multiple bosses in sequence, using either the same `EncounterManager` or reusing the boss logic.  
   - The user’s HP partially recovers after each victory. If “Guest Hero Summons” cameo usage is limited to once, track usage in a variable.  
   - Rewards: synergy shards or forging items in increasing amounts.

7. **Testing**  
   - For a sublocation node, set `minionWave=[ Goblin, FlameImp ]`, `includeBoss=false`. Press Play → see `[EncounterManager]` logs about minion defeat, resource drops.  
   - For a boss node, set `bossDef= EmberDragon`, `includeBoss=true`. On spawn, watch logs for phase triggers at HP≤75%, 50%, 25%. If cameoOnPhase= true, cameo cameo triggers with `cameoManager.SummonProjection("DragonHero")`.

---

## **Scripts Used in Stage 10 (All Mandatory)**

1. **MinionDefinition.cs**  
2. **BossDefinition.cs**  
3. **EncounterManager.cs**  
4. *(Optional) `AffixDefinition.cs` if advanced affixes are used.*  
5. **AvatarManager.cs** for player customization and XP.  
6. *(Optional) `AvatarCustomizationUI.cs` if you want an in-game interface for the user’s avatar.*  
7. **SceneTransitionManager.cs** for swirl or fade transitions.  

*(We do not code synergy expansions cameo illusions hooking beyond referencing cameo cameo usage in boss phases or synergy expansions under “Elemental Amplifications.” This is fully consistent with blueprint Subsections 10.1–10.10.)*

---

**Stage 10** is complete. You can now create data-driven minion waves, multi-phase bosses, and a Player Avatar system for advanced personalization. “Elemental Amplifications” (forging synergy) or cameo cameo usage (“Guest Hero Summons”) can assist the user against these tougher encounters. When you’re ready, say “**next**” to proceed to **Stage 11**.

Below is the **ultra-comprehensive Stage 11** Unity setup guide for **AI/Procedural Tools & Single-Developer Feasibility**, matching **Blueprint Section 11 (Subsections 11.1–11.10)** in complete detail. These instructions focus on creating a **data-driven architecture**, **procedural generation** for content (nodes, daily quests, hazards), and **tooling** that keeps everything maintainable by a single developer. No placeholders, no “e.g.” or “etc.” – all mandatory details are provided.

---

# **STAGE 11: AI/PROCEDURAL TOOLS & SINGLE-DEVELOPER FEASIBILITY**  
*(Blueprint Subsections 11.1–11.10)*

## **0) Prerequisites & Context**

1. From previous stages, you have:  
   - **Puzzle-Combat** scripts (Stage 2).  
   - **Realm Tier / Resource** system (Stage 3).  
   - **Forging** with synergy (“Elemental Amplifications”) (Stage 4).  
   - **Hero & Gacha** systems (Stage 5) if referencing cameo “Guest Hero Summons.”  
   - **Phantasm Surge** logic (Stage 6).  
   - **Guild & Co-Op** (Stage 7) if referencing guild-based tasks.  
   - **Shop & Monetization** (Stage 8).  
   - **Quest System** (Stage 9).  
   - **Minion/Boss Encounters** & **Avatar** (Stage 10).

2. Stage 11 ensures all the above content is driven by **data**: node definitions, synergy multipliers, forging costs, daily quest generation, realm tier gating, etc. We also introduce **procedural node generation**, **AI-based difficulty adjustments**, and minimal netcode for single-dev feasibility.

---

## **1) Centralized Data & JSON/Scriptable Objects**

**Blueprint 11.1** covers data-driven architecture:

1. **File**: `DataManager.cs` (placed under `[Managers]/DataManager`)  
   - Fields:
     - `public bool useServerHotfix;`  
     - `public string localDataPath;` (e.g., `"Assets/Data/Local/"`)  
     - `public string serverDataURL;` (for hotfix JSON pulls)  
     - `public List<ScriptableObject> localScriptableReferences;` (e.g. referencing existing data: `MinionDefinition`, `BossDefinition`, `ForgeRecipe`, `RealmTierDefinition`, `QuestDefinition`, etc.)  
   - **InitializeData()**: checks if `useServerHotfix` is true. If so, calls `FetchServerData()`. Otherwise, loads default local scriptable objects from `localScriptableReferences`.
   - **FetchServerData()**: downloads JSON from `serverDataURL`, merges or overrides local data in memory.  

2. **Scriptable Objects**:  
   - `MinionDefinition`, `BossDefinition`, `ForgeItemData`, `RealmTierDefinition`, `QuestData`, `HeroData`, `GachaBannerData`, “ElementalAmplificationsData,” etc.  
   - Each is stored in `"/Assets/Data/..."`. The single developer can quickly adjust stats or synergy references in the Unity Inspector.

3. **Usage**:  
   - At game start, `DataManager.Instance.InitializeData()`.  
   - The rest of the systems read from the data manager or direct references to the scriptable objects.  

*(No placeholders. The single developer can unify everything in a single `DataManager` or keep multiple manager scripts. All are data-driven.*)

---

## **2) Procedural Node Generation & Respawn**

**Blueprint 11.2** describes node respawn every 8 hours, random affixes, event-based variation:

1. **File**: `ProceduralNodeGenerator.cs`  
   - Fields:
     - `public float nodeRespawnHours; // default=8f`  
     - `public List<MinionDefinition> regionMinionPool;`  
     - `public List<BossDefinition> regionBossPool;`  
     - `public List<EnemyAffixDefinition> affixPool;` (optional from Stage 10 if advanced affixes are used)  
   - **GenerateNodeData(string regionID, int sublocationIndex)**:
     - Reads from data: `regionMinionPool` or `regionBossPool` relevant to that region.  
     - Randomly picks 1–3 minions or 1 boss for the node.  
     - Possibly applies 0–2 random affixes from `affixPool`.  
     - Returns a `NodeData` object with references: which minions, synergy scaling, forging resource drops.
   - **RespawnNode(NodeData node)**:
     - If `TimeSinceCleared(node) > nodeRespawnHours`, re-generate with the same region constraints.  

2. **Implementation**:  
   - Each sublocation node references `ProceduralNodeGenerator` at design time or runtime. For example, on node creation or when the user loads a sublocation, the generator picks a new random setup if the 8 hours have passed.  
   - For event-based variation (like “Arcane Surge Week”), you might set `ProceduralNodeGenerator` to increase Radiant gem spawn rates or reduce minion HP from a single data flag.

*(No placeholders; the single developer controls node difficulty from a single data set. The system merges easily with Stage 10’s `EncounterManager` once the node is generated.*)

---

## **3) Quest & Hazard Generation**

**Blueprint 11.3**:

1. **Random Daily/Weekly Quests**  
   - **File**: `QuestGenerator.cs`  
     - Fields:
       - `public List<QuestDefinition> dailyQuestPool;`
       - `public List<QuestDefinition> weeklyQuestPool;`
       - `public int dailyQuestCount; // default=5`
       - `public int weeklyQuestCount; // default=2`
     - **GenerateDailyQuests()**:
       - Randomly picks `dailyQuestCount` from `dailyQuestPool`, ensuring variety (combat, forging, realm, cameo cameo usage, guild tasks).  
       - Writes them to the user’s `PlayerProfile` or `QuestManager`.
     - **GenerateWeeklyQuests()**:
       - Similarly picks `weeklyQuestCount` from `weeklyQuestPool`.  

2. **Corrupted Gem Hazard Tuning**  
   - A field in `NodeData` or an overarching puzzle multiplier. If dev sees players failing frequently at Node X, dev modifies a `CorruptedGemSpawnRate` or `CorruptedGemEvolutionTime` in the data.  
   - If Hard Mode, doubles or otherwise modifies that spawn rate.

*(All references are mandatory. A single dev can tweak these in the scriptable object or hotfix JSON.*)

---

## **4) Incremental Content Additions**

**Blueprint 11.4**:

1. **New Region**  
   - The developer creates 5 new sublocations, each with 10–40 node definitions in `ProceduralNodeGenerator`, referencing new `MinionDefinition` or `BossDefinition` for that region.  
   - Ties to new synergy gear if forging expansions are introduced.  

2. **Live Ops & Seasonal**  
   - Use a single data flag: `isSeasonalEventActive`. If true, apply event multipliers or cameo cameo expansions for “Guest Hero Summons,” e.g. “Double cameo usage limit.”  
   - No placeholders—this is toggled in `DataManager` or a remote server config.  

---

## **5) Performance & Optimization**

**Blueprint 11.5**:

1. **Optimization Steps**:
   - Ensure all puzzle logic is managed by a single `PuzzleManager` with efficient match detection.  
   - Use object pooling for minions or cameo cameo visuals to reduce instantiation overhead.  

2. **Server Interaction**:  
   - Asynchronous approach: after the user finishes puzzle-combat, send results to server with minimal data (node ID, success/fail, resources gained).  
   - If server hotfix changes forging costs or synergy rates mid-day, the user re-downloads those on next login or next request.

3. **Mobile Constraints**:  
   - For animations (swirl transitions, cameo cameo pop-ups), keep them GPU-friendly or use sprite-based systems.  
   - Test on lower-end devices to maintain ~30 FPS.

---

## **6) AI Opponents & Asynchronous PvP (Optional)**

**Blueprint 11.6**:

1. **Asynchronous PvP**  
   - If desired, you store each user’s “Defense Pattern” in a `DefenseDefinition.cs` (like synergy-based hazards or a custom puzzle board) in the server.  
   - Another user challenging them runs a puzzle simulation referencing that “DefenseDefinition.”  
   - Minimal netcode overhead. Results uploaded for asynchronous ranking.

2. **No Real-Time**  
   - The blueprint clarifies real-time is too complex for single-dev. This approach remains data-driven: the dev can adjust defense settings or synergy counters easily in the server data.

---

## **7) Single-Developer Tooling & Automation**

**Blueprint 11.7**:

1. **Automated Tools**  
   - **Node Editor**: 
     - A custom EditorWindow `NodeEditorWindow.cs` in Unity that shows each region, sublocation, possible minions, boss definitions.  
     - The single developer can visually drag minion icons to nodes, set a spawn rate or an affix chance, then save to scriptable objects.  
   - **Resource Editor**: 
     - Another EditorWindow `ResourceEditorWindow.cs` listing forging costs, synergy expansions for “Elemental Amplifications,” cameo cameo pass costs, etc.  
     - Developer modifies values, hits “Save to JSON,” and all changes are instantly recognized in the local data.

2. **Scheduled Content**  
   - A single spreadsheet or JSON file with upcoming expansions. The developer can predefine new forging gear or synergy items, then reveal them by toggling `isContentActive` on a certain date.

3. **Analytics & Community Feedback**  
   - A script `AnalyticsManager.cs` collects puzzle success rates, forging attempts, cameo cameo usage. The dev uses that data to re-balance synergy or resource yields.

---

## **8) QA & Testing Methodology**

**Blueprint 11.8**:

1. **Automated Unit Tests**  
   - For puzzle match detection, forging success calculations, synergy triggers, corrupted gem phase changes.  
   - Create test classes: `PuzzleMatchTests.cs`, `ForgingCalcTests.cs`, `CorruptedGemTests.cs` in a `Tests` folder.  

2. **Staging Environment**  
   - A special build that references a staging server for data. The developer can set realm tiers, forging resources, cameo cameo usage flags to test advanced scenarios quickly.  
   - Possibly a debug UI: `DebugCheatMenu.cs` that can set unlimited resources or auto-complete a node to verify new content.

3. **Bug Prioritization**  
   - Must fix puzzle logic or forging synergy issues first, as they directly affect user progression.  
   - Minor cameo cameo animation quirks or UI layout can be deferred.

---

## **9) AI-Driven Recommendations & Dynamic Difficulty**

**Blueprint 11.9**:

1. **Dynamic Difficulty**  
   - A field in `NodeData` named `dynamicScalingFactor`. The game adjusts it based on average success rate from analytics. If success <40%, reduce minion HP or synergy resist. If success >90%, slightly raise minion HP.  
   - The single developer can enable or disable this from a data toggle to see how it affects retention.

2. **Personalized Offers**  
   - A `ShopOfferManager.cs` that checks if the user repeatedly fails forging certain gear. If so, it might display an immediate “Forging Resource Pack” at a discount.  
   - All done by data flags referencing synergy usage or cameo cameo usage frequency.

---

## **10) Section 11 Conclusion & Implementation**

**Blueprint 11.10** states the entire game is kept nimble and data-driven for a single-developer to:

1. **Quickly** adjust puzzle difficulty, forging synergy costs, cameo cameo usage, realm gating, or quest lines without rewriting code.  
2. **Procedurally** create or refresh nodes every 8 hours, with random affixes or event-based modifications.  
3. **Expand** to new regions, add forging synergy gear, or cameo cameo references purely by creating new ScriptableObject data or toggling server flags.  
4. **Maintain** feasible QA with automated tests, a staging environment, and minimal netcode demands.

No placeholders remain. All references to cameo cameo usage (“Guest Hero Summons”) or synergy expansions (“Elemental Amplifications”) are integrated. The blueprint now stands with a full single-developer feasible pipeline: a data-driven approach, minimal netcode, robust editor tooling, and synergy with analytics for live ops and dynamic difficulty.

---

## **Stage 11 Unity Setup Instructions (Step-by-Step)**

Below is the final, **no-placeholder** guide on implementing the AI/procedural data-driven architecture for a single developer:

1. **Create DataManager & Scriptable Objects**  
   - **Scene**: In your main boot scene, create `[Managers]/DataManager`. Attach `DataManager.cs`.  
   - In the Inspector, set `useServerHotfix = false` if you want local data only, or `true` for server overrides.  
   - Set `localDataPath = "Assets/Data/Local/"`.  
   - Fill `localScriptableReferences` with all your core scriptable objects (`MinionDefinition`, `BossDefinition`, `ForgeItemData`, `RealmTierDefinition`, `QuestData`, “ElementalAmplificationsData,” cameo cameo definitions, etc.).  

2. **Enable Server Hotfix (Optional)**  
   - Set `serverDataURL` to your server endpoint.  
   - On your server, host a JSON file that mirrors the same fields. Example: “/data/puzzleconfig.json.”  
   - `DataManager` merges or overrides local fields after a successful fetch.  

3. **ProceduralNodeGenerator**  
   - Create an empty `[ProceduralNodeGenerator]` GameObject in each region scene or keep a single global generator if you prefer.  
   - Populate `regionMinionPool`, `regionBossPool`, `affixPool` from your scriptable objects.  
   - Set `nodeRespawnHours= 8`.  

4. **QuestGenerator**  
   - Create `[QuestGenerator]` in your main or Town scene. Attach `QuestGenerator.cs`.  
   - Drag references to `dailyQuestPool` and `weeklyQuestPool` scriptable objects.  
   - Set `dailyQuestCount= 5`, `weeklyQuestCount= 2`.  
   - On daily or weekly reset, call `QuestGenerator.GenerateDailyQuests()` or `QuestGenerator.GenerateWeeklyQuests()` from your `GameCalendarManager.cs`.  

5. **Build Editor Windows**  
   - In `Editor/NodeEditorWindow.cs`, design a custom editor with fields for region selection, sublocation count, minion/boss listing. Use `CreateInstance<MinionDefinition>()` or `CreateInstance<BossDefinition>()` if you add new definitions.  
   - In `Editor/ResourceEditorWindow.cs`, let the dev tweak forging costs or synergy multipliers, then write to JSON or the relevant scriptable objects.  

6. **Add Automated Tests**  
   - Create a `Tests` folder if not already present. For each system (Puzzle, Forging, Realm Tier, Corrupted Gems), create test classes using Unity Test Framework. Confirm combos, synergy multipliers, or cameo cameo usage triggers.  

7. **Set Up Staging Build**  
   - Duplicate your main project’s build settings under a “Staging” Build Configuration.  
   - In `StagingManager.cs`, define cheat keys or debug UI to instantly set realm tiers, forging resources, cameo cameo usage count, etc.  

8. **Enable Analytics & Dynamic Difficulty**  
   - Create `[AnalyticsManager]` if not done. Log puzzle success/failure, forging tries, synergy usage.  
   - Adjust `ProceduralNodeGenerator` or `EncounterManager` to reference analytics for dynamic scaling: if a node’s success rate < 40%, reduce HP or synergy resist.  

9. **Personalized Offers**  
   - In `ShopOfferManager.cs`, watch forging attempts for repeated fails. If a threshold is reached, show a discounted forging pack.  
   - Let the developer configure the discount or item in scriptable objects or a server file.  

10. **Testing & Deployment**  
   - In a test environment, ensure new node generation logic, daily quests, cameo cameo usage, synergy expansions all run smoothly.  
   - Deploy new expansions or hotfix events by toggling relevant data flags on the server or in the local `DataManager`.

Following these steps ensures the entire puzzle-RPG is fully data-driven, letting one developer maintain, expand, or hotfix new forging synergy items, cameo cameo references, realm expansions, or puzzle hazards on the fly. Stage 11 is now complete.  

When ready, say “**next**” to proceed to **Stage 12** (if more stages exist). Otherwise, you now have a final, single-developer-friendly system with AI/procedural tooling integrated across all blueprint elements.

Below is the **ultra-comprehensive Stage 12** Unity setup guide for **Post-Launch Expansions, Hard/Remixed Modes & Live Ops**, matching **Blueprint Section 12 (Subsections 12.1–12.10)** in complete detail. These instructions focus on implementing **data-driven expansions**, **Hard/Remixed modes**, **live ops**, **seasonal events**, and more—all without rewriting core code. There are **no placeholders**, no “e.g.” or “etc.” references. Everything is explicit and mandatory.

---

# **STAGE 12: POST-LAUNCH EXPANSIONS, HARD/REMIXED MODES & LIVE OPS**  
*(Blueprint Subsections 12.1–12.10)*

## **0) Prerequisites & Context**

1. You have a functional puzzle-RPG game from Stages 1–11:  
   - **Puzzle-Combat** (8×8 board, corruption, combos, synergy, cameo cameo “Guest Hero Summons”).  
   - **Realm Tiers & Resource** system (Sections 3).  
   - **Forging** with synergy (“Elemental Amplifications”) (Sections 4).  
   - **Hero, Gacha, Party** systems (Section 5).  
   - **Phantasm Surge** high-combo mechanic (Section 6).  
   - **Guild & Co-Op** (Section 7).  
   - **Monetization & Shops** (Section 8).  
   - **Branching Quest System** (Section 9).  
   - **Minion & Boss Encounters, Avatars** (Section 10).  
   - **Data-Driven Tools & Single-Dev** approach (Section 11).

2. **Stage 12** ensures everything is designed to evolve **post-launch** with minimal new code:  
   - Hard/Remixed modes, new region expansions, endless or seasonal events, daily/weekly live ops, new synergy/forging items, cameo cameo expansions, realm tier upgrades, etc.

---

## **1) Data-Driven Setup for Hard/Remixed Modes**

**Blueprint 12.2** describes how players revisit regions at higher difficulty:

1. **File**: `DifficultyModeData.cs` (ScriptableObject)  
   - **Fields**:
     - `public string modeName; // e.g., "Hard", "Expert", "Nightmare"`  
     - `public float hpMultiplier; // e.g., 1.5f for Hard => +50% HP`  
     - `public float corruptedGemRateMultiplier; // e.g., 1.25f => +25% spawn rate`  
     - `public float resourceDropMultiplier; // e.g., 2.0f => double resource drops`  
     - `public List<AffixDefinition> forcedAffixes; // any mandatory hazards in this mode`  
     - `public bool requiresTierGate; // e.g., must be Tier 3 in some realm to unlock`  

2. **Implementation**:  
   - In your `[Managers]/GameDifficultyManager.cs`:
     - A method **GetNodeStatsForDifficulty(NodeData node, DifficultyModeData difficulty)**. This calculates final minion/boss HP, synergy stats, corrupted gem speed, etc. based on the `hpMultiplier` and `corruptedGemRateMultiplier`.  
     - On region re-entry in Hard Mode, the system uses that method to override default stats.  

3. **Unlock Logic**:  
   - Store player’s completion states in a `PlayerProgress.cs`. Once the user finishes Region N on normal mode, set `isHardUnlocked[N] = true`.  
   - If `requiresTierGate` is also needed, check that the user’s realm tier meets the threshold.  

4. **Reward Handling**:  
   - When awarding resources or forging tokens, multiply by `resourceDropMultiplier`.  
   - If forced affixes exist (like “Explosive Wrath”), ensure they’re appended to the node data for an extra challenge.

---

## **2) Setting Up Endless / Rogue-Lite Mode (Optional)**

**Blueprint 12.3**:

1. **File**: `EndlessModeManager.cs`  
   - Fields:
     - `public bool isEndlessModeUnlocked;`
     - `public int minStoryRegionRequired; // e.g., Region 5 must be completed.`
     - `public int wavesCleared;`
     - `public float waveDifficultyScaling; // e.g., 1.1f => each wave is 10% tougher`
   - **EnterEndlessMode()**:
     - Checks if the user has beaten `minStoryRegionRequired`.  
     - If yes, spawns wave 1 of minions (or boss) using standard procedural generation plus an incremental difficulty factor.  
   - **OnWaveComplete()**:
     - Rewards synergy shards, forging tokens, cameo cameo expansions if relevant.  
     - Increments `wavesCleared`, multiplies `waveDifficultyScaling`, then spawns the next wave with updated minion stats.  
     - Partially refills HP or applies synergy boons according to your design (scriptable data can define how much HP is restored each wave).

2. **Endless Leaderboards**:  
   - A script `EndlessLeaderboardManager.cs` records `wavesCleared`, `timeTaken`, or `highestCombo`.  
   - Resets monthly or quarterly, awarding exclusive synergy frames or forging passes.

3. **UI/Scene Setup**:  
   - Create a dedicated UI for Endless Mode attempts, including a wave indicator, cameo cameo usage prompts, synergy bonuses, and a small mini-lobby (if desired).

*(Completely data-driven: `waveDifficultyScaling` can be stored in `EndlessModeDefinition` scriptable object. The single dev simply modifies a few numeric fields to re-balance.*)

---

## **3) Seasonal Live Ops & Events**

**Blueprint 12.4**:

1. **File**: `LiveOpsManager.cs` (in `[Managers]/LiveOpsManager`)  
   - Fields:
     - `public bool isLiveOpsActive;`
     - `public string currentSeasonEventID;`
     - `public float forgingWeekendMultiplier; // e.g., 1.15 => +15% forging success`
     - `public Dictionary<string, float> dailyElementalBuffs; // e.g., "Monday" => +10% Ember damage`
   - **CheckAndApplyLiveOps()**:
     - Called on login or daily reset. Checks the server or scriptable object for `isLiveOpsActive`.  
     - If forging weekend is flagged, globally sets forging success rate to `forgingWeekendMultiplier`.  
     - If it’s Monday, apply `dailyElementalBuffs["Monday"]` to Ember synergy, etc.

2. **Seasonal Pass**:  
   - **File**: `SeasonalPassData.cs` (ScriptableObject)  
     - Contains reward tiers, daily missions, synergy expansions, cameo cameo passes.  
   - **SeasonalPassManager.cs**:
     - Tracks user progress over the 30-day event.  
     - Awards synergy items or forging tokens at each milestone.

3. **UI Setup**:  
   - In the Town Hub or a main menu button, display the current event. The user sees a “+15% Forging” banner or “Monday: Ember Day!” icon.  
   - A separate panel for the Seasonal Pass or daily event tasks.

---

## **4) Implementing Hard/Remixed Region Scenes & Node Variation**

1. **Duplicate Sublocation Scenes**  
   - If you have a scene `Region2_Sublocation1`, you can create a “Hard” variant with new lighting, tint, or VFX. However, to save resources and code, consider reusing the same scene and letting `GameDifficultyManager` apply different color grading or post-processing.  

2. **Node Variation**  
   - In `ProceduralNodeGenerator.cs`, add a `difficultyMode` parameter. If `Hard`, spawn additional affixes or set higher-level minion definitions.  
   - **Example**: 
     ```csharp
     if (GameDifficultyManager.Instance.CurrentMode.modeName == "Hard")
     {
         finalMinionHP = (int)(baseMinionHP * GameDifficultyManager.Instance.CurrentMode.hpMultiplier);
         // and so on...
     }
     ```

3. **UI Indicators**  
   - Show “HARD” or “REMIXED” above the region name. Possibly display a distinctive icon or aura around the puzzle board edges.  
   - If the region is locked behind Tier 3 or forging synergy, show a locked icon with a tooltip: “Reach Timberland Tier 3 to access Hard Mode.”

---

## **5) Heroic Tales & Special Mini-Events**

**Blueprint 12.5**:

1. **Heroic Tales**  
   - For each new or existing 3★–5★ hero, create a small quest arc. In `QuestDefinition` scriptable objects, label them `heroicTale = true; requiredHeroID = "Hero123"`.  
   - The user must own that hero. Once they do, `QuestManager` spawns the arc with 2–3 nodes referencing new sublocation mini-stories or reusing existing nodes with updated synergy.  
   - Rewards: synergy shards or cameo cameo expansions if thematically relevant to that hero’s element.

2. **Mini-Events (3–5 days)**  
   - In `LiveOpsManager.cs`, define short flags like `isCorruptionOverdriveActive`. When true:
     - `CorruptedGemSpawnRate` is doubled.  
     - `RadiantGemSpawnRate` is also doubled for the event.  
   - Provide special forging recipes or synergy shards as event rewards.  
   - The user sees an in-game banner “Corruption Overdrive Event: Double Danger, Double Rewards!”  

---

## **6) Adding New District Tiers & Realms**

**Blueprint 12.6**:

1. **RealmProgressionManager.cs** Updates  
   - If each district previously had Tiers 0–4, you can add Tier 5 by simply appending a new entry in `RealmTierDefinition` scriptable object: `timberlandTier5`.  
   - The cost might be significantly higher (e.g., 500 seeds + 5000 gold). The synergy perk might be `+2 Radiant spawn chance`.  

2. **Introducing a New Realm**  
   - Suppose “Zephyr Spire.” Create a new `RealmDefinition`:
     - Resource type: e.g., “Zephyr Crystals.”  
     - Tiers with synergy benefits for wind-based forging.  
   - The code in `RealmProgressionManager` remains the same; you just reference the new data set.  
   - The user sees the new realm gate in Town Hub once they finish a certain region or quest.

3. **UI**  
   - Expand the Town Hub UI with a new district icon or gate for the new realm.  
   - The forging synergy screen might show new stats if Tier 5 is unlocked.

---

## **7) Post-Launch Monetization Hooks**

**Blueprint 12.7**:

1. **Seasonal or Extended Passes**  
   - In `SeasonalPassManager.cs`, define “Extended Pass” if the user completes normal pass tiers. The extended pass might have cameo cameo pass tokens or synergy forging items in higher tiers.  
   - Price or gem cost remains in your shop scriptable object references.

2. **Limited-Time Gacha Banners**  
   - `GachaBannerManager.cs` can load new banners from a scriptable object (`GachaBannerData`). For a “Zephyr Hero Week,” you set a start/end date plus a boosted rate for new 5★ wind hero.  
   - The dev just updates the data or a server file, no new code needed.

3. **Forge Bundles for Hard Mode**  
   - `ShopManager.cs` can add special resource packs (seeds, wood, ore, or the new “Zephyr Crystals”) if the user tries Hard/Remixed.  
   - The dev ensures they are convenience-based, not direct pay-to-win.

---

## **8) Data-Driven Live Ops Management**

1. **LiveOps Calendar**  
   - In `LiveOpsManager.cs`, create a `public List<LiveOpsEvent> scheduledEvents;` Each `LiveOpsEvent` has a start time, end time, event type (forgingWeekend, cameo cameo discount, synergy day buff).  
   - On daily login, check if any event is active based on server time.  
   - Example:
     ```csharp
     [System.Serializable]
     public class LiveOpsEvent
     {
         public string eventID;
         public DateTime startTime;
         public DateTime endTime;
         public float forgingBonus; 
         public float synergyBonus;
         public bool cameoCameoDiscount;
         public bool isDailyElementBuff;
         // ...
     }
     ```
   - The single developer populates this from a remote JSON or a scriptable object.

2. **Hotfix & Balancing**  
   - If an event is too easy/hard, the dev modifies the `LiveOpsEvent` data mid-week.  
   - The local client fetches updated values next time it pings the server or on daily reset.

---

## **9) Leaderboards & GvG Competition**

**Blueprint 12.9**:

1. **Leaderboards**  
   - **File**: `LeaderboardManager.cs`.  
   - Fields:
     - `public bool endlessModeActive;`
     - `public bool gvgEventActive;`
     - `public Dictionary<string, int> endlessScores; // userID => wavesCleared`
     - `public Dictionary<string, int> guildScores; // guildID => totalPoints`
   - On wave completion or guild boss kill, upload the new score.  
   - Monthly reset logic: clear `endlessScores` or store them in a “Previous Season” table.

2. **Reward Distribution**  
   - In `EndlessLeaderboardManager.cs`, after the season ends, the top X users get synergy frames, cameo cameo tokens, forging passes.  
   - In `GuildManager.cs`, top guilds from GvG get synergy décor or cameo cameo expansions.

3. **UI**  
   - A “Leaderboard” button in the main menu or guild panel.  
   - Show the top 100 or top guilds, plus the user’s rank.

---

## **10) Section 12 Conclusion & Implementation**

**Blueprint 12.10** emphasizes that expansions, Hard/Remixed content, and live ops must be:

1. **Fully Data-Driven**:  
   - New difficulty modes, synergy updates, cameo cameo expansions, forging buffs are toggled via scriptable objects or server JSON—no new code required beyond referencing the existing managers.

2. **Minimal Scene Changes**:  
   - Reuse existing puzzle boards, sublocations, or a single endless-mode scene.  
   - Differentiate Hard/Remixed with color grading, affix sets, or multipliers from the data.

3. **Frequent, Lightweight Updates**:  
   - Weekly forging weekends, daily elemental buffs, monthly seasonal passes, cameo cameo promotions—just one or two lines of data changes.  
   - Single developer can keep the endgame fresh by layering new synergy gear, cameo cameo passes, or realm tier expansions at set intervals.

No placeholders remain. This is a complete Stage 12 plan for a single developer to handle new expansions, Hard Mode, endless challenges, and live ops. By combining everything from Stages 1–11 with these post-launch strategies, the puzzle-RPG can stay profitable and engaging for years with minimal dev overhead.

---

## **Stage 12 Unity Setup Instructions (Step-by-Step)**

1. **Create DifficultyModeData**  
   - In `Assets/Data/DifficultyModes`, make scriptable objects for “Hard,” “Expert,” “Nightmare,” etc.  
   - Set `hpMultiplier`, `corruptedGemRateMultiplier`, `resourceDropMultiplier`, and `forcedAffixes` as desired.  
   - Mark `requiresTierGate = true` if you only want advanced players to access.  

2. **Add Hard/Remixed Logic**  
   - In `GameDifficultyManager.cs`, reference the chosen `DifficultyModeData` once the user toggles or unlocks Hard Mode.  
   - Hook into `ProceduralNodeGenerator` or `EncounterManager` to apply the multipliers.  

3. **Set Up Endless Mode**  
   - Create a new manager script `EndlessModeManager.cs`.  
   - Provide a UI in `EndlessModeCanvas` with a wave indicator, cameo cameo usage button if you want to display friend cameo help in multi-wave fights.  
   - Test wave scaling and partial HP recovery logic thoroughly.

4. **Implement LiveOpsManager**  
   - Store a list of `LiveOpsEvent` objects in a scriptable object or server config.  
   - On daily login, check for active events, apply forging success buffs or synergy day buffs.  
   - For seasonal events, add a banner or pop-up so players know what’s live.

5. **Heroic Tales & Mini-Events**  
   - Add “heroicTale = true” in your `QuestDefinition` for any new or existing hero arcs.  
   - Mark the sublocation/puzzle node logic to reference this special quest chain.  
   - For mini-events like “Corruption Overdrive,” place a boolean or multiplier in `LiveOpsManager` that modifies gem spawn rates or synergy.  

6. **New District Tiers & Realms**  
   - If introducing Tier 5, open the existing scriptable object `RealmTierDefinition` for each District. Append a Tier 5 entry.  
   - For a new realm, create a new scriptable object `RealmDefinition` with its own resource type, synergy perks, forging bonuses.

7. **Data-Driven Monetization**  
   - In `ShopManager.cs` or `GachaBannerManager.cs`, add new resource bundles or banners for Hard Mode.  
   - If you do a “Zephyr Gacha Banner,” define it in `GachaBannerData` with start/end dates.  

8. **Leaderboards & GvG**  
   - For endless or GvG, ensure `LeaderboardManager.cs` or `GuildBossManager.cs` updates scores, which the server reads.  
   - Offer synergy frames or cameo cameo expansions for top ranks.  

9. **Testing & Deployment**  
   - With a staging environment, set your new Hard Mode multipliers, test a few expansions, or simulated events.  
   - Adjust synergy rates or cameo cameo passes on the fly to confirm your data-driven approach works.  
   - Once stable, push the new data to the live server, no code changes required.

This completes **Stage 12** with robust instructions for **Post-Launch Expansions, Hard/Remixed Modes, and Live Ops** in Unity, referencing the blueprint’s synergy (“Elemental Amplifications”), cameo cameo usage (“Guest Hero Summons”), forging updates, realm tier expansions, and everything else.  


Below is the **ultra-comprehensive Stage 13** Unity setup guide for **Leaderboards & Player-vs-Player (PvP) Systems**, matching **Blueprint Section 13 (Subsections 13.1–13.10)** in complete detail. These instructions focus on implementing **leaderboards**, **asynchronous PvP**, **guild vs. guild** competitions, and everything else related to competitive gameplay. There are **no placeholders**, no “e.g.,” no “etc.” references. Everything is explicit and mandatory.

---

# **STAGE 13: LEADERBOARDS & PLAYER-VERSUS-PLAYER (PVP) SYSTEM**  
*(Blueprint Subsections 13.1–13.10)*

## **0) Prerequisites & Context**

1. You have a functional game from Stages 1–12, including:  
   - **Puzzle-Combat** (8×8 board, “Elemental Amplifications” synergy, cameo cameo “Guest Hero Summons”).  
   - **Forging**, **Realm Tier** upgrades, **Guild** features, **Live Ops** scheduling, and **Hard/Remixed** modes for extended endgame.  
   - Data-driven approach (ScriptableObjects/JSON) for new content or balancing.

2. **Stage 13** adds the final layer of **competitive elements**:  
   - **Leaderboards** for puzzle-combat achievements, forging success, realm tiers, etc.  
   - **Asynchronous PvP** (recommended for single-developer feasibility).  
   - **Guild vs. Guild** expansions, cheat prevention, and reward structures.

---

## **1) Leaderboard Data Structures**

**Blueprint 13.1** and **13.2** outline the need for multiple boards. In Unity, we’ll keep these in a **LeaderboardManager**.

1. **File**: `LeaderboardManager.cs` in `[Managers]/Leaderboard`
   - **Fields**:
     - `public List<LeaderboardDefinition> availableLeaderboards;`
     - `public float leaderboardRefreshInterval; // how often to refresh from server, in minutes`
   - **Methods**:
     1. **InitializeLeaderboards()**  
        - Loads each `LeaderboardDefinition` from a local scriptable object or server data.  
        - Schedules updates every `leaderboardRefreshInterval` minutes.
     2. **RequestLeaderboardUpdate(string leaderboardID)**  
        - Sends a server request to retrieve the latest top ranks, user rank, and relevant scores.  
        - On response, caches data locally.
     3. **GetLocalCachedLeaderboard(string leaderboardID)**  
        - Returns the last known ranking list for UI display.

2. **File**: `LeaderboardDefinition.cs` (ScriptableObject)
   - **Fields**:
     - `public string leaderboardID; // "FORGING_XP", "ENDLESS_MODE", "REALM_TIER", "ASYNC_PVP", etc.`
     - `public string displayName;`
     - `public bool hasSeasonReset;`
     - `public string rewardDistributionMethod; // "monthly", "weekly", etc.`
     - `public int topCutoff; // how many top players get special rewards?`
   - This definition helps the single developer add or modify leaderboards without rewriting code.

3. **Server Interaction** (As described in blueprint):
   - The actual ranks and scores are stored on the server. Unity client requests them via `LeaderboardManager` at login or certain intervals.

---

## **2) Leaderboard UI & Scene Setup**

1. **Scene**: `LeaderboardScene` (optional) or a UI panel within your main menu.  
   - A `LeaderboardCanvas` with:
     - A **Dropdown** or **Tab** control listing each available leaderboard (Forging Mastery, Endless Mode, etc.).  
     - A **ScrollRect** area for the leaderboard entries.  
     - A **PlayerRankPanel** showing the user’s current rank, score, and next milestone.  
     - A **Refresh Button** that calls `RequestLeaderboardUpdate(leaderboardID)`.
2. **Prefabs**:
   - **LeaderboardEntryPrefab**: has text fields for rank, player name, score, plus optional element icons if relevant to synergy or forging.  
   - **LeaderboardHeaderPrefab**: for display name of the selected leaderboard, any season countdown, or “Rewards: top 10% get synergy shards,” etc.

3. **Implementation**:
   - On opening the leaderboard UI, the user chooses a board from the dropdown → calls `RequestLeaderboardUpdate()` → populates the UI with the returned data.

---

## **3) Leaderboard Reward Distribution**

**Blueprint 13.3** emphasizes rank-based prizes:

1. **File**: `LeaderboardRewardsManager.cs`
   - **Fields**:
     - `public List<LeaderboardRewardDefinition> rewardDefinitions;`
     - Possibly mapped by `leaderboardID` and `rankRange` (e.g., 1–10, 11–100, top 10%, etc.).
   - **Methods**:
     - **DistributeRewards(leaderboardID)**: runs when a leaderboard season ends.  
       - Fetch final standings from the server.  
       - For each player in the standings, check which reward bracket they fall into.  
       - Award synergy shards, forging tokens, cameo cameo passes, or cosmetic frames accordingly.

2. **File**: `LeaderboardRewardDefinition.cs` (ScriptableObject)
   - **Fields**:
     - `public string leaderboardID;`
     - `public int minRank;`
     - `public int maxRank;`
     - `public int synergyShardReward;`
     - `public int forgingTokenReward;`
     - `public int cameoCameoPasses;`
     - `public string cosmeticTitle;`
     - `public bool awardingTrophyForRoom;`

3. **Visual Indication**:
   - In the user’s mailbox or a “Season End” pop-up, show what they earned. Possibly a special animation for the top bracket.

---

## **4) Asynchronous PvP: Puzzle Duels**

**Blueprint 13.4** describes asynchronous approach:

1. **File**: `AsyncPvpManager.cs`
   - **Fields**:
     - `public bool asyncPvpEnabled;`
     - `public float pvpMatchmakingRange; // e.g., synergy rating range or MMR range.`
   - **Methods**:
     1. **FindOpponent()**:
        - Queries server for a player with a synergy rating or forging rating close to the user’s.  
        - Receives that opponent’s “defense config” (gear synergy, forging synergy, cameo cameo constraints, corrupted gem spawn rates, etc.).
     2. **LoadAsyncPvpBattle(OpponentDefenseData defenseData)**:
        - Spawns a puzzle node with hazards or synergy rules based on the defense config. The user fights an AI “simulation” of that opponent.  
        - On victory or defeat, uploads the result to the server (`recordWinOrLoss()`) to update rank.

2. **Opponent Defense Data**:
   - A scriptable format on the server describing:
     - The defender’s **gear synergy** (Elemental Amplifications, forging bonuses).  
     - Possibly a “preferred hazard” or “corrupted gem rate multiplier” if the user’s synergy allows it.  
     - The defender’s HP or a puzzle “boss” approximation.

3. **UI Flow**:
   - A **PvP** button in the main menu or a dedicated “PvP Arena” scene.  
   - Tapping “Find Opponent” → retrieves `OpponentDefenseData` → user enters puzzle → tries to beat the AI’s parameters within a time limit or HP constraint.

4. **Reward & Ranking**:
   - **AsyncPvpLeaderboard** is one of your `availableLeaderboards`. Each win grants rank points; each loss subtracts.  
   - The user’s rank or MMR is visible in a panel, with synergy forging items or cameo cameo expansions as potential end-of-season rewards.

---

## **5) Optional Real-Time PvP (High Complexity)**

**Blueprint 13.5** suggests it’s advanced and can be a future addition:

- If you decide to implement, create `RealTimePvpManager.cs` with full netcode. This is beyond single-dev scope unless you have strong networking infrastructure.  
- Currently, we skip this for Stage 13 since asynchronous is the recommended approach.

---

## **6) Guild vs. Guild Competitions**

**Blueprint 13.6**:

1. **Resource Collection Race**:
   - Within `GuildManager.cs`, add fields for `guildCollectionEventActive` and a method to track donated seeds/wood/ore from members.  
   - A `GuildEventLeaderboard` can rank guilds by total donations.  
   - Rewards: synergy décor for the guild, cameo cameo expansions for each member, forging tokens, etc.

2. **Boss Time Trials**:
   - If `GuildBossManager.cs` already exists from Stage 7, add a timed aspect: record how fast the guild collectively brings the boss from 100% to 0%.  
   - Another dedicated `LeaderboardDefinition` can store the top times or minimal total attempts.

3. **UI**:
   - A **Guild Competition** tab in the guild menu.  
   - Show the event progress, top guilds, and countdown to the event’s end.

4. **Reward Distribution**:
   - On event completion, top guilds receive synergy shards or forging boosters. Possibly cameo cameo perks for each guild member if it’s thematically appropriate.

---

## **7) Merging Leaderboards with Live Ops**

**Blueprint 13.7**:

1. **Weekly or Seasonal Focus**:
   - In `LiveOpsManager.cs`, define events that highlight a specific leaderboard:
     - For instance, “This week’s Featured Board: Forging Mastery! Earn 20% more forging XP in puzzle-combat or forging attempts.”  
   - Update the UI to show which board is “featured.” Possibly give extra synergy shards for top ranks.

2. **Seasonal Rankings**:
   - A “Winter Festival Leaderboard” measuring how many special event nodes the user cleared.  
   - After the festival, distribute exclusive forging recipes or cameo cameo expansions to top players.

---

## **8) Cheat Prevention & Fair Play**

**Blueprint 13.8**:

1. **Server-Side Validation**:
   - In your puzzle code, forging code, or cameo cameo usage, always send final data (e.g., node time, combos performed) to the server for verification.  
   - If the server sees impossible combos or forging successes in a fraction of normal time, it flags the account.

2. **Anti-Bot Checks**:
   - If a user tries to spam forging or puzzle nodes at unrealistic intervals, require a brief “confirmation puzzle” or insert random gem logic.  
   - Log unusual cameo cameo usage spikes (like 100 cameo summons in an hour).

3. **Leaderboards**:
   - The server ensures only valid data (approved puzzle or forging results) appear.  
   - A “Report Cheater” button can also exist in the guild or friend UI if needed.

---

## **9) Numeric Examples & Tuning**

1. **Asynchronous PvP Rank Gains**:
   - Win: +10 rank points, Loss: -5 rank points. If mismatch in synergy rating is large, adjust gains/losses accordingly.  
   - **File**: `PvpRankDefinition.cs`: define min rank, max rank, point thresholds, synergy buff rewards, cameo cameo pass awarding rank thresholds, etc.

2. **Guild Resource Race**:
   - Collect seeds/wood/ore for 3 days. Top 3 guilds in each bracket get forging synergy décor or cameo cameo expansions.  
   - If you see guilds collecting too quickly, hotfix the thresholds in your data.

3. **Season Resets**:
   - Possibly every 30 days for asynchronous PvP or Endless Mode.  
   - The user’s final rank yields synergy items or cameo cameo passes, then the rank resets.

---

## **10) Section 13 Conclusion & Implementation**

**Blueprint 13.10** emphasizes how **leaderboards** and **PvP** unify the “Elemental Amplifications” forging synergy and puzzle loops:

1. **Implementation Steps**:

   1. **Create/Configure LeaderboardManager**  
      - Add `LeaderboardDefinition.cs` scriptable objects for each board: forging XP, realm tiers, endless mode, async PvP, guild events, etc.  
      - Set refresh intervals, season schedules, reward definitions.

   2. **Asynchronous PvP**  
      - Implement `AsyncPvpManager.cs` with a server call `FindOpponent()`, returning the opponent’s synergy/hazard data.  
      - The puzzle system loads that data to spawn a “defense scenario.”  
      - On completion, record the user’s result → server updates the PvP ranking.

   3. **Guild vs. Guild**  
      - Ensure your `GuildManager.cs` and `GuildBossManager.cs` incorporate resource donation tracking or time-trial logging.  
      - Display a GvG leaderboard in the guild UI.  
      - Distribute synergy or cameo cameo expansions upon event conclusion.

   4. **Cheat Prevention**  
      - Double-check puzzle results server-side.  
      - At suspicious patterns, either block or further verify user data.

   5. **UI Integration**  
      - A “Leaderboard” button in the main menu to access personal ranks, see top players/guilds.  
      - A “PvP Arena” or “Duels” button for asynchronous challenges.  
      - A “Guild Competition” tab in the guild interface.

2. **No New Scenes Required** (Optional):
   - You can place all leaderboard/pvp UI within your existing Town Hub or main menu.  
   - Reuse puzzle-combat scenes for asynchronous PvP by simply applying the “defense config” data from the server.

3. **Monetization & Engagement**:
   - Competitive players might spend on synergy resources or cameo cameo passes to improve ranks.  
   - Seasonal resets keep them re-engaging.  
   - Rewards can be set in `LeaderboardRewardDefinition` for synergy expansions, forging tokens, cameo cameo usage, or even cosmetic frames.

By following these steps, **Stage 13** integrates a fully data-driven, asynchronous **PvP** system, multiple **leaderboards**, **guild competitions**, and fair-play checks. This completes the blueprint’s competitive layer, ensuring long-term user engagement and monetization potential without heavy real-time netcode burdens—perfect for a single-developer puzzle-RPG.

---

# **Stage 13 Unity Setup Checklist (All Scripts)**

1. **`LeaderboardManager.cs`**  
   - Manages update intervals and caching for multiple leaderboards.

2. **`LeaderboardDefinition.cs`**  
   - ScriptableObject specifying each board’s ID, reset type, reward style.

3. **`LeaderboardRewardsManager.cs`**  
   - Handles distribution of synergy shards, forging tokens, cameo cameo passes, or titles at season end.

4. **`LeaderboardRewardDefinition.cs`**  
   - ScriptableObject specifying rank brackets and exact rewards (no placeholders).

5. **`AsyncPvpManager.cs`**  
   - Finds opponents, loads puzzle “defense config,” records results.

6. **`PvpRankDefinition.cs`**  
   - ScriptableObject for rank points, thresholds, synergy or cameo cameo pass rewards at each rank.

7. **`GuildManager.cs`** & **`GuildBossManager.cs`** (updated)  
   - Adds resource race or time-trial logic for GvG competitions, logs data to a GvG leaderboard.

8. **`LiveOpsManager.cs`** (updated)  
   - Potentially highlights a specific leaderboard each week or runs cameo cameo synergy promotions.

9. **UI Prefabs**:  
   - `LeaderboardCanvas`  
   - `LeaderboardEntryPrefab`  
   - `GuildCompetitionPanel`  
   - `PvpArenaPanel`

Everything is now **fully aligned** with the Stage 13 blueprint, referencing “Elemental Amplifications” and “Guest Hero Summons” in synergy. This ensures a seamless, data-driven approach for **leaderboards, asynchronous PvP, GvG contests**, and ongoing competitive events.

STAGE 14: ADVANCED CODE INTEGRATION & MODULES (UNITY INSTRUCTIONS)
Overview & Goal
Goal: Combine all existing systems (Regions, Puzzle-Combat, Forging, Realm Progression, Hero/Gacha, Guild, LiveOps, Quest, Leaderboards, Player Avatars, etc.) into a cohesive, data-driven project.
Focus:
Ensure each manager module is set up in the Unity scene(s) or as persistent Singletons.
Configure Inspector references and prefabs.
Validate performance targets for mobile.
Prepare back-end integration placeholders (server or local data) and security checks.
Guarantee data-driven live updates with minimal code changes.
1) Scene & Project Structure
Recommended Scenes (top-level organization):

Bootloader: Minimal scene that loads first, containing persistent managers (if you prefer a multi-scene approach).
MainMenu: Title or login scene, connecting to the server or local data.
TownHub: Oakrest town scene with sub-UI for forging, guild, etc.
PuzzleScene: The main puzzle board for 8×8 (and also the forging 4×4 puzzle, if loaded additively).
GlobalUI: (Optional) A scene with top-level UI canvases that can persist across scene loads, containing overlays and manager-based UIs.
Folders in Unity’s Project window:

Scripts
Managers (contains all manager scripts: MultiRegionManager, BoardManager, RealmManager, MysticForgeManager, HeroCollectionManager, GachaManager, QuestManager, GuildManager, LiveOpsManager, and any additional integrated managers like LeaderboardManager or PlayerAvatarManager).
Data (for ScriptableObjects or JSON data files).
UI (components, overlays, etc.).
Utilities (for shared tools, singletons, or generic helper scripts).
Prefabs
Manager prefabs if you prefer a prefab-based manager approach.
UI prefabs for puzzle boards, forging interfaces, guild screens, quest dialogues, etc.
Scenes
Listed as above (Bootloader, MainMenu, TownHub, PuzzleScene, GlobalUI).
Art / Audio
Gem sprites, region backgrounds, SFX, BGM, etc.
2) Creating Manager GameObjects & Inspector Setup
Each manager can be either:

Singleton-based: A single manager script that calls DontDestroyOnLoad(gameObject).
Scene-based: Present only in certain scenes (like BoardManager in PuzzleScene).
Below are the recommended setups for each.

2.1 MultiRegionManager
Purpose: Handles region data (10 main regions + Hard/Remixed).
Scene Placement:
Typically placed in the Bootloader scene or a GlobalManager scene that persists.
GameObject Name: MultiRegionManagerGO
Script: MultiRegionManager.cs attached to MultiRegionManagerGO.
Inspector Fields:
Region Data Source: A TextAsset or ScriptableObject reference for Regions.json or RegionData array.
Hard Mode Multipliers: For example, a float for HP multiplier, corrupted gem spawn rate, or synergy difficulty.
Debug Logging: A boolean to toggle verbose logs.
Steps to Configure:

Create an empty GameObject in the Bootloader scene.
Rename it MultiRegionManagerGO.
Attach MultiRegionManager.cs.
In the Inspector, assign the relevant Regions.json or RegionData ScriptableObject to the “Region Data Source” field.
Set default Hard Mode multipliers in the Inspector (e.g., HPMultiplier = 1.5f, CorruptedSpawnMultiplier = 1.25f).
2.2 BoardManager (Puzzle Logic)
Purpose: Powers the 8×8 puzzle logic (and the 4×4 forging puzzle if you unify them or create a separate manager).
Scene Placement:
Usually placed in the PuzzleScene so it’s re-initialized each time you open a puzzle node.
If forging puzzle is separate, you can reuse this manager or create a ForgeBoardManager.cs.
GameObject Name: BoardManagerGO in the PuzzleScene.
Script: BoardManager.cs.
Inspector Fields:
Gem Prefabs: An array of prefabs for Ember, Cascade, Terra, Zephyr, Radiant, Corrupted, each set as a GameObject or Sprite.
Board Size: Typically locked to 8 for puzzle-combat, 4 for forging. If combined, have two sets of parameters or use separate managers.
Match Detection: References or threshold for how many gems form a valid match.
Phantasm Surge Threshold: The integer combo count (like 50) that triggers surge.
Elemental Amplifications config references (like synergy data) if you want BoardManager to read synergy multipliers directly.
Steps to Configure:

Create an empty GameObject named BoardManagerGO in PuzzleScene.
Attach BoardManager.cs.
In the Inspector, define:
GemPrefabs array with each elemental gem (Ember, Cascade, Terra, Zephyr, Radiant, Corrupted). No placeholders—use your actual gem assets.
BoardSize = 8.
PhantasmSurgeThreshold = 50 (or your chosen default).
ElementalAmplificationsData: If you store synergy multipliers in a ScriptableObject, assign it here.
2.3 RealmManager (Realm Tier Progression)
Purpose: Manages the four Districts (Timberland, Miner’s Gulch, Seed Grove, Arcane Bloom), upgrading tiers, unlocking synergy perks.
Scene Placement:
Typically in a persistent manager scene or the TownHub scene if that’s the main vantage for realm progression.
GameObject Name: RealmManagerGO.
Script: RealmManager.cs.
Inspector Fields:
District Data: A reference to RealmData or JSON containing costs, synergy unlocks, resource requirements.
UI References: For District upgrade panels, progress bars, or confirmation dialogs.
Audio: If a short SFX is played on upgrade.
Steps to Configure:

Create an empty GameObject called RealmManagerGO in the TownHub scene.
Attach RealmManager.cs.
Assign your RealmData asset or TextAsset in “District Data.”
Link the UI references (progress bar, button for each District) in the Inspector.
Set any realm synergy multipliers or forging synergy callbacks if required.
2.4 MysticForgeManager (Forging)
Purpose: Runs the forging puzzle logic (4×4 board), handles gear data, success calculations, forging XP gains.
Scene Placement:
Typically in the TownHub scene or an additively loaded ForgingScene.
GameObject Name: MysticForgeManagerGO.
Script: MysticForgeManager.cs.
Inspector Fields:
Gear Data Source: A JSON or ScriptableObject reference containing forging recipes for Ember/Cascade/Terra/Zephyr/Arcane.
Forge Puzzle Reference: If you’re using a separate smaller puzzle board prefab, link it.
Success Rate Base Values: Rarity base success for Rare, Epic, Legendary.
Time to Solve: The default forging puzzle timer (e.g. 15 seconds).
UI Panels: Forge result pop-up, cost display panel, forging progress bar if you have forging cooldowns.
Steps to Configure:

Create an empty MysticForgeManagerGO in the TownHub scene.
Attach MysticForgeManager.cs.
Assign the GearData or forging recipes file in the Inspector.
Reference the forging puzzle board prefab if distinct from the standard 8×8 puzzle.
Set default success rates (Rare ~70%, Epic ~60%, Legendary ~50% or your chosen values).
Link forging UI elements (cost panel, results window, success bar).
2.5 HeroCollectionManager & GachaManager
Purpose:
HeroCollectionManager: Tracks the user’s hero roster, levels, synergy associations.
GachaManager: Manages summoning banners, pity counters, premium gem spending.
Scene Placement:
Often placed in a persistent manager object or MainMenu scene that persists.
GameObject Names: HeroCollectionManagerGO, GachaManagerGO.
Scripts: HeroCollectionManager.cs, GachaManager.cs.
Inspector Fields:
Heroes Data: Heroes.json or ScriptableObject with base stats, synergy multipliers, star ratings.
Banners Data: Banners.json containing rates, pity thresholds.
Summon UI: The UI panel that appears when pulling.
Currency Manager: Reference for premium gems or tickets.
Steps to Configure:

Create two empty GameObjects: HeroCollectionManagerGO and GachaManagerGO in the Bootloader or MainMenu scene (or whichever you prefer to keep persistent).
Attach HeroCollectionManager.cs and GachaManager.cs to their respective GameObjects.
Link the heroes data file in HeroCollectionManager.cs.
Link banners data file in GachaManager.cs.
Link the Summon UI prefab or panel to GachaManager.cs.
Ensure cameo cameo references (Guest Hero Summons) are integrated if a borrowed hero from a friend is used or displayed.
2.6 QuestManager (Daily, Weekly, Story Arcs)
Purpose: Oversees quest logic, from daily tasks to deep storyline arcs.
Scene Placement:
Commonly persistent to track progress at all times, or in the TownHub scene.
GameObject Name: QuestManagerGO.
Script: QuestManager.cs.
Inspector Fields:
Quest Data: QuestData JSON or ScriptableObject referencing daily, weekly, and storyline quests.
Quest UI: Panels to display active quests, progress, and completion.
Popup Prefab: If you have a short pop-up for quest completion rewards.
Steps to Configure:

Create a GameObject named QuestManagerGO.
Attach QuestManager.cs.
Assign the quest data asset in the Inspector.
Connect quest UI prefabs or references (like a main quest list panel, daily quest panel).
Optionally assign cameo cameo references if certain quests require borrowing a friend’s hero or accomplishing synergy tasks that reference cameo usage.
2.7 GuildManager (Co-Op & Resource Gifting)
Purpose: Handles guild membership, resource donations, guild-level upgrades, guild boss states.
Scene Placement:
Usually persistent so the user can open guild info from anywhere.
GameObject Name: GuildManagerGO.
Script: GuildManager.cs.
Inspector Fields:
Guild Data: Possibly stored server-side, but you can keep a local reference for offline usage.
Guild UI: The guild panel, donation panel, boss fight result screens.
Guild Boss Config: If local data is used, link the JSON or ScriptableObject for guild boss definitions (HP, phases, rewards).
Steps to Configure:

Create GuildManagerGO.
Attach GuildManager.cs.
Link any local references (boss HP data, donation config) in the Inspector.
Connect the guild UI to show membership, chat (if using a local solution or bridging to a server), and cameo cameo usage for borrowing guildmates’ heroes.
2.8 LiveOpsManager
Purpose: Toggles daily/weekly events (forging weekends, synergy days, cameo cameo pass promotions).
Scene Placement:
Typically persistent.
GameObject Name: LiveOpsManagerGO.
Script: LiveOpsManager.cs.
Inspector Fields:
Events Data: A schedule or config referencing start/end times, event modifiers (like +15% forging success).
UI Indicator: Optional icon or pop-up for active events.
Steps to Configure:

Create LiveOpsManagerGO.
Attach LiveOpsManager.cs.
Link an events data file or schedule in the Inspector.
If using a server-based approach, you can keep a local fallback file for offline.
Bind any UI elements that display “Active Event: Ember Overload!”
3) Data Structures & Scriptable Objects Setup
Below is how to set up the ScriptableObjects or TextAssets for data-driven logic:

Regions.json / RegionData

Must have an array of 10 Region entries, each with 5 Sublocations.
For Hard Mode variants, store a flag or a multiplier property.
Example fields: regionID, sublocations[], minionPools[], bossID, unlockRequirements.
Gear.json / ForgeItemData

Contains forging recipes for each element and rarity.
Example fields: element (Ember, Cascade, Terra, Zephyr, Arcane), rarity (Rare, Epic, Legendary), baseCostGold, baseCostResources, baseSuccessRate.
Heroes.json / HeroData

Each hero has heroID, element, starRating, baseStats, synergy multipliers for “Elemental Amplifications.”
Possibly references cameo cameo perk if it’s a hero that can assist forging or puzzle-combat differently.
QuestData

A large array with daily, weekly, and storyline quests.
Fields like questID, objectives[], rewards[], isBranching, requiredRegion, etc.
Banners.json (for Gacha)

Defines current or upcoming banners, each with bannerID, featuredHeroIDs, rates, pityThreshold.
RealmData

For District tiers (Timberland, Miner’s Gulch, Seed Grove, Arcane Bloom).
Each tier cost, synergy perks, forging time reductions, cameo cameo expansions if relevant.
Event Data / LiveOpsData

Weekly schedules for forging weekends, synergy day buffs, cameo cameo pass promotions.
Each entry: eventID, startTime, endTime, modifiers.
Unity Setup

In the Project window, create a folder Assets/Scripts/Data.
For each data category, choose one of two approaches:
ScriptableObject: Right-click → Create → [YourGame]/[DataType] and fill out fields in Inspector.
TextAsset JSON: Store the JSON file in the same folder, parse at runtime with JsonUtility or a third-party solution.
In the relevant managers (e.g., MultiRegionManager, MysticForgeManager), link the assets or text files in the Inspector.
4) UI & Scene Management
4.1 Scene Flow (Detailed)
Bootloader:

Loads essential persistent manager objects (if not using a single “GlobalManagerScene”).
Moves to MainMenu when ready.
MainMenu:

Shows start screen, account login, or a local profile load.
Once the user hits “Continue,” loads TownHub.
TownHub:

The user sees Oakrest layout:
Buttons or hotspots to open forging workshop, guild, realm district gates, hero menu, etc.
Tapping a “World Map” or “Overworld” button calls MultiRegionManager to show region selection or sublocation maps.
On selecting a puzzle node, loads the PuzzleScene additively or via a scene transition swirl.
PuzzleScene:

Contains the 8×8 puzzle board (and if forging puzzle is needed, the 4×4 might be in a nested UI).
Once the puzzle is complete (victory or defeat), returns to the TownHub sublocation map with the result.
GlobalUI (Optional):

Overlays persistent UI: currency display, notifications, cameo cameo usage icon if the user decides to borrow a friend’s hero at any time.
4.2 UI Panel References
BoardManager references a puzzle canvas or panel that holds the 8×8 grid.
MysticForgeManager references a forging puzzle panel (4×4) plus forging results pop-up.
RealmManager references an overlay to show District progress bars, upgrade buttons.
QuestManager references a quest panel or daily tasks window.
GuildManager references a guild UI panel for donations, chat, boss.
LiveOpsManager references an event banner panel or top banner icon.
Inspector Setup:

For each manager script, in the Inspector, define fields like:
public GameObject puzzlePanel;
public GameObject forgingPanel;
public Text realmTierText;
public Button upgradeButton;
public GameObject dailyQuestPanel;
No placeholders—assign the actual UI objects in your Unity scene or prefabs.
5) Performance & Optimization Targets
5.1 Mobile Devices
Aim for 30–60 FPS on mid-range devices (e.g., a smartphone with a few years of hardware).
Keep memory usage below 500 MB on Android and iOS if possible.
Practical Steps:

Pooling: Pool gem objects instead of instantiating/destroying them constantly.
Sprite Atlases: Combine gem sprites in a single atlas to reduce draw calls.
UI Overdraw: Ensure the puzzle board is not behind multiple transparent layers. Use minimal overlapping UIs.
5.2 Asset Bundles & Loading
Segment your content so the user doesn’t download everything at once. For instance, each region’s backgrounds can be in a separate AssetBundle.
Addressable Assets (optional) to handle large textures or expansions post-launch.
5.3 Network Usage
Asynchronous design: only send node result data or forging success logs to the server. Avoid real-time netcode for puzzle logic to keep overhead low.
6) Back-End & LiveOps Tools
6.1 Admin Panel
A web-based or editor-based tool for toggling:
Forging Weekend events,
Synergy Day buffs,
Cameo cameo pass promotions (Guest Hero Summons),
Realm expansions (like adding Tier 5 or new Realms).
Unity Setup:

Typically this is outside the Unity client, but you might create an AdminPanel scene for debug usage.
If purely server-based, keep a minimal debug console in Unity for local offline testing.
6.2 Analytics
Must track:
Daily Active Users,
Puzzle attempts,
Forging attempts,
Realm tier distribution,
Cameo cameo usage frequency.
Unity Setup:

If using a 3rd-party analytics solution, add it as a plugin.
For each manager (BoardManager, MysticForgeManager, etc.), call AnalyticsLogger.LogEvent("PuzzleClear", dataDictionary); or something similar when events happen.
Ensure you store user progress in a server-side profile if possible.
6.3 LiveOps Scheduling
A cron-like system or timed triggers that automatically:
Activate forging weekends on Fridays,
Start synergy day buffs on specific weekdays,
Launch cameo cameo promotions monthly.
Unity Setup:

In LiveOpsManager.cs, keep a list or dictionary of scheduled events with start/end times.
On Update() or a timed coroutine, check if the current system time surpasses startTime or endTime, then call ActivateEvent(eventID) or DeactivateEvent(eventID).
7) Testing & QA
7.1 Unit Tests
In Editor Tests or using a test framework, create:
PuzzleLogicTests: Checking gem matching logic, synergy combo increments, corrupted gem phase transitions.
ForgingTests: Testing base success rates, forging puzzle bonus logic, resource cost calculations.
RealmTierTests: Upgrading from Tier0 to Tier1, verifying resource consumption.
QuestTests: Ensuring quest objectives complete properly.
7.2 Integration Tests
Set up an automated scenario:
Log in or load a test profile.
Perform a daily minigame for resources.
Use those resources to forge an Ember Rare item.
Attempt a puzzle node with that new item, trigger cameo cameo usage if relevant.
Return to TownHub.
Check quest progress, claim reward.
7.3 Beta Branch
For major expansions (like a new region #11 or Tier5 expansions), create a Beta environment or separate build:
Ensure testers can jump to high-tier forging or puzzle logic quickly.
Validate data hotfixing or synergy changes are recognized.
8) Security & Anti-Cheat Layers
8.1 Basic Checks
If a user claims forging puzzle provided +30% success in 10 seconds multiple times in a row, mark suspicious.
If cameo cameo usage logs show an impossible usage count (like hundreds of borrowed heroes in a few minutes), investigate.
8.2 Encryption
For local save data, enable minimal encryption.
For puzzle seeds, store partial seeds server-side. The server can compare final combos vs. plausible outcomes to reduce tampering.
8.3 Ban / Warning System
If repeated suspicious logs, the server can mark the user’s profile as under review.
Provide an in-game UI message about potential account suspension if flagged.
9) Future-Proofing
9.1 Scalable Regions
The system reads an array or list of region definitions from Regions.json. Adding region #11 or #12 just means adding more entries, each with sublocations. No code rewriting needed if coded properly.
9.2 Hero Gacha Updates
Store banners in Banners.json. The developer can rotate or add new banners without changing code, just by loading new data.
For synergy expansions, simply add synergy multipliers to the new heroes.
9.3 Live Co-Op Potential
If eventually building real-time co-op:
Keep puzzle logic local.
Only sync wave states, cameo cameo triggers, or combined boss HP via a server channel.
This is significantly more complex but can build on the existing asynchronous structure.
10) Final Verification (Section 14 Conclusion)
Modular Architecture: You now have MultiRegionManager, BoardManager, RealmManager, MysticForgeManager, HeroCollectionManager, GachaManager, QuestManager, GuildManager, LiveOpsManager (and any others) each handling a distinct system, with data references in the Inspector.
Data-Driven: JSON or ScriptableObjects for Regions, Gear, Heroes, Quests, RealmData, Banners, and LiveOps ensure a single developer can tweak or add content quickly.
UI & Scene Management: Scenes are structured for minimal load times, with persistent managers or additive loading.
Performance Targets: You are set up for mobile optimization (object pooling, sprite atlases, minimal net usage).
Security: Basic anti-cheat checks, encryption, and server verification are in place.
Future-Proofing: Additional expansions, new heroes, realms, or Hard Mode variants require minimal coding changes, focusing on new data entries.
Stage 14 is now fully integrated in Unity, bridging all prior systems into a single data-driven, single-developer-maintainable puzzle-RPG framework. You can proceed to final polish, balancing, or additional expansions with minimal friction.

End of Stage 14 Unity Instructions. You now have a comprehensive, AAA-level design and implementation roadmap for advanced code integration and modules, ensuring your puzzle-RPG remains scalable, secure, and easy to maintain post-launch.


STAGE 15: INCREMENTAL TUTORIAL & ONBOARDING (UNITY INSTRUCTIONS)
Overview & Goal
Goal: Create a comprehensive tutorial sequence that appears only when needed, guiding players through puzzle-combat basics, forging, realm tiers, cameo cameo usage (“Guest Hero Summons”), guild interactions, and more—without overwhelming them at the start.
Scope:
A TutorialFlowManager in Unity that checks triggers and displays pop-up dialogues or highlight overlays.
Data-driven steps so you can add, remove, or adjust tutorial steps easily via JSON or ScriptableObjects.
Incremental rollout: puzzle basics first, then forging, realm progression, synergy expansions, cameo cameo usage, guild, etc.
1) Scene & Project Structure
Recommended Scenes (reminder):

TownHub (Oakrest),
PuzzleScene (8×8 board),
Workshop or integrated forging area,
Possibly a Bootloader or GlobalManager scene for persistent singletons.
Key New Addition:

TutorialFlowManager can be placed either:
In the TownHub scene (if that’s your main persistent hub),
Or in the Bootloader scene if you want it to persist across scene loads.
Folders in Unity’s Project window (supplementing existing ones):

Scripts/Tutorial: for tutorial-related scripts, data, or custom editors.
UI/Tutorial: for pop-up prefabs, highlight overlays, and tutorial hand-holding elements (e.g., pointing arrows).
2) TutorialFlowManager Setup
2.1 Creating the Manager
Scene Placement:
If you have a GlobalManagerScene or a Bootloader with singletons, put it there so it persists. Otherwise, place it in the TownHub scene as a persistent object (calling DontDestroyOnLoad).
GameObject Name: TutorialFlowManagerGO.
Script: TutorialFlowManager.cs.
2.2 Inspector Fields
In TutorialFlowManager.cs, you will typically have:

Tutorial Data: A ScriptableObject or JSON array containing a list of tutorial steps. For instance, TutorialStepsData.
Each step might include:
TriggerCondition (like OnFirstPuzzleNodeEntered, OnForgeUnlocked, OnGuildUnlocked, OnHardModeUnlocked).
UIHighlightTarget (the Unity object or UI button to highlight).
PopUpText (the dialogue to display).
RewardID if you tie tutorial completions to small quest-like rewards (optional).
Pop-Up Prefab: A reference to a TutorialPopUp prefab that can display text, images, an OK button, or “Got it!”.
Highlight Overlay: A reference to a highlight or arrow prefab used to guide the user’s attention to a certain UI element (like the Forge Button or Guild Button).
Quest Integration: (If you want tutorial steps to tie into QuestManager) A link to QuestManager.cs or a direct method call to log completions.
Example of TutorialFlowManager Inspector fields:

public TextAsset tutorialStepsJson; (or public TutorialStepsData tutorialStepsAsset;)
public GameObject tutorialPopUpPrefab;
public GameObject highlightOverlayPrefab;
public QuestManager questManagerReference;
public bool enableDebugLogs;
2.3 ScriptableObject or JSON Structure
If using JSON (tutorialSteps.json), each tutorial step could look like:

json
Copy
{
  "stepID": "TUTORIAL_01",
  "triggerCondition": "OnFirstPuzzleNodeEntered",
  "popupText": "Welcome to the puzzle board! Match 3 gems of the same color to attack.",
  "highlightTarget": "PuzzleGemBoard",
  "optionalRewardID": "TutorialToken1"
}
If using a ScriptableObject (TutorialStepsData), you’d have an array or list of TutorialStep objects with equivalent fields. In the Inspector of TutorialStepsData, you can fill them out manually.

3) Tutorial Trigger Implementation
Core Logic: TutorialFlowManager must listen for game events. For instance:
BoardManager can dispatch an event “PuzzleNodeEntered”.
MysticForgeManager can dispatch “FirstForgeAttemptStarted”.
RealmManager can dispatch “DistrictTierUpgradeAvailable”.
GuildManager can dispatch “GuildUnlocked” or “GuildBossAccessed”.
Event System or Observer Pattern:
UnityEvent or C# events can be used. Each manager script triggers an event. The TutorialFlowManager checks its tutorial steps to see if one matches the trigger condition and is not yet completed.
3.1 Example Code Snippet (Pseudocode)
csharp
Copy
// In BoardManager.cs (puzzle scene)
public event Action OnPuzzleNodeEntered;

private void StartPuzzleNode()
{
    // This is called when a puzzle node is actually loaded
    OnPuzzleNodeEntered?.Invoke();
}

// In TutorialFlowManager.cs
private void OnEnable()
{
    // Suppose we have references to all managers or a global event aggregator
    BoardManager.OnPuzzleNodeEntered += HandlePuzzleNodeEntered;
}

private void HandlePuzzleNodeEntered()
{
    // Check if there's a tutorial step with triggerCondition == "OnFirstPuzzleNodeEntered" and not yet completed
    TriggerTutorialStep("OnFirstPuzzleNodeEntered");
}
3.2 TriggerTutorialStep Method
Inside TutorialFlowManager.cs:

csharp
Copy
public void TriggerTutorialStep(string condition)
{
    // Look up the next step from data that matches 'condition'
    var step = GetNextStepForCondition(condition);
    if (step != null && !IsStepCompleted(step.stepID))
    {
        ShowTutorialPopUp(step);
        MarkStepCompleted(step.stepID);
    }
}
GetNextStepForCondition: finds the matching step or steps from the loaded data.
IsStepCompleted: checks if the user has already done it (stored in local PlayerPrefs or server data).
ShowTutorialPopUp: instantiates the pop-up prefab, displays step’s popupText, optionally highlights the target UI element.
MarkStepCompleted: sets a flag in local memory or a server profile.
4) Pop-Up & Highlight Overlays
4.1 Tutorial Pop-Up Prefab Setup
Prefab Name: TutorialPopUpPrefab.
Canvas: Usually a child of a top-level canvas in your scene.
Contents:
A Text or TMP_Text field for the tutorial message.
A Button (“OK” or “Got it!”).
Optional image or step indicator (e.g., “Step 2/10”).
Inspector:
public Text or TMP_Text tutorialMessage;
public Button okButton;
Behavior:
When spawned by TutorialFlowManager, sets tutorialMessage.text = step.popupText;
On okButton.onClick, destroy the pop-up or disable it.
4.2 Highlight Overlay Prefab
Prefab Name: HighlightOverlayPrefab.
Structure:
A transparent dark background with a cutout or arrow that focuses on a specific UI element, or
A simple arrow or glow effect positioned over the target.
Inspector:
public RectTransform highlightTarget; to let the script position itself around the target.
Positioning:
The script can convert the target’s screen position to UI coordinates. Example code:
csharp
Copy
public void HighlightUIElement(RectTransform targetRect)
{
    // Convert targetRect position to overlay's coordinate space
    Vector2 screenPos = RectTransformUtility.WorldToScreenPoint(Camera.main, targetRect.position);
    // Then place the highlight overlay around that screenPos with offset
    // Example for an arrow or glowing circle
}
5) Example Tutorial Steps & Trigger Points
Based on the blueprint’s recommended flow:

Step A: “OnFirstPuzzleNodeEntered”

Pop-Up: “Match 3 or more gems of the same color to attack. Radiant gems are wildcards. Watch for corrupted gems!”
Highlight: The puzzle board’s center or a particular gem.
Reward: None or a small gold bonus to encourage finishing the step.
Step B: “OnTownHubFirstVisit”

Pop-Up: “This is Oakrest Town Hub. Visit the District Gates for resources, the Workshop for forging.”
Highlight: The District Gate button or Workshop button.
Step C: “OnForgeUnlocked”

Pop-Up: “Let’s craft your first Ember sword. Tap the Forge icon to begin.”
Highlight: The forging station or workshop node.
Step D: “OnRealmTierUpgradePossible”

Pop-Up: “Upgrade your District to Tier 1 for better synergy bonuses. Gather enough wood or seeds to proceed.”
Highlight: The realm upgrade button.
Step E: “OnGuildUnlocked”

Pop-Up: “Join a Guild to share resources, fight guild bosses, or borrow a friend’s hero cameo cameo. Check out the Tavern!”
Highlight: The tavern node or guild button.
Step F: “OnFirstPhantasmSurge”

Pop-Up: “You triggered Phantasm Surge! This clears some corrupted gems and boosts damage. Aim for 50+ combos in one move.”
Highlight: Possibly the Surge meter or a swirl effect on the board.
Step G: “OnHardModeUnlocked”

Pop-Up: “Hard Mode is available for bigger rewards and stronger enemies. Upgrade your forging gear or use cameo cameo if needed.”
Highlight: The Hard Mode toggle in the region selection UI.
6) Quest Integration (Optional)
If you want to tie these tutorials into the QuestManager:

Create tutorial quests in your QuestData (like Q_TUTORIAL_01, Q_TUTORIAL_02, etc.).
Each quest has objectives that match the tutorial step triggers.
When the user completes a step, call questManagerReference.RecordProgress("TutorialQuest", "Q_TUTORIAL_01", 1); or something similar to mark it done.
The quest might reward synergy shards, forging tokens, or cameo cameo passes as an incentive.
7) Daily Planner Highlight
Many players skip reading pop-ups. The blueprint suggests Daily Planner or Quest UI might centralize all tasks:
Implementation:
In your TownHub UI, have a “Daily Planner” button.
The first time it appears, a short tutorial pop-up can highlight that button: “Check here daily for tasks, forging opportunities, cameo cameo usage, and realm progression goals.”
Each new tutorial step can also appear in the daily planner with a short label (“Try forging your first item!”).
Inspector:

In TutorialFlowManager.cs, you could reference DailyPlannerUI or an existing QuestPanel. When a tutorial triggers, also add an entry that says “Complete the forging tutorial step.”
8) Onboarding Flow & Best Practices
Spacing Out Tutorials
Ensure you do not chain too many back-to-back. Example: After finishing forging tutorial, let the user do at least 1–2 puzzle nodes before popping the next realm upgrade tutorial.
Keep Pop-ups Short
Show a single sentence or two at most.
“OK” to close. If it’s more complex, break it into 2–3 steps with a next/previous arrow.
Disable Other UI (soft gating)
For critical steps: gray out the rest of the screen so the user focuses on the forging button or synergy upgrade button.
Release the gating immediately after the user taps the highlight or closes the pop-up.
9) Testing & Analytics for Tutorials
Testing
In a Test Account or internal QA environment, mark all tutorials as “unseen.” Then play from the start, verifying that each tutorial triggers properly in order.
Analytics
Log how many players see each tutorial step.
If a large portion skip forging tutorial or never see it, you can show a gentle reminder or auto-trigger it again.
Adjustment
If feedback says the puzzle tutorial is still too big, break it into two steps:
Step 1: “Basic matches.”
Step 2: “Corrupted gems and Radiant gems.”
If cameo cameo usage is often ignored, add a short tutorial step once the user’s level is high enough or they attempt a tough node for the first time.
10) Final Verification (Section 15 Conclusion)
Incremental Introduction: Each feature tutorial triggers exactly when relevant—puzzle basics on the first node, forging tutorial on first workshop entry, cameo cameo usage when the user or guild system is unlocked, etc.
Minimal Overload: By dividing tutorials into small steps and storing them in a data-driven format (tutorialSteps.json or a TutorialStepsData SO), a single developer can manage or expand them easily.
Hands-On Guidance: Whenever possible, show the user an actual forced mini-step (like forging a free item or performing a puzzle match) to cement the lesson.
Integration: All tutorials can tie into QuestManager if you want to reward synergy shards or forging tokens upon completion, further motivating players to follow the instructions.
Analytics: Track completion rates and user progress. If many players drop out before finishing forging tutorial, refine or shorten your instructions.
With this Stage 15 tutorial system in place, new users will steadily learn puzzle-combat, forging synergy, realm upgrades, cameo cameo usage (“Guest Hero Summons”), guild features, and more—without feeling overwhelmed. This fosters higher retention, smoother progression, and a more professional, AAA-level onboarding experience.

End of Stage 15 Unity Instructions. You have now created a robust, incremental tutorial flow that seamlessly introduces each major system to the player at the appropriate time, ensuring they grasp forging, synergy (“Elemental Amplifications”), cameo cameo usage, guild features, and beyond.

STAGE 16: PERFORMANCE & NETCODE OPTIMIZATION (UNITY INSTRUCTIONS)
Overview & Goal
Goal: Achieve stable 30–60 FPS on mid-range mobile devices, keep memory usage under ~500 MB, and maintain a low server overhead via asynchronous netcode.
Scope:
Optimizing puzzle-combat performance (8×8 or 4×4 forging board).
Managing memory, VFX, and audio layers efficiently.
Implementing minimal real-time netcode, with most interactions handled client-side and validated server-side.
Handling offline and asynchronous features (guild boss fights, cameo cameo usage logs, forging attempts, etc.).
1) Project Setup & Build Targets
Unity Version:

Use a stable LTS release (e.g., Unity 2021 LTS or later).
Verify all optimization features (e.g., Addressables, Profiler, GPU instancing) are available and active as needed.
Build Settings:

Platform: Android/iOS.
Scripting Backend: IL2CPP for iOS, IL2CPP or Mono for Android (IL2CPP preferred for performance).
API Compatibility: .NET Standard 2.1 or highest stable that your Unity version supports.
Quality Settings:

Create at least two quality tiers: Low and High.
On lower devices, reduce or disable certain post-processing or swirl overlays.
On high-end devices, allow up to 60 FPS or more if stable.
2) Puzzle-Combat Optimization
2.1 Board Updates & Match Detection
Board Representation:

Use a Gem[,] gemArray (2D array) or List<List<Gem>> for an 8×8 puzzle board.
For forging puzzle (4×4), similarly use a smaller structure.
Discrete Checking:

CheckMatches only when all gem movements have finished or after a user swap.
If you run a continuous match check every frame, you risk CPU spikes. Instead, queue a check after each tween or animation completes.
Pooling Matches:

If multiple combos occur simultaneously, handle them in a single pass.
Summarize combos for synergy calculations (like forging synergy, cameo cameo triggers, etc.) and PhantasmSurge checks in one batch.
2.2 Corrupted Gem Evolution
Interval Updates:

Maintain an internal timer that updates corrupted gem phase changes every 0.5s or 1s, not per frame.
Example: CorruptedGemManager.UpdateCorruptedGems(float deltaTime) with a small state machine for phases 1→2→3.
Cap for Hard Mode:

If you see performance dropping due to too many corrupted gems, either cap their total or slow their spawn rate for older devices. Make this adjustable via server data or a local config.
Object Pooling:

When corrupted gems spawn or vanish, re-use gem objects from a GemPool rather than creating/destroying repeatedly.
2.3 Particle & Visual Effects
Short & Reusable:

For a big combo, prefer a single ComboExplosion effect over many small overlapping effects.
Cache swirl textures for events like cameo cameo introductions or forging synergy animations, so you don’t reload them each time.
Quality Scaling:

On Low Graphics: reduce particle count or skip certain flourish effects.
On High Graphics: allow full particle animations for a more impressive spectacle.
3) Arcane Flow Transitions
Lightweight Shader:

If you do swirling transitions between puzzle waves or forging puzzle states, implement a fullscreen shader that warps the screen for a brief second.
Limit the number of passes for older devices; offer a simpler fade if performance is an issue.
Asset Bundling:

Keep swirl textures in an Addressable Asset group or a dedicated Resource folder. Load them once at startup or upon entering the puzzle scene, then re-use them.
Toggle:

In Settings, let the user pick “Enhanced Transitions” or “Simple Fades”. Store this preference in PlayerPrefs or the server profile.
4) Adaptive Audio Layers
4.1 Audio Mixer Setup
Audio Mixer Groups:

Create 3 main groups: BGM, SFX, Voices (or cameo cameo stings).
For the cameo cameo usage (“Guest Hero Summons”), you might have a short voice line or jingle.
Crossfading:

When a PhantasmSurge triggers, or cameo cameo is activated, fade to an intense track or sting for a short duration. Then fade back to the standard puzzle BGM.
4.2 Performance Considerations
Compression:

Convert large BGM files to Vorbis at ~128 kbps.
Keep SFX as short WAV or Ogg.
Audio Channels:

Limit maximum voices to ~8 or ~12, depending on device memory. Overlapping SFX from combos should combine or be curtailed.
Profile & Adjust:

If big combos + cameo cameo triggers cause audio stutter, reduce the concurrency in the AudioManager.
5) Asynchronous Netcode
5.1 Basic Client-Server Flow
Local Execution:

Puzzle logic (matching gems, synergy combos, cameo cameo triggers) happens entirely client-side for responsiveness.
After puzzle completion, the result is sent to the server: nodeID, comboCount, timeTaken, cameoUsed (if any), etc.
Validation:

The server checks if the user’s synergy levels, forging gear, or cameo cameo usage frequency is plausible. If it’s suspicious (e.g., 100% forging success or infinite cameo cameo usage), logs flag it for review.
Batch or Immediate:

You can send data after each node or forging attempt.
Alternatively, store them locally and upload in a batch on the next stable Wi-Fi connection. This is a design choice balancing reliability vs. real-time progression tracking.
5.2 Guild Boss & Asynchronous PvP
Guild Boss:

Each user’s damage contribution is recorded asynchronously. The boss’s HP is stored on the server.
When the user reconnects, they see updated boss HP. If cameo cameo is used, that cameo cameo usage is logged to deduct daily cameo cameo attempts (if you have a limit).
Asynchronous PvP:

The “defender” sets a synergy-based hazard pattern. The “attacker” does the puzzle. After finishing, results are sent to the server, which updates ELO or rank.
Leaderboard:

The server updates or refreshes ranks every few minutes. No heavy real-time sync needed.
6) Server Architecture & Scaling
6.1 Backend Setup
Choice:

A small RESTful approach with an HTTP/HTTPS server or WebSocket for more event-based updates.
If you have minimal data volume, simple REST endpoints suffice:
POST /puzzleComplete
POST /forgingAttempt
GET /guildBossState
Database:

A NoSQL store (e.g., MongoDB) or a relational DB (MySQL/PostgreSQL) for storing user profiles, synergy expansions, cameo cameo tokens, forging logs, etc.
Hotfix & LiveOps:

Keep a table or JSON config that can dynamically toggle forging success rates, synergy spawn rates, cameo cameo event frequencies, etc., so one developer can adapt the game quickly.
6.2 Disaster Recovery
Backups:

Automate daily or weekly backups of user data.
Store backups on a separate instance or cloud bucket.
Rollback:

If a major bug corrupts synergy gear or cameo cameo usage logs, revert to the last safe backup for the affected players.
Monitoring:

Use a service (e.g., AWS CloudWatch) to track CPU usage, DB queries, or error logs.
If unusual cameo cameo usage or forging success spikes happen, the developer receives an alert.
7) Edge Cases & Offline Play
7.1 Offline Resource Accumulation
Realm Districts:

If the user is offline for 10 hours, they accumulate up to the 12-hour cap (or whichever limit you set).
On reconnection, the server calculates “lastLoginTime” vs. “currentTime” and awards the resources.
Cameo Cameo Offline:

Borrowing a friend’s cameo cameo hero requires a server check, so it’s typically disabled offline.
The user can still do forging puzzles offline, and the results queue until reconnection.
7.2 Combat Without Connection
Queueing:

Store puzzle node completions in a local file or player prefs with a simple list: {nodeID, combos, timestamp}.
On reconnection, push them to the server via a batch method.
Possible Cheating:

If a user tries to exploit this with time manipulation, the server uses server time. Large discrepancies lead to partial acceptance or forced re-sync.
8) Client-Side Caching & Memory Management
8.1 Asset Bundles & Addressables
By Region:

For each region (e.g., Ember Highlands, Cascade Shores), group the backgrounds, minion textures, cameo cameo animations, forging puzzle skins, etc.
Load them upon region entry, unload them when leaving.
Caching:

Keep core assets (gem sprites, synergy icons, cameo cameo placeholders) in memory, as they are used frequently.
Store less frequent UI assets in addressable bundles you can unload to reclaim memory.
8.2 Garbage Collection Minimization
Object Pooling:

For the puzzle board, pre-instantiate a GemPool of e.g. 100 gem objects. Recycle them instead of calling Instantiate/Destroy repeatedly.
Avoid Large Temporary Structures:

For synergy calculations, use a small buffer or reuse arrays.
High-level combos might produce big lists of matched gems: process them quickly, then clear the list.
Profiling:

Use Unity Profiler or the Memory Profiler package to see if your forging puzzle or cameo cameo animations produce spikes.
If so, reduce the scope or time they remain in memory.
9) Testing & Profiling
9.1 Profiler & Instruments
Unity Profiler:

Test puzzle combos, forging puzzle transitions, cameo cameo usage. Observe frame times (CPU ms, GPU ms).
Check memory usage in real time, watch for spikes on gem spawning or forging result screens.
Xcode Instruments (iOS):

If iOS is a target, run the game on a real device (e.g., an iPhone 7 or iPhone SE for mid-tier) and watch for memory or CPU usage exceeding thresholds.
9.2 Performance Benchmarks
Worst Case:

Simulate an 8×8 board with multiple combos, a cameo cameo trigger, forging synergy pop-ups, and audio transitions all happening at once.
Ensure the framerate stays above 30 FPS on mid-tier hardware.
Load Testing:

On the server side, simulate hundreds or thousands of puzzle completions per minute to confirm the backend can handle it.
Monitor DB read/write throughput.
Iterate:

If cameo cameo animations cause GPU or CPU bottlenecks, shorten them or reduce their resolution on lower-end devices.
10) Final Verification (Section 16 Conclusion)
Discrete Puzzle Checks: By only updating match logic when gems stop moving, you avoid CPU spikes.
Lightweight FX: Swirl or cameo cameo intros are short, shader-based transitions that can degrade gracefully on low-end devices.
Async Netcode: Most interactions (forging, cameo cameo usage, synergy expansions) are local, with minimal packets to the server.
Memory Management: Addressable assets, object pooling, short audio clips, and intelligent caching keep usage under ~500 MB.
Offline Handling: The user can still do puzzle-combat offline, with results queued for the next sync. The server validates synergy or cameo cameo logs to minimize cheating.
By following these Stage 16 instructions, you’ll ensure your puzzle-RPG runs smoothly across a broad range of devices while maintaining minimal server overhead. Proper profiling, caching, netcode design, and graceful fallback for cameo cameo or synergy expansions keep the user experience fluid and stable, meeting AAA mobile game performance standards.

End of Stage 16 Unity Instructions. With these optimizations and netcode guidelines in place, you secure a performant, scalable puzzle-RPG that can handle high-level synergy combos, cameo cameo usage, forging expansions, and more—all within the constraints of typical mobile hardware and a single-developer backend environment.

STAGE 17: FINAL INTEGRATION & FULL GAMEPLAY LOOP (UNITY INSTRUCTIONS)
Overview & Goal
Goal: Bring together all previously implemented systems (Sections 1–16) into a seamless daily gameplay cycle, incorporating puzzle-combat, forging, realm progression, cameo cameo usage (“Guest Hero Summons”), guild features, live ops, and the overarching quest system.
Scope:
Arranging scene flow to unify Town Hub, Overworld (Regions), Puzzle-Combat nodes, Forging puzzles, Realm Districts, Guild systems, and cameo cameo integration.
Ensuring daily loops and “Elemental Amplifications” synergy function across all relevant managers (BoardManager, RealmManager, MysticForgeManager, etc.).
Activating final monetization and live ops hooks (gacha, forging passes, cameo cameo passes, realm resource passes, guild events) in the Unity project.
1) Scene & Manager Unification
1.1 Scene Hierarchy Overview
PersistentManagers Scene:

Contains the following singleton or DontDestroyOnLoad managers:
GameManager (or a MasterManager that coordinates scene transitions).
MultiRegionManager (handles region/sublocation data, unlocking Hard Mode, etc.).
RealmManager (tracks District Tiers, daily minigame logic).
MysticForgeManager (handles forging puzzle, gear data).
HeroCollectionManager & GachaManager (hero rosters, star rating, cameo cameo references).
QuestManager (daily/weekly/story arcs).
GuildManager (guild membership, resource donations, boss fights, cameo cameo usage if borrowing guild heroes).
LiveOpsManager (day/week synergy buffs, forging weekends, cameo cameo pass promotions).
AudioOverlayManager (audio mixing for puzzle Surges, cameo cameo stings).
Ensure each manager is set to DontDestroyOnLoad so it persists across scene transitions.
TownHub Scene:

The Oakrest layout with:
Main Square UI (merchants, premium shop, daily tasks board).
Realm District Entry button or portal.
Workshop node (forging puzzle entry).
Tavern node (guild chat, cameo cameo desk).
PlayerRoom node (housing, trophies).
Return to Overworld button to open the OverworldMap scene.
OverworldMap Scene:

Displays the 10 Regions (plus Hard Mode toggles if unlocked).
Each Region has 5 sublocations. On selection, transitions to a Sublocation scene or UI.
Sublocation Scene (or UI):

Shows puzzle-combat nodes, mini-boss icons, resource tasks, forging quest nodes if applicable.
Tapping a node transitions to the PuzzleCombat scene.
PuzzleCombat Scene:

Runs the BoardManager logic (8×8 puzzle).
On completion, returns to the Sublocation scene.
ForgingPuzzle Scene:

Runs the MysticForgeManager logic (4×4 forging board).
On completion, returns to the Workshop node in TownHub.
2) Daily Flow & UI Integration
2.1 Daily Planner UI
Implementation:

A central UI panel accessible from the TownHub scene’s DailyPlannerButton or automatically shown on login.
Lists daily/weekly quests from QuestManager, forging tasks, cameo cameo usage counters, realm tier upgrade suggestions, and guild to-dos.
Data Hooks:

QuestManager populates daily tasks (like “Defeat 5 minions,” “Forge 1 Ember item”).
RealmManager references show user’s district Tiers, daily minigames completed or not.
GuildManager indicates guild boss status, resource donation progress.
Rewards & Acknowledgment:

On quest completion or cameo cameo usage achievements, call QuestManager.ClaimReward(questID) from the UI button.
Update synergy item counts, forging tokens, cameo cameo passes accordingly.
2.2 Offline Resource Collection
Upon Login:

RealmManager calls a function CheckOfflineProduction() that calculates how many hours have passed since the last logout.
Award wood/ore/seeds/blossoms up to the offline cap.
Display a pop-up: “You gained X seeds, X wood while offline.”
TownHub UI:

Show the updated resource amounts in the main currency bar (gold, seeds, wood, ore, blossoms).
Cameo Cameo:

If cameo cameo usage tokens refresh daily, show a pop-up: “Your cameo cameo uses have reset to X per day.”
3) Puzzle-Combat & Forging Integration
3.1 Real-Time Puzzle Board
BoardManager Prefab:

Include all logic from Stage 2 (8×8 match detection, corrupted gem spawn, synergy triggers, PhantasmSurge if combo threshold is hit, cameo cameo cameo icons).
For cameo cameo usage, a small UI button or cameo cameo portrait might appear in a corner if the user has an available “Guest Hero Summons” usage.
Damage & Rewards:

On node completion:
Calculate final damage output with synergy or forging gear bonuses.
Grant forging materials, synergy shards, cameo cameo tokens if relevant (based on node data).
Call QuestManager.RecordProgress(QuestType.CombatNode, nodeID, 1) if a quest is tied to this node.
PhantasmSurge & “Elemental Amplifications”:

Ensure forging synergy or realm synergy from RealmManager is applied to the puzzle board config. For example, if Tier 2 Timberland grants +5% Ember gem spawn, reflect that in the board’s SpawnRates.
3.2 Mystic Forge Puzzle
Forge UI in TownHub → Workshop:

Lists available gear recipes, required resources, base success rate, synergy perks.
On user selection of a gear item, a “Forge” button opens the ForgingPuzzle scene.
4×4 Puzzle:

MysticForgeManager: Populates forging board with ~50–60% gems matching the gear’s element, plus Radiant gems at a lower rate.
Each matched set of the gear’s element raises the forging success % by 1 or 2 points, up to a cap.
Completion:

Show the final forging success result. If success, add the gear to user’s inventory, else consume resources and possibly reward forging XP or cameo cameo usage synergy.
QuestManager.RecordProgress(QuestType.ForgeItem, itemID, 1) if relevant.
4) Realm District & Tier Upgrades
4.1 District Scenes or Panels
Implementation:

From TownHub, the user can access a District Menu showing each District’s Tier level, the resources needed for the next upgrade, and a Daily Minigame button.
Upgrade Process:

When the user has enough seeds/wood/ore/gold:
A Upgrade button triggers RealmManager.UpgradeTier(districtID).
If successful, new synergy perks or forging cost reductions unlock. Possibly cameo cameo synergy expansions if the design includes forging cameo logic.
Daily Minigame:

If Stage 3 introduced short chopping/mining/harvesting minigames, open them in a small UI panel or separate scene.
Reward the user with a chunk of resources.
QuestManager.RecordProgress(QuestType.DistrictMinigame, districtID, 1) if needed.
5) Hero Collection, Gacha, & Cameo Cameo Usage
5.1 Hero & Gacha UI
TownHub → Hero Collection:

Shows the user’s heroes, star rarities, levels, synergy with puzzle elements (Ember, Terra, etc.).
A Gacha button opens the Gacha UI (banners, single pull, 10-pull, pity counters).
Performing a Pull:

GachaManager.PerformGachaPull(bannerID) consumes premium gems or tickets.
If a new hero is gained, HeroCollectionManager.AddHero(heroData) updates the roster. Possibly triggers cameo cameo synergy if that hero is cameo-eligible.
5.2 Party Setup & Synergy
Party Screen:

The user selects up to 4 heroes + 1 cameo cameo slot if a friend’s hero is borrowed.
Show synergy bonuses for matching elements, forging gear equipped, or “Elemental Amplifications” if they have realm synergy perks.
Guest Hero Summons:

A cameo cameo usage button or UI list of friends/guildmates’ heroes.
Once selected, the cameo cameo hero can appear in puzzle-combat or forging puzzle (if forging cameo logic is enabled).
GuildManager or HeroCollectionManager tracks cameo cameo usage count, daily limit, or cameo cameo pass benefits.
6) Guild & Co-Op Implementation
6.1 Tavern Node in TownHub
Guild UI:

Guild Chat panel for text messages.
Resource Donation panel: user can donate seeds, wood, ore. GuildManager.DonateResources(playerID, type, amount).
Guild Boss panel: shows boss HP, each member’s damage, cameo cameo usage logs if cameo cameo usage is shared among guildmates.
Guild Missions:

Shown in the Guild UI or Daily Planner if they are weekly tasks.
Rewards synergy shards, forging tokens, cameo cameo expansions if the guild collectively meets targets.
6.2 Asynchronous Guild Boss
Boss Attempt:
The user enters a puzzle-combat scene specifically for the guild boss node.
On completion, damage dealt is posted to the server: GuildManager.SubmitGuildBossDamage(playerID, damage, cameoUsed).
Progress:
The boss’s HP is reduced for all guild members. If the boss is defeated, reward distribution triggers.
Possibly cameo cameo synergy rewards or forging tokens.
7) Live Ops & Monetization
7.1 LiveOpsManager Integration
Initialization:

LiveOpsManager.CheckLiveOps() is called on game start or on daily reset.
Activates daily/weekly forging buffs, synergy expansions (like “Ember Monday” or “Forging Weekend”), cameo cameo pass sales, gacha banners.
Event UI:

The TownHub can have an EventBanner UI showing the active synergy buff or cameo cameo promotion:
“+15% forging success for Ember gear!”
“+2 cameo cameo uses for all players this weekend!”
Time-Limited Quests:

If an event quest is active (like “Corruption Overdrive,” doubling corrupted gems and Radiant gem spawn), show it in the Daily Planner.
Once the event ends, LiveOpsManager deactivates the event flags.
7.2 Shop & Passes
Standard Shop:

Sells premium gems, resource packs, forging passes, cameo cameo passes, realm resource passes.
The user purchases an item → the server updates the user’s profile with the pass benefits.
Battle Pass:

A 14- or 30-day pass awarding synergy items, forging tokens, cameo cameo expansions.
The user’s pass progress is tracked in QuestManager, awarding tiered rewards upon completing daily/weekly tasks.
Gacha Banners:

Rotating featured heroes or synergy gear. Admin can schedule new banners in LiveOpsManager or through a server-side event.
8) Quest & Story Integration
8.1 QuestManager & Sublocation Flow
Branching Quests:

Each Region’s final boss requires ~70% node clearance plus a story quest item.
QuestManager checks progress: if the user completed “Collect EmberKey” or advanced forging synergy quest, they unlock the boss node.
Daily & Weekly Quests:

Tied to forging attempts, cameo cameo usage, guild donations, puzzle-combat nodes.
On completion, QuestManager calls RewardManager.GrantRewards(rewardData), which might include synergy shards or cameo cameo tokens.
Story Scenes:

Minimal cutscenes or dialogues appear in Sublocation or TownHub transitions. They can be toggled in user settings if they prefer a skip.
9) Final Performance & Netcode Checks
9.1 Performance Profiling
TownHub:

Verify that loading the TownHub with multiple UI panels (Realm District, Shop, Tavern, forging node) maintains stable FPS on mid-range devices.
Check memory usage for loaded assets.
Puzzle-Combat:

Confirm the puzzle manager runs at 30–60 FPS during mass combos, cameo cameo triggers, forging synergy pop-ups, or big corrupted gem spawns.
Forging Puzzle:

The 4×4 forging puzzle must remain smooth. Pool forging gem objects, keep VFX short.
9.2 Netcode Logging
Local Save & Sync:

If the user goes offline, the system queues puzzle results, forging attempts, cameo cameo usage logs.
Upon reconnection, logs are posted to the server. The server performs minimal validation and updates the user’s profile.
Guild & Leaderboard:

The server aggregates daily or weekly stats. The user sees updated ranks or guild resource totals.
Watch for suspicious forging success rates or cameo cameo usage frequency.
Cheating Prevention:

If synergy expansions or cameo cameo usage appear impossible, log them for manual review or automatic partial bans.
10) Shipping & Post-Launch Maintenance
10.1 Final Build Pipeline
Platforms:

Android: Generate an .apk or .aab with IL2CPP, minify code for release, sign with your keystore.
iOS: Export an Xcode project, verify game runs at consistent performance on iPhone 8, iPhone 12, etc.
Addressable Bundles:

Build & upload environment + puzzle assets to a CDN if needed, so the user can download them on demand.
Beta Testing:

Provide the build to testers. Gather feedback on forging synergy clarity, cameo cameo usage flows, puzzle difficulty.
10.2 Live Ops & Data-Driven Updates
Server Panel:

Adjust synergy spawn rates, forging costs, cameo cameo pass durations from the admin dashboard.
Roll out new region expansions, gear sets, or cameo cameo heroes with minimal app updates.
Continuous Improvement:

Watch analytics: if many players quit after failing forging attempts or not using cameo cameo, consider adjusting success rates or cameo cameo freebies.
Introduce Hard Mode or Endless Tower expansions from Stage 12 if the user base demands more late-game content.
Stage 17 Conclusion
By following these Stage 17 instructions in Unity, you unify all previously implemented modules and features—Puzzle-Combat with synergy expansions, forging puzzle, realm progression, cameo cameo usage, guild systems, quest arcs, and monetization—into a coherent daily gameplay loop.

The TownHub acts as the central hub for forging, realm upgrades, guild interactions, cameo cameo usage, and quest acceptance.
The Overworld and Sublocations let players engage in puzzle-combat nodes, gather forging materials, and progress the story.
The Daily Planner ties together quests, forging tasks, cameo cameo usage counters, and realm objectives in one user-friendly UI, ensuring each day’s session feels structured and rewarding.
LiveOpsManager orchestrates dynamic events or synergy buffs, cameo cameo pass promotions, or forging weekends.
With data-driven toggles and minimal code overhead, a single developer can maintain, expand, and balance the entire puzzle-RPG post-launch, sustaining high retention and monetization potential.
This final stage ensures everything runs smoothly as a single, AAA-quality mobile puzzle-RPG with real-time matching, “Elemental Amplifications,” cameo cameo synergy, forging mini-puzzles, realm progression, guild co-op, robust questing, and carefully integrated monetization.

End of Stage 17 Unity Instructions. You have now completed the comprehensive blueprint and its Unity integration for a fully operational puzzle-RPG, ready for live ops, expansions, and a sustainable endgame.